' Gambas class file

Export

Static Public _ObjectCache As New Collection

Static Private $cType As Collection = [
  "b": "b", 
  "c": "y", 
  "h": "n",
  "i": "i",
  "l": "x",
  "p": "x",
  "g": "d",
  "f": "d",
  "d": "d",
  "s": "s",
  "v": "v",
  "DBusObject": "o",
  "Collection": "a{sv}",
  "Boolean[]": "ab",
  "Byte[]": "ay",
  "Short[]": "an",
  "Integer[]": "ai",
  "Long[]": "ax",
  "Pointer[]": "ax",
  "Single[]": "ad",
  "Float[]": "ad",
  "Date[]": "ad",
  "String[]": "as",
  "Variant[]": "av"]
  
Static Private $sName As String

Property Read _Path As String

Private $sFullPath As String
Private $sPath As String
Private $sInterface As String
Private $aInterface As String[]
Private $aChildren As String[]
Private $hObserver As DBusObserver
Private $iRegister As Integer
Private $bRegisterParent As Boolean

Static Private Sub IsDBusValues(sType As String) As Boolean
  
  Dim hClass As Class
  
  If sType = "DBusValues" Then Return True
  
  Try hClass = Classes[sType]
  If Not hClass Then Return
  If Not hClass.Parent Then Return
  
  Return IsDBusValues(hClass.Parent.Name)
  
End

Static Private Sub IsDBusVariant(sType As String) As Boolean
  
  Dim hClass As Class
  
  If sType = "DBusVariant" Then Return True
  
  Try hClass = Classes[sType]
  If Not hClass Then Return
  If Not hClass.Parent Then Return
  
  Return IsDBusVariant(hClass.Parent.Name)
  
End


Static Private Sub ConvType(sType As String) As String

  Dim sSign As String
  Dim hClass As Class
  
  sSign = $cType[sType]
  
  If Not sSign And If IsDBusVariant(sType) Then
    hClass = Classes[sType]
    sSign = hClass["Signature"].Value
  Endif
  
  Return sSign
      
End

Public Sub _AddChild(sChild As String)
  
  If Not $aChildren Then $aChildren = New String[]
  $aChildren.Add(sChild)
  
End

Public Sub _RemoveChild(sChild As String)
  
  Dim iPos As Integer
  
  If Not $aChildren Then Return
  iPos = $aChildren.Find(sChild)
  If iPos >= 0 Then
    $aChildren.Remove(iPos)
    If $aChildren.Count = 0 Then $aChildren = Null
  Endif
  
End


Public Sub _Register(hConnection As DBusConnection, sFullPath As String, Optional aInterface As String[])
  
  Dim hParent As DBusObject
  Dim sParent As String
  Dim iPos As Integer
  Dim sService As String
  Dim sPath As String
  
  If $sFullPath Then
    If $sFullPath <> sFullPath Then Error.Raise("Object already registered")
    Inc $iRegister
    Return
  Endif
  
  Inc $iRegister
  
  If Not $sName Then 
    $sName = DBus._RegisterApplication(hConnection)
    If Not DBus.Unique Then $sName = Left($sName, - Len(CStr(Application.Id)) - 1)
  Endif
  
  iPos = InStr(sFullPath, "/")
  If iPos = 0 Then Error.Raise("Bad object path")
  sService = Left(sFullPath, iPos - 1)
  sPath = Mid$(sFullPath, iPos)
  
  If _ObjectCache.Exist(sFullPath) Then Error.Raise("Path already used")
  
  $sFullPath = sFullPath
  $sPath = sPath
  'Debug Me;; $sFullPath; " | "; $sPath
  
  $sInterface = DBus._Normalize($sName & "." & Object.Class(Me).Name)
  If aInterface Then $aInterface = aInterface.Copy()
  
  _ObjectCache[sFullPath] = Me
  
  If sPath <> "/" Then
    
    sParent = File.Dir(sPath)
    hParent = _ObjectCache[sService &/ sParent]
    If Not hParent Then
      $bRegisterParent = True
      hParent = New DBusObject
      hParent._Register(hConnection, sService &/ sParent)
    Endif
  
    hParent._AddChild(File.Name(sPath))
    
  Endif

  $hObserver = New DBusObserver(hConnection, DBus.Method, sPath, "", "", sService) As "DBusObserver"
  
End

Public Sub _Unregister(hConnection As DBusConnection)
  
  Dim sChild As String
  Dim hChild As DBusObject
  Dim sParent As String
  Dim hParent As DBusObject
  Dim sService As String
  Dim iPos As Integer
  Dim sPath As String
  
  Dec $iRegister
  If $iRegister > 0 Then Return
  
  iPos = InStr($sFullPath, "/")
  sService = Left($sFullPath, iPos - 1)
  sPath = Mid$($sFullPath, iPos)
  
  If $bRegisterParent Then
    
    $bRegisterParent = False
    sParent = File.Dir(sPath)
    hParent = _ObjectCache[sService &/ sParent]
    If hParent Then
      hParent._Unregister(hConnection)
      Return
    Endif
    
  Endif
  
  If $aChildren Then
    For Each sChild In $aChildren.Copy()
      hChild = _ObjectCache[$sFullPath &/ sChild]
      hChild._Unregister(hConnection)
    Next
    $aChildren = Null
  Endif
  
  hParent = _ObjectCache[File.Dir($sFullPath)]
  If hParent Then hParent._RemoveChild(File.Name($sFullPath))
  
  $hObserver = Null
  _ObjectCache[$sFullPath] = Null
  $sFullPath = ""
  $sPath = ""
  
  If _ObjectCache.Count = 0 Then 
    DBus._UnregisterApplication(hConnection)
    $sName = ""
  Endif
  
End

Static Private Sub ToDBusSignature(sSign As String) As String[]
  
  Dim aResult As New String[]
  Dim sOne As String
  Dim iPos As Integer
  Dim sClass As String
  
  If Not sSign Then 
    If DBus.Debug Then Error "gb.dbus: void signature"
    Return aResult
  Endif
  
  While sSign
    
    If IsLCase(Left(sSign)) Then
      
      sOne = ConvType(Left(sSign))
      sSign = Mid$(sSign, 2)
      
    Else
      
      iPos = InStr(sSign, ";")
      If iPos Then
        sClass = Left(sSign, iPos - 1)
        sSign = Mid$(sSign, iPos + 1)
      Else
        sClass = sSign
        sSign = ""
      Endif
      
      sOne = ConvType(sClass)
      
    Endif
    
    If Not sOne Then 
      If DBus.Debug Then Error "gb.dbus: cannot convert signature for "; sClass
      Return
    Endif
    
    aResult.Add(sOne)
    
  Wend
    
  Return aResult
  
End




Public Sub _Introspect() As String
  
  Dim sRes As String
  Dim sChild As String
  Dim sSymbol As String
  Dim hClass As Class
  Dim bHasProperty As Boolean
  Dim bHasMethod As Boolean
  Dim sType As String
  Dim sArg As String
  Dim iInd As Integer
  Dim cDescInterface As New Collection
  Dim sDesc As String
  Dim sInterface As String
  Dim sPrefix As String
  Dim aSign As String[]
  Dim sKind As String
  Dim sSign As String
  Dim bReadOnly As Boolean
  Dim bMulti As Boolean
  Dim aType As String[]
  Dim I As Integer
  
  sRes &= "<!DOCTYPE node PUBLIC \"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN\" \"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd\">\n"
  sRes &= "<node>\n"
  
  sRes &= "  <interface name=\"org.freedesktop.DBus.Introspectable\">\n"
  sRes &= "    <method name=\"Introspect\">\n"
  sRes &= "      <arg name=\"xml_data\" type=\"s\" direction=\"out\"/>\n"
  sRes &= "    </method>\n"
  sRes &= "  </interface>\n"
  
  
  hClass = Object.Class(Me)
  
  For Each sSymbol In hClass.Symbols
    With hClass[sSymbol]
      If Left(sSymbol) = "_" Then Continue
      If .Static Then Continue
      If .Kind = Class.Property Then 
        bHasProperty = True
      Else If .Kind = Class.Method Then
        bHasMethod = True
      Endif
    End With
  Next
  
  sRes &= "  <interface name=\"org.freedesktop.DBus.Peer\">\n"
          "    <method name=\"Ping\"/>\n"
          "    <method name=\"GetMachineId\">\n"
          "      <arg name=\"machine_uuid\" type=\"s\" direction=\"out\"/>\n"
          "    </method>\n"
          "  </interface>\n"
  
  If bHasProperty Then
    sRes &= "  <interface name=\"org.freedesktop.DBus.Properties\">\n"
            "    <method name=\"Get\">\n"
            "      <arg name=\"interface_name\" type=\"s\" direction=\"in\"/>\n"
            "      <arg name=\"property_name\" type=\"s\" direction=\"in\"/>\n"
            "      <arg name=\"value\" type=\"v\" direction=\"out\"/>\n"
            "    </method>\n"
            "    <method name=\"Set\">\n"
            "      <arg name=\"interface_name\" type=\"s\" direction=\"in\"/>\n"
            "      <arg name=\"property_name\" type=\"s\" direction=\"in\"/>\n"
            "      <arg name=\"value\" type=\"v\" direction=\"in\"/>\n"
            "    </method>\n"
            "    <method name=\"GetAll\">\n"
            "      <arg name=\"interface_name\" type=\"s\" direction=\"in\"/>\n"
            "      <arg name=\"values\" type=\"a{sv}\" direction=\"out\"/>\n"
            "    </method>\n"
            "  </interface>\n"
  Endif
  
  For Each sSymbol In hClass.Symbols
    
    With hClass[sSymbol]
      
      If .Kind = Class.Event Then
        sSymbol = Mid$(sSymbol, 2)
      Else
        If .Static Then Continue
      Endif
    
      sPrefix = ""
      If $aInterface Then
        For Each sInterface In $aInterface
          sPrefix = LCase(Replace(sInterface, ".", "_") & "_")
          If LCase(sSymbol) Begins sPrefix And RInStr(sSymbol, "_") <= Len(sPrefix) Then Break
          sPrefix = ""
        Next
      Endif
      
      sSymbol = Mid$(sSymbol, Len(sPrefix) + 1)
      
      If InStr(sSymbol, "_") Then Continue
      
      sDesc = ""
      sType = ""
      sKind = .Kind
      sSign = .Signature
      bReadOnly = .ReadOnly
      
      If .Type Then
        sType = .Type
        bMulti = IsDBusValues(sType)
        sType = ConvType(sType)
        If Not sType Then Continue
      Endif
      
    End With
    
    Select Case sKind

      Case Class.Method, Class.Event

        aSign = ToDBusSignature(sSign)
        If Not aSign Then Continue
        
        sArg = ""

        For iInd = 0 To aSign.Max
          sArg &= "      <arg name=\"arg" & CStr(iInd + 1) & "\" type=\"" & aSign[iInd] & "\"/>\n"
        Next

        If sKind = Class.Event Then
          
          sDesc &= "    <signal name=\"" & sSymbol & "\">\n"
          If sArg Then sDesc &= sArg
          sDesc &= "    </signal>\n"
          
        Else
          
          sDesc &= "    <method name=\"" & sSymbol & "\">\n"
        
          If sArg Then sDesc &= sArg
          
          If sType Then
            If bMulti Then
              aType = DBus._SplitSignature(sType)
              For I = 0 To aType.Max
                sDesc &= "      <arg name=\"value" & CStr(I + 1) & "\" type=\"" & aType[I] & "\" direction=\"out\"/>\n"
              Next
            Else
              sDesc &= "      <arg name=\"value\" type=\"" & sType & "\" direction=\"out\"/>\n"
            Endif
          Endif
          
          sDesc &= "    </method>\n"
          
        Endif
        
      Case Class.Property
        
        sDesc &= "    <property name=\"" & sSymbol & "\" type=\"" & sType & "\" access=\"" & If(bReadOnly, "read", "readwrite") & "\"/>\n"
        
    End Select
    
    If sPrefix Then
      cDescInterface[sInterface] &= sDesc
    Else
      cDescInterface[$sInterface] &= sDesc
    Endif
      
  Next
  
  For Each sDesc In cDescInterface
    sRes &= "  <interface name=\"" & cDescInterface.Key & "\">\n" & sDesc & "  </interface>\n"
  Next
  
  If $aChildren Then
    For Each sChild In $aChildren.Sort()
      sRes &= "  <node name=\"" & sChild & "\"/>\n"
    Next
  Endif
  
  sRes &= "</node>\n"
  
  Return sRes
  
End

Private Sub GetProperty()
  
  Dim sInterface As String
  Dim sProperty As String
  
  With $hObserver.Message
  
    sInterface = .Arguments[0]
    sProperty = .Arguments[1]
    
    If $aInterface And If sInterface <> $sInterface Then
      sProperty = Replace(sInterface, ".", "_") & "_" & sProperty
    Else
      If InStr(sProperty, "_") Then Return
    Endif
    
    $hObserver.Reply("v", [Object.GetProperty(Me, sProperty)])
    
  End With
  
Catch
  
  If DBus.Debug Then Error "gb.dbus: org.freedesktop.Properties.Get: error: "; Error.Text
  $hObserver.Error(Error.Text)
  
End

Private Sub GetAllProperties()
  
  Dim cVal As New Collection
  Dim sWantInterface As String
  Dim hClass As Class
  Dim sSymbol As String
  Dim sInterface As String
  Dim sPrefix As String
  Dim sProp As String
  Dim vVal As Variant
  Dim hObs As DBusObserver
  Dim bComma As Boolean
  
  hObs = $hObserver
  
  With hObs.Message
  
    sWantInterface = .Arguments[0]
    
    hClass = Object.Class(Me)
    
    'Debug "[";; System.Backtrace.Join(" ")
    
    For Each sSymbol In hClass.Symbols

      With hClass[sSymbol]
        
        If .Kind <> Class.Property Then Continue
        If .Static Then Continue
        
        sPrefix = ""
        If $aInterface Then
          For Each sInterface In $aInterface
            sPrefix = LCase(Replace(sInterface, ".", "_") & "_")
            If LCase(sSymbol) Begins sPrefix And RInStr(sSymbol, "_") <= Len(sPrefix) Then Break
            sPrefix = ""
          Next
        Endif
        
        sProp = Mid$(sSymbol, Len(sPrefix) + 1)
        If InStr(sProp, "_") Then Continue
        
        If Not sPrefix Then sInterface = $sInterface
        
        If sInterface <> sWantInterface Then Continue
        
        'Debug sSymbol; " @ "; sInterface
    
        vVal = Object.GetProperty(Me, sSymbol)
        If IsNull(vVal) Then
          If TypeOf(vVal) = gb.String Then
            cVal[sProp] = DBus.Null
            'Debug sProp; ": "; "DBus.Null"
          Endif
        Else
          cVal[sProp] = vVal
          'If TypeOf(vVal) = gb.Object Then Debug sProp; ": "; vVal
        Endif
        
      End With
    Next
    
    'Debug "]"
    
    If DBus.Debug Then
      Error "gb.dbus: GetAll("; Quote(sWantInterface); "): [";
      For Each vVal In cVal
        If bComma Then 
          Error ", ";
        Else
          bComma = True
        Endif
        Error Quote(cVal.Key); ": "; vVal;
      Next
      Error "]"
    Endif
    
    hObs.Reply("a{sv}", [cVal])
    
  End With
  
Catch
  
  If DBus.Debug Then Error "gb.dbus: error: org.freedesktop.Properties.GetAll: "; Error.Text;; Error.Backtrace.Join(" ")
  hObs.Error(Error.Text)
  
End

Private Sub SetProperty()
  
  Dim sInterface As String
  Dim sProperty As String
  Dim vValue As Variant
  
  With $hObserver.Message
  
    sInterface = .Arguments[0]
    sProperty = .Arguments[1]
    vValue = .Arguments[2]
    
    If $aInterface And If sInterface <> $sInterface Then
      sProperty = Replace(sInterface, ".", "_") & "_" & sProperty
    Else
      If InStr(sProperty, "_") Then Return
    Endif
    
    Object.SetProperty(Me, sProperty, vValue)
    
  End With
  
Catch
  
  If DBus.Debug Then Error "gb.dbus: org.freedesktop.Properties.Set: error: "; Error.Text
  $hObserver.Error(Error.Text)
  
End


Public Sub DBusObserver_Message()
  
  Dim vVal As Variant
  Dim sMethod As String
  Dim sInterface As String
  Dim sType As String
  Dim hObs As DBusObserver
  
  hObs = $hObserver
  
  sMethod = hObs.Message.Member
  sInterface = hObs.Message.Interface
  
  If DBus.Debug Then Error "gb.dbus: call: ["; hObs.Message.Destination; "]";; sInterface;; sMethod
  
  If InStr(sMethod, "_") Then Return
  
  If sInterface = "org.freedesktop.DBus.Introspectable" Or If Not sInterface Then
    If sMethod = "Introspect" Then
      hObs.Reply("s", [_Introspect()])
      Return
    Endif
  Endif
  
  If sInterface = "org.freedesktop.DBus.Properties" Or If Not sInterface Then
    If sMethod = "Get" Then
      GetProperty()
      Return
    Else If sMethod = "Set" Then
      SetProperty()
      Return
    Else If sMethod = "GetAll" Then
      GetAllProperties()
      Return
    Endif
  Endif
  
  If $aInterface And If sInterface <> $sInterface Then
    sMethod = Replace(sInterface, ".", "_") & "_" & sMethod
  Endif

  sType = Object.Class(Me)[sMethod].Type
  
  If sType Then
    vVal = Object.Call(Me, sMethod, hObs.Message.Arguments)
    If TypeOf(vVal) = gb.Object And If vVal Is DBusValues Then
      sType = vVal.Signature
      hObs.Reply(sType, vVal.Value)
    Else If TypeOf(vVal) = gb.Object And If vVal Is DBusVariant Then
      sType = vVal.Signature
      hObs.Reply(sType, [vVal.Value])
    Else
      sType = ConvType(sType)
      If Not sType Then sType = "v"
      hObs.Reply(sType, [vVal])
    Endif
  Else
    Object.Call(Me, sMethod, hObs.Message.Arguments)
    hObs.Reply()
  Endif

Catch

  If DBus.Debug Then Error "gb.dbus: "; sInterface; "."; sMethod; ": error: "; Error.Text;; Error.Backtrace.Join(" ")
  hObs.Error(Error.Text)
  
End


Public Sub _Raise(hConnection As DBusConnection, sSignal As String, aArg As Object)

  Dim hClass As Class
  Dim aSign As String[]
  Dim iPos As Integer
  Dim sInterface As String
  Dim sSymbol As String
  
  If Not $sFullPath Then Error.Raise("DBus object is not registered")
  
  hClass = Object.Class(Me)
  sSymbol = ":" & Replace(sSignal, ".", "_")
  If Not hClass.Exist(sSymbol) Then Error.Raise("Unknown signal")

  With hClass[sSymbol]
    aSign = ToDBusSignature(.Signature)
    If Not aSign Then Error.Raise("Unknown signal")
  End With
  
  iPos = RInStr(sSignal, ".")
  If iPos Then
    sInterface = Left(sSignal, iPos - 1)
    sSignal = Mid$(sSignal, iPos + 1)
  Else
    sInterface = $sInterface
  Endif
  
  iPos = InStr($sFullPath, "/")
  hConnection._SendSignal(Mid$($sFullPath, iPos), sInterface, sSignal, aSign.Join(""), aArg)
  
End


Private Function _Path_Read() As String

  Return $sPath

End
