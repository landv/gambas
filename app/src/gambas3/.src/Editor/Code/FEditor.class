' Gambas class file

' Gambas 3
' Integrated Development Environment for Gambas
'
' Copyright (C) Benoît Minisini, Fabien Bodard, Charlie Reinl, José Luis Redrejo, Robert Rowe
'
' This program is free software; you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation; either version 2 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 51 Franklin St, Fifth Floor,
' Boston, MA  02110-1301  USA
'

Public Path As String '' Source file absolute path.
Public Editor As Editor '' The current Editor control.
Public Scan As Collection '' The result of the class symbol analyze.
Public ParentClass As String '' The parent class.
Public ParentComponent As String '' The component of the parent class.
Public AutoCreatable As Boolean '' If the class has "[CREATESTATIC|CREATE STATIC]".
Public NotCreatable As Boolean '' If the class has "[CREATEPRIVATE|CREATE PRIVATE]".
Public Age As Integer '' The text age. It is incremented each time the text is modified

Property Read ReadOnly As Boolean '' If the editor is read-only.

Public Const IDENT_CAR As String = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_$"
Public Const NBR_COLOR As Integer = 15

Static Public StructControlCompletion As Boolean = True
Static Public LocalVariableDeclaration As Boolean = False
Static Public ExpressionStart As Integer

Static Private $cStructClose As New Collection(gb.IgnoreCase)

Static Private $hVirtualSymbol As New CSymbolInfo

Static Private $bPublic As Boolean
Static Private $bStatic As Boolean
Static Private $sName As String

Private $bModify As Boolean
'PRIVATE $cLine AS NEW Collection
Private $bToolbar As Boolean
Private $iLastLine As Integer
Private $hSymbol As CSymbolInfo
Private $bCheckSignature As Boolean
Private $iArgSignature As Integer
Private $iPosSignature As Integer
Private $bCompletion As Boolean
Private $bCleanOnSave As Boolean
Private $bShowPopupHelp As Boolean

Private $bDoNotSavePosition As Boolean

Private Const TYPE_SYMBOL As Integer = 0
Private Const TYPE_FUNCTION As Integer = 1
Private Const TYPE_ARRAY As Integer = 2

Private $bLastStatic As Boolean

Private $iViewMode As Integer
Private VIEWMODE_NORMAL As Integer = 0
Private VIEWMODE_HORIZONTAL As Integer = 1
Private VIEWMODE_VERTICAL As Integer = 2

Private $hEditor1 As Editor
Private $hEditor2 As Editor

Private $cProc As New Collection(gb.IgnoreCase)
Private $aProc As New String[]
Private $iFirstProcLine As Integer

Private $sModule As String

Private $hSampleCode As CSampleCode
Private $iSampleStart As Integer
Private $iSampleEnd As Integer
Private $iSamplePos As Integer

Private $hInsertColor As CInsertColor
Private $hBookmark As CBookmark

Static Private $cLastClassCount As New Collection


Static Public Sub _init()

  $cStructClose["DO"] = "Loop"
  $cStructClose["WHILE"] = "Wend"
  $cStructClose["REPEAT"] = "Until"
  $cStructClose["SELECT"] = "End Select"
  $cStructClose["FOR"] = "Next"
  $cStructClose["WITH"] = "End With"
  $cStructClose["ELSE"] = "<"
  $cStructClose["CASE"] = "<"
  $cStructClose["DEFAULT"] = "<"
  $cStructClose["CATCH"] = "<"
  $cStructClose["FINALLY"] = "<"
  
  StructControlCompletion = Settings["/Editor/ControlStructCompletion", 1]
  LocalVariableDeclaration = Settings["/Editor/LocalVariableDeclaration", 0]
  
End

Public Sub _new(sPath As String)

  Dim hModule As CModule

  $iLastLine = -1

  Path = sPath
  Me.Name = File.BaseName(Path)

  SetReadOnly

  Editor = edtEditor
  edtEditor.Flags[Editor.HighlightBraces] = True
  'edtEditor.Flags[Editor.ShowCursorPosition] = True
  edtEditor.Highlight = Highlight.Gambas

  $hInsertColor = New CInsertColor(btnInsertColor, Editor)
  $hBookmark = New CBookmark(Editor, btnBookmark, mnuBookmark)

  ' If Not frmCompletion Then
  '   frmCompletion = New FCompletion(Me)
  '   frmCompletion.Hide
  '   frmSignature = New FSignature(Me)
  '   frmSignature.Hide
  ' Endif

  ReadConfig
  Refresh

  'Editor = edtEditor
  Me.Icon = Picture["img/16/" &/ File.ext(sPath) & ".png"]

  For Each hModule In CModule.All
    If Exist(File.SetExt(Path, hModule.Key)) Then
      $sModule = hModule.Key
      btnForm.Visible = True
    Endif
  Next

  $bDoNotSavePosition = True

End

Public Sub Refresh()

  edtEditor.TabSize = Project.TabSize
  If $hEditor1 Then $hEditor1.TabSize = Project.TabSize
  If $hEditor2 Then $hEditor1.TabSize = Project.TabSize

End

Private Sub ReadConfigEditor(hEditor As Editor)

  hEditor.ReadConfig

End

Public Sub ReadConfig()

  $bToolBar = Settings["/Editor/Toolbar", True]
  panToolbar.Visible = $bToolbar
  Form_Arrange

  ReadConfigEditor(edtEditor)
  If $hEditor1 Then ReadConfigEditor($hEditor1)
  If $hEditor2 Then ReadConfigEditor($hEditor2)

  $bCompletion = Settings["/Editor/Completion", True]
  $bCleanOnSave = Settings["/Editor/CleanOnSave", False]

  $bShowPopupHelp = Settings["/Editor/ShowPopupHelp", True]

  Project.SetSmallFont(panToolbar)

  RefreshBackground

End

Public Function Save(Optional bReset As Boolean) As Boolean

  Dim sHeader As String

  If Me.ReadOnly Then Return
  If Not $bModify Then
    If bReset Then Editor.Reset
    Return
  Endif

  Editors_Scroll
  
  Save.Begin(Path)

  '   IF $bCleanOnSave THEN
  '
  '     iProc = -1
  '     iLine = edtEditor.Line
  '     iCol = edtEditor.Column
  '
  '     iCount = edtEditor.Lines.Count
  '     FOR iLig = 0 TO iCount
  '
  '       IF iLig < iCount THEN
  '         sLig = RTrim(edtEditor.Lines[iLig])
  '       ELSE
  '         sLig = "SUB gambas()"
  '       ENDIF
  '
  '       IF NOT LTrim(sLig) THEN
  '         INC iVoidLine
  '         CONTINUE
  '       ENDIF
  '
  '       IF IsProc(sLig) THEN
  '         IF iProc >= 0 THEN
  ' '           IF iFull < 2 THEN
  ' '             bChange = TRUE
  ' '             sData = Left(sData, iPosProc)
  ' '             IF iLine > iProc THEN
  ' '               IF iLine < iLig THEN
  ' '                 iLine = iProc - 1
  ' '               ELSE
  ' '                 iLine = iLine - (iLig - iProc + 1)
  ' '               ENDIF
  ' '             ENDIF
  ' '           ENDIF
  '         ENDIF
  '         iProc = iLig
  '         iFull = 0
  '         iPosProc = Len(sData)
  '       ELSE
  '         INC iFull
  '       ENDIF
  '
  '       IF iLig < iCount THEN
  '         sData = sData & String(iVoidLine, "\n") & sLig & "\n"
  '         iVoidLine = 0
  '       ENDIF
  '
  '     NEXT
  '
  '   'IF Len(sData) <> Len(edtEditor.Text) THEN
  '   File.Save(Path, sData)
  '
  '   IF bChange THEN
  '
  '     edtEditor.Text = sData
  '     bReset = TRUE
  '     'TRY edtEditor.Line = iLine
  '     'IF NOT ERROR THEN
  '     '  TRY edtEditor.Column = iCol
  '     'ENDIF
  '     edtEditor.Goto(iLine, iCol)
  '
  '   ENDIF
  '
  ' ELSE

  sHeader = "' Gambas " & File.Ext(Path) & " file"

  Editor.Begin

  If RTrim(Editor.Lines[0].Text) <> sHeader Then
    Editor.Insert(sHeader & "\n", 0, 0)
  Endif

  If Editor.Lines.Count < 2 Or If Editor.Lines[1].Text Then
    Editor.Insert("\n", 1, 0)
  Endif

  Editor.End
  
  Editor.HighlightAll
  If Settings["/FormatCode/FormatOnLoad"] Then MPrettyCode.Run(edtEditor)
  File.Save(Path, Editor.Text)

  ' ENDIF

  $bModify = False
  DrawTitle

  If bReset Then Editor.Reset

  Save.End()

Catch

  Return Save.Error()

End

Private Sub DrawTitle()

  Project.DrawTitle(Me)

End

' Private Sub DrawInfo()
'
'   lblEditor.Text = CStr(Editor.Line + 1) & ":" & CStr(Editor.Column + 1)
'
' End

Public Sub Modify(Optional bReset As Boolean)

  If Me.ReadOnly Then Return

  If bReset Then

    If Not $bModify Then Return
    $bModify = False

  Else

    $bModify = True
    Inc Project.TimeStamp
    Inc Age
    $cProc.Clear ' = New Collection
    $aProc.Clear ' = New String[]

    FSearch.OnFileChange(Me.Path)
    FDebugInfo.RefreshTabs(Me.Path, Me.Name)

  Endif

  DrawTitle

End

Public Sub Delete()
  
  FSearch.OnFileChange(Me.Path)
  FDebugInfo.RefreshTabs(Me.Path, Me.Name)
  Super.Delete
  
End

Public Sub Rename(sNewName As String, sNewPath As String)

  Dim sOldName As String = Me.Name
  Dim sOldPath As String = Me.Path

  Me.Name = sNewName
  Path = sNewPath 'File.Dir(Path) &/ sNewName & "." & File.Ext(Path)
  DrawTitle

  FSearch.OnFileChange(sOldPath)
  FDebugInfo.RefreshTabs(sOldPath, sOldName)

  FSearch.OnFileChange(Me.Path)
  FDebugInfo.RefreshTabs(Me.Path, Me.Name)

End


Public Function IsModified() As Boolean

  Return $bModify

End

Public Sub Form_Arrange()

  ' Dim iToolbarOffset As Integer
  '
  ' If $bToolbar Then
  '   panToolBar.Move(0, 0, Me.ClientW)
  '   iToolbarOffset = panToolBar.H
  ' Else
  '   iToolbarOffset = 0
  ' Endif
  '
  ' Select Case $iViewMode
  '   Case VIEWMODE_NORMAL
  '     edtEditor.Move(0, iToolbarOffset, Me.ClientW, Me.ClientH - iToolbarOffset)
  '   Case VIEWMODE_HORIZONTAL
  '     splHorizontal.Move(0, iToolbarOffset, Me.ClientW, Me.ClientH - iToolbarOffset)
  '   Case VIEWMODE_VERTICAL
  '     splVertical.Move(0, iToolbarOffset, Me.ClientW, Me.ClientH - iToolbarOffset)
  ' End Select

  'ResizeProcList

End

Public Sub Editors_Change()

  Modify

End

Private Sub RefreshLineInfo(Optional bForce As Boolean) As Boolean

  Dim bNewLine As Boolean

  If bForce Then
    $iLastLine = -1
  Endif

  If Editor.Line <> $iLastLine Then

    $iLastLine = Editor.Line

    UpdateFunction
    timProc.Stop
    timProc.Start

    If IsModified() Then {Scan} = Null

    If $hSampleCode Then
      If Editor.Line < $iSampleStart Or If Editor.Line >= $iSampleEnd Then
        $hSampleCode = Null
      Endif
    Endif
    
    bNewLine = True

  Else If $bCheckSignature Or If FSignature.VisibleFrom(Editor) Then
    
    $bCheckSignature = False
    CheckSignature
    
  Endif

  lblInfo.Text = CStr(Editor.Column + 1) & ":" & CStr(Editor.Line + 1)
  Return bNewLine

End

Public Sub Editors_Cursor()

  If RefreshLineInfo() Then
    HideMessage
    HideCompletion
    HideSignature
  Endif

  If Editor.Line = Editor.CurrentLine Then Design.CheckErrorMessage(Me)

  CPosition.SaveCurrent

End

Public Sub Form_GotFocus()

  Editor.SetFocus

End

Public Sub Form_Deactivate()

  'HideCompletion
  'HideSignature
  'mnuEditor.Enabled = False

End

Public Sub Goto(iLine As Integer, Optional iColumn As Integer = -1, Optional bCenter As Boolean)

  'DEC iLine
  If iColumn < 0 Then iColumn = Editor.Column

  If iLine < 0 Then
    iLine = 0
  Else If iLine >= Editor.Lines.Count Then
    iLine = Editor.Lines.Count - 1
    iColumn = Editor.Lines[iLine].Length
  Endif

  If Not Editor.Lines[iLine].Limit Then Editor.Lines[iLine].Expanded = True
  Editor.Goto(iLine, iColumn, bCenter)

End

Public Sub GotoCenter(iLine As Integer, Optional iColumn As Integer = -1)

  Me.Goto(iLine, iColumn, True)

End

Public Sub Editors_Menu()

  mnuForm.Visible = Project.ExistForm(Me.Name)
  CreateMenu
  mnuEditor.Popup

End

Private Sub CreateMenu()

  Dim sName As String
  Dim hMenu As Menu
  Dim cFunc As New String[]
  Dim sParent As String
  Dim sNewParent As String
  Dim hParent As Menu
  Dim sFullName As String
  Dim iPos As Integer
  Dim hSymbol As CSymbolInfo
  Dim cSymbol As Collection

  'DIM hPoint AS Picture

  'IF $hMenuGo THEN $hMenuGo.Delete

  '$hMenuGo = NEW Menu(mnuEditor)
  '$hMenuGo.Caption = "&Go to"

  Inc Application.Busy

  mnuGoto.Children.Clear

  cSymbol = CComponent.GetClassSymbols(Me.Name)

  For Each hSymbol In cSymbol

    If LCase(hSymbol.Kind) <> "m" Then Continue
    If hSymbol.LineNumber = 0 Then Continue
    cFunc.Add(hSymbol.Name)

  Next

  cFunc.Sort(gb.IgnoreCase + gb.Natural)
  hParent = mnuGoto

  'hPoint = Picture["img/16/point.png"]

  For Each sName In cFunc

    hSymbol = cSymbol[sName]
    sFullName = sName

    iPos = InStr(sName, "_")
    If iPos Then
      sNewParent = Left$(sName, iPos - 1)
      sName = Mid$(sName, iPos + 1)
      If Len(sNewParent) = 0 Then
        sNewParent = "(Special)"
        sName = "_" & sName
      Endif
    Else
      sNewParent = ""
    Endif

    If UCase(sNewParent) <> UCase(sParent) Then

      If sNewParent Then

        hParent = New Menu(mnuGoto)
        hParent.Text = sNewParent

      Else

        hParent = mnuGoto

      Endif

      sParent = sNewParent

    Endif

    hMenu = New Menu(hParent) As "mnuGoto"
    hMenu.Text = sName
    hMenu.Tag = hSymbol.LineNumber - 1
    'IF NOT hSymbol.NotPublic THEN hMenu.Picture = hPoint

  Next

  mnuGoto.Visible = cFunc.count > 0
  mnuSepGoto.Visible = cFunc.count > 0
  mnuStartup.Checked = Project.Startup = File.BaseName(Path)

  UpdateMenu

  Dec Application.Busy

End

Private Sub UpdateMenu()

  Dim bVisible As Boolean

  Action["watch"].Enabled = Project.Running 'AND Len(Trim(edtEditor.Selection.Text)) > 0

  'mnuWatch.Visible =
  'btnWatch.Visible = Project.Running
  'mnuUntil.Visible = mnuWatch.Visible

  bVisible = Not edtEditor.ReadOnly

  mnuUndo.Visible = bVisible
  mnuRedo.Visible = bVisible
  mnuSepUndo.Visible = bVisible
  mnuCut.Visible = bVisible
  mnuPaste.Visible = bVisible
  mnuPasteSpecial.Visible = bVisible
  mnuComment.Visible = bVisible
  mnuUncomment.Visible = bVisible
  'mnuSepComment.Visible = bVisible
  mnuReload.Visible = bVisible
  mnuInsertColor.Visible = bVisible
  mnuWatch.Visible = Not bVisible

  btnUndo.Visible = bVisible
  btnRedo.Visible = bVisible
  btnCut.Visible = bVisible
  btnPaste.Visible = bVisible
  btnPasteSpecial.Visible = bVisible
  btnInsertColor.Visible = bVisible
  btnComment.Visible = bVisible
  btnUncomment.Visible = bVisible
  btnIndent.Visible = bVisible
  btnUnIndent.Visible = bVisible
  btnReload.Visible = bVisible
  btnSave.Visible = bVisible
  btnWatch.Visible = Not bVisible

End

Public Sub mnuGoto_Click()

  GotoFunction(CInt(Last.Tag))

End

Private Function InsertFunction(sProc As String, sType As String, bPublic As Boolean, sSign As String, Optional bStatic As Boolean) As Integer

  Dim iLine As Integer
  Dim iCol As Integer
  Dim sPublic As String
  Dim sStatic As String

  ' For iLine = 0 To Editor.Lines.Count - 1
  '   If IsProc(Editor.Lines[iLine].Text) Then
  '     If Comp($sName, sProc, gb.Text) = 0 Then
  '       Return iLine
  '     Endif
  '   Endif
  ' Next

  FillProcCombo
  Try iLine = $cProc[sProc]
  If Not Error Then Return iLine

  If Me.ReadOnly Then Return -1

  Editor.Begin

  iLine = Editor.Lines.Count - 1
  iCol = Editor.Lines[iLine].Length
  If iCol Then
    Editor.Insert("\n", iLine, iCol)
    Inc iLine
  Endif

  sPublic = If(bPublic, "Public", "Private")
  sStatic = If(bStatic, "Static ", "")
  
  Editor.Goto(iLine, 0)

  If sType Then
    Editor.Insert("\n" & sStatic & sPublic & " Function " & sProc & "(" & sSign & ") As " & sType & "\n\n" & Space$(Project.TabSize) & "\n\nEnd\n")
  Else
    Editor.Insert("\n" & sStatic & sPublic & " Sub " & sProc & "(" & sSign & ")\n\n" & Space$(Project.TabSize) & "\n\nEnd\n")
  Endif

  Editor.End

  Return iLine + 1

End

Public Sub GotoEvent(sName As String, sEvent As String, Optional sSign As String) As Boolean

  Dim sProc As String
  Dim iLine As Integer

  sProc = sName & "_" & sEvent
  iLine = InsertFunction(sProc, "", True, sSign)
  If iLine < 0 Then Return True
  GotoFunction(iLine) ' + 1, Len(edtEditor.Lines[iLine]))

End

Public Sub mnuSave_Click()

  Save

End

Public Sub mnuClose_Click()
  
  Me.Close
  
End


Private Sub InsertProperty()

  Dim iPos As Integer
  Dim bStatic As Boolean
  Dim bRead As Boolean
  Dim sName As String
  Dim sName2 As String
  Dim sType As String
  Dim iLine As Integer
  Dim iCol As Integer

  If Highlight.Symbols[0] = "STATIC" Then
    bStatic = True
    iPos = 2
  Else
    iPos = 1
  Endif

  If Highlight.Symbols[iPos] = "READ" Then
    bRead = True
    Inc iPos
  Endif

ANOTHER_SYMBOL: 

  sName = Highlight.Symbols[iPos]
  If sName = "{" Then
    Inc iPos
    If Highlight.Types[iPos] <> Highlight.Symbol Then Return
    sName = Highlight.Symbols[iPos]
    Inc iPos
    If Highlight.Symbols[iPos] <> "}" Then Return
  Else
    If Highlight.Types[iPos] <> Highlight.Symbol Then Return
  Endif
  If Not sName2 Then sName2 = sName

  Inc iPos
  
  If Highlight.Symbols[iPos] = "," Then
    Inc iPos
    Goto ANOTHER_SYMBOL
  Endif
  
  sName = sName2
  
  If Highlight.Symbols[iPos] <> "AS" Then Return
  Inc iPos
  sType = Highlight.Symbols[iPos]
  If Highlight.Types[iPos] <> Highlight.DataType Then Return
  Inc iPos
  If Highlight.Symbols.Max >= iPos Then
    If Highlight.Symbols[iPos] = "[" Then
      sType &= "[]"
    Endif
  Endif

  iLine = Editor.Line
  iCol = Editor.Column

  InsertFunction(sName & "_Read", sType, False, "", bStatic)
  If Not bRead Then
    InsertFunction(sName & "_Write", "", False, "Value AS " & sType, bStatic)
  Endif

  Editor.Goto(iLine, iCol)

Catch

End

Private Sub CheckCodeSnippet() As Boolean

  Dim sLine As String
  Dim iPos As Integer
  Dim iLine, iCol As Integer

  If Settings["/Editor/CodeSnippet", 1] = 0 Then Return

  If Not $hSampleCode Then

    If Editor.Column < Editor.Lines[Editor.Line].Length Then Return

    sLine = String.Left(Editor.Lines[Editor.Line].Text, Editor.Column)
    For iPos = 1 To Len(sLine)
      If Not IsSpace(Mid$(sLine, iPos, 1)) Then Break
    Next
    If iPos > Len(sLine) Then Return

    sLine = String.Mid$(sLine, iPos)

    CSampleCode.Init
    $hSampleCode = CSampleCode.All[sLine]
    If Not $hSampleCode Then Return

    $iSampleStart = Editor.Line
    $iSampleEnd = $iSampleStart + $hSampleCode.GetLineCount()

    Editor.Begin
    Editor.Remove(Editor.Line, Editor.Column - String.Len(sLine), Editor.Line, Editor.Column)
    iLine = Editor.Line
    iCol = Editor.Column
    $iSamplePos = iCol
    $hSampleCode.Insert(Editor)
    'Editor.Insert($hSampleCode.Make(iIndent), Editor.Line, Editor.Column)
    Editor.Goto(iLine, iCol)
    Editor.End

  Endif

  If $hSampleCode.GotoNextPos(Editor, $iSampleStart, $iSampleEnd, $iSamplePos) Then
    $hSampleCode = Null
    Return CheckCodeSnippet()
  Endif

  Return True

End

Private Sub SymbolBegins(aSym As String[], sWith As String) As Boolean

  Dim aWith As String[] = Split(UCase(Trim(sWith)), " ")
  Dim iInd As Integer

  For iInd = 0 To aWith.Max
    If aSym[iInd] <> aWith[iInd] Then Return False
  Next

  Return True

Catch

End

Private Sub DoStructControlCompletion(iLine As Integer, sLine As String, aSymbol As String[]) As Boolean

  Dim bIndent, bUnindent As Boolean
  Dim sClose, sClose2 As String
  Dim iPos, iInd As Integer
  Dim iIndent As Integer
  Dim sIndent As String

  If aSymbol.Count >= 1 Then
    If aSymbol[0] = "IF" And If aSymbol[aSymbol.Max] = "THEN" Then
      bIndent = True
      bUnindent = False
      sClose = "Endif"
      sClose2 = "Else"
    Else If SymbolBegins(aSymbol, "Public Struct") Or If aSymbol[0] = "STRUCT" Then
      bIndent = True
      bUnindent = False
      sClose = "End Struct"
    Else
      sClose = $cStructClose[aSymbol[0]]
      If sClose Then
        bIndent = True
        If sClose = "<" Then sClose = ""
        'bUnindent = sClose = "<"
      Endif
    Endif
  Endif

  If bIndent Then

    iIndent = Editor.GetIndent(sLine)

    If sClose Then
      For iInd = Editor.Line + 1 To Editor.Lines.Count - 1
        sLine = Editor.Lines[iInd].Text
        If Not Trim(sLine) Then Continue
        If Right(RTrim(sLine)) = ":" Then Continue ' Ignore labels
        iPos = Editor.GetIndent(sLine)
        If iPos < iIndent Then Break
        If iPos > iIndent Then Continue
        Highlight.Analyze(sLine)
        If SymbolBegins(Highlight.Symbols, sClose) Then
          sClose = ""
        Else If sClose2 And If SymbolBegins(Highlight.Symbols, sClose2) Then
          sClose = ""
        Endif
        Break
      Next
    Endif

    Editor.Begin
    If bUnindent And If Not Key.Shift Then
      If IsSpace(Left(sLine, Project.TabSize)) Then
        sLine = Mid$(sLine, Project.TabSize + 1)
        Editor.Lines[Editor.Line].Text = sLine
        iIndent -= Project.TabSize
      Endif
    Endif
    sIndent = Space$(iIndent)
    Editor.Insert("\n" & Space$(Project.TabSize) & sIndent)
    If StructControlCompletion Then
      If Not bUnindent And If sClose And If Not Key.Shift Then Editor.Insert("\n" & sIndent & sClose)
    Endif
    Editor.End
    Editor.Goto(iLine + 1, Project.TabSize + Len(sIndent))
    Stop Event
    Return True
  Endif

End

Public Sub Editors_KeyPress()

  Dim sLine As String
  Dim iLine As Integer
  Dim iInd As Integer
  Dim iPos As Integer
  Dim bStop As Boolean
  Dim aSymbol As String[]
  Dim aScan As String[]
  Dim hClass As Class
  Dim aClass As String[]
  Dim sClass As String
  Dim iOldCount As Integer

  If Not Editor.ReadOnly Then

    iLine = Editor.Line

    If FCompletion.VisibleFrom(Editor) Then
      bStop = FCompletion.ManageKey()
    Endif

    If FSignature.VisibleFrom(Editor) Then
      bStop = bStop Or FSignature.ManageKey()
      'IF Key.Text THEN CheckSignature(Key.Text)
    Endif

    If bStop Then
      Stop Event
      Return
    Endif

  Endif

  If Key.Code = Key.F6 Then

    ToggleProcList
    Stop Event
    
  Else If Key.Code = Key.F2 Then
    
    If Key.Shift Then 
      CPosition.MovePrevious
      Stop Event
    Endif

  Else If Key.Code = Key.Pause Then

    '     IF Key.Alt THEN
    '       Design.Stop
    '       STOP EVENT
    '     ENDIF

  Else If Key.Code = Key.Insert Then

    If Key.Shift Then
      If Not Editor.ReadOnly Then
        Editor.Paste
        Stop Event
      Endif
    Else If Key.Control Then
      Editor.Copy
      Stop Event
    Endif

  Else If Key.Code = Key.Delete Then

    If Key.Shift Then
      If Not Editor.ReadOnly Then
        Editor.Cut
        Stop Event
      Endif
    Endif

  Else If Key.Control Then

    If Key.Code = Key["A"] Then

      mnuSelectAll_Click
      Stop Event

      ' Else If Key.Code = Key.Up Then
      '
      '   GotoPreviousProc
      '   Stop Event
      '
      ' Else If Key.Code = Key.Down Then
      '
      '   GotoNextProc
      '   Stop Event

    Else If Key.Code = Key.Return Then

      If Key.Shift Then
        If Editor.Lines[Editor.Line].Expanded Then
          Editor.CollapseAll
        Else
          Editor.ExpandAll
        Endif
      Else
        Editor.Lines[Editor.Line].Expanded = Not Editor.Lines[Editor.Line].Expanded
      Endif
      Stop Event
      
    ' Else If Key.Code = Key["L"] Then
    '   
    '   FMain.SearchProject
    '   
    Else If Key.Code = Key.F12 Then
      
      For Each sLine In Split(File.Load("/proc/self/maps"), "\n")
        If InStr(sLine, "[heap]") Then
          aScan = Scan(sLine, "*-* *")
          Print "Heap size is " & Format(Val("&H" & aScan[1] & "&") - Val("&H" & aScan[0] & "&"), "#,##0") & " bytes."
          Break
        Endif
      Next
      
      aClass = New String[]
      
      For Each hClass In Classes
        aClass.Add(hClass.Name)
      Next
      
      aClass.Sort
      
      For Each sClass In aClass
        With Classes[sClass]
          iOldCount = 0
          Try iOldCount = $cLastClassCount[sClass]
          If .Count = iOldCount Then Continue
          Print sClass; ": "; .Count;; "("; Format(.Count - iOldCount, "+0"); ")"
          $cLastClassCount[sClass] = .Count
        End With
      Next
      
    Endif

    Return
    
  Endif

  If Editor.ReadOnly Then Return

  If Asc(Key.Text) = 13 Then

    sLine = Editor.Lines[iLine].Text

    If IsComment(sLine) And If Not Key.Shift Then

      iInd = Editor.GetIndent(sLine)
      If Editor.Column > iInd Then
        iPos = iInd + 1
        While Mid$(sLine, iPos, 1) = "'"
          Inc iPos
        Wend
        While Mid$(sLine, iPos, 1) = " "
          Inc iPos
        Wend
        Editor.Begin
        Editor.Insert("\n" & Space$(iInd))
        Editor.End
        Editor.Begin
        Editor.Insert(Mid$(Left$(sLine, iPos - 1), iInd + 1))
        Editor.End
        Stop Event
      Endif

      Return

    Endif

    If Editor.Column < String.Len(sLine) Then Return

    If IsProc(sLine) And If Not Key.Shift Then

      For iInd = iLine + 1 To Editor.Lines.Count - 1
        sLine = Editor.Lines[iInd].Text
        If IsEndProc(sLine) Then Return
        If IsProc(sLine) Then Break
      Next

      sLine = Trim(Editor.Lines[iLine].Text)

      Editor.Begin
      If InStr(sLine, "(") = 0 Then Editor.Insert("()")
      Editor.Insert(Replace("\n\t\n\t\n\t\nEnd\n", "\t", Space$(Project.TabSize)))
      'edtEditor.Line = iLine + 2
      'edtEditor.Column = 2
      Editor.Goto(iLine + 2, 2)
      Editor.End

      Stop Event
      Return

    Endif

    aSymbol = Highlight.Symbols

    If aSymbol.Count >= 4 Then
      If aSymbol[0] = "PROPERTY" Or If aSymbol[0] = "STATIC" And aSymbol[1] = "PROPERTY" Then
        Editor.Insert("\n")
        InsertProperty
        Stop Event
        Return
      Endif
    Endif

    If Not Key.Shift And If LocalVariableDeclaration Then
      If CreateLocalVariable() Then iLine = Editor.Line
    Endif

    If DoStructControlCompletion(iLine, sLine, aSymbol) Then Return
    
  Else If Key.Code = Key.Space Then

    CheckCompletion(" ")
    $bCheckSignature = True

  Else If Key.Code = Key.Backspace Then

    CheckCompletion("<")
    $bCheckSignature = True

  Else If Key.Text = "." Then

    CheckCompletion(".")

    ' Else If Key.Text = "_" Then
    '
    '   CheckCompletion("_")
    '
  Else If InStr("(),[]", Key.Text) Then

    $bCheckSignature = True

  Else If InStr(IDENT_CAR, Key.Text) Then

    CheckCompletion("A")

  Else If Key.Code = Key.Tab Then

    If Not Editor.Selected Or If Editor.Selection.StartLine = Editor.Selection.EndLine Then
      If CheckCodeSnippet() Then Stop Event
    Endif

  Endif

End

Static Public Function IsCurrentProc() As Boolean

  Dim aLine As String[]
  Dim bProc As Boolean
  Dim iPos As Integer

  aLine = Highlight.Symbols

  $bPublic = False
  $bStatic = False
  $sName = ""

  For iPos = 0 To aLine.Count - 1

    If aLine[iPos] = "FAST" Then
      Continue
    Endif

    If aLine[iPos] = "PUBLIC" Then
      $bPublic = True
      Continue
    Endif

    If aLine[iPos] = "PRIVATE" Then
      $bPublic = False
      Continue
    Endif

    If aLine[iPos] = "STATIC" Then
      $bStatic = True
      Continue
    Endif

    If aLine[iPos] = "SUB" Then
      bProc = True
      Break
    Endif

    If aLine[iPos] = "PROCEDURE" Then
      bProc = True
      Break
    Endif

    If aLine[iPos] = "FUNCTION" Then
      bProc = True
      Break
    Endif

    Break

  Next

  If Not bProc Then Return

  Inc iPos
  If iPos >= aLine.Count Then Return

  $sName = aLine[iPos]
  If $sName = "{" Then
    Inc iPos
    If iPos >= aLine.Count Then Return
    $sName = aLine[iPos + 1]
  Endif

  Return True

End

Static Public Function IsProc(sLine As String) As Boolean

  Highlight.Analyze(sLine)
  Return IsCurrentProc()

End

Static Public Sub IsComment(sLine As String) As Boolean

  Return Left(LTrim(sLine)) = "'"

End

Static Public Sub IsCurrentEndProc() As Boolean

  Dim aLine As String[]

  aLine = Highlight.Symbols

  If aLine.Count = 1 Then Return aLine[0] = "END"
  If aLine.Count = 2 Then Return aLine[0] = "END" And (aLine[1] = "PROCEDURE" Or aLine[1] = "FUNCTION" Or aLine[1] = "SUB")

End

Static Public Function IsEndProc(sLine As String) As Boolean

  Highlight.Analyze(sLine)
  Return IsCurrentEndProc()

End

Public Function CanSetBreakpoint(iLine As Integer) As Boolean

  Dim sLine As String
  Dim iPos As Integer

  If iLine < 0 Or If iLine >= Editor.Lines.Count Then Return

  'Editor.Lines[iLine].Refresh
  sLine = Trim(Editor.Lines[iLine].Text)
  iPos = InStr(sLine, "'")
  If iPos Then sLine = Trim(Left$(sLine, iPos - 1))
  If Len(Trim(sLine)) = 0 Then Return False

  If $cProc.Count Then
    If iLine < $iFirstProcLine Then Return False
    If iLine = $cProc[btnProc.Text] Then Return False
  Else
    If GetCurrentProcLine(iLine) < 0 Then Return False
    If IsProc(Editor.Lines[iLine].Text) Then Return False
  Endif

  Return True

End

Public Sub SetBreakpoint(iLine As Integer, bVal As Boolean) As Boolean

  If bVal And If Not CanSetBreakpoint(iLine) Then Return True

  ' Update debug window
  FDebugInfo.AddBreakpoint(Me.Name, GetProcAt(iLine), iLine, bVal)

  'Editor.Lines.SetFlag(iLine, Editor.Breakpoint, bVal)
  Editor.Lines[iLine].Breakpoint = bVal
  If iLine = Editor.Line Then RefreshLineInfo(True)

End

Private Sub HasBreakpoint(iLine As Integer) As Boolean

  Return Editor.Lines[iLine].Breakpoint

End

Public Sub CheckBreakpoints()

  Dim iLine As Integer

  For Each iLine In Editor.Breakpoints
    If Not CanSetBreakpoint(iLine) Then SetBreakpoint(iLine, False)
  Next

End

Public Function GetBreakpoints(Optional bCheck As Boolean) As Integer[]

  If bCheck Then CheckBreakpoints
  Return Editor.Breakpoints
  
End

Private Sub GetIndentWidth(iStart As Integer, iEnd As Integer) As Integer

  Dim iLine As Integer
  Dim sLine As String
  Dim iInd As Integer
  Dim iIndent As Integer = 0

  For iLine = iStart To iEnd - 1
    sLine = Editor.Lines[iLine].Text
    If LTrim(sLine) Then
      iInd = Len(sLine) - Len(LTrim(sLine))
      If iIndent = 0 Then
        iIndent = iInd
      Else
        iIndent = Min(iIndent, iInd)
      Endif
      If iIndent = 0 Then Break
    Endif
  Next

  Return iIndent

End

Public Sub mnuComment_Click()

  Dim iStartLine As Integer
  Dim iEndLine As Integer
  Dim iLine As Integer
  Dim iIndent As Integer

  If Editor.ReadOnly Then Return
  'IF NOT Editor.Selected THEN RETURN

  If Editor.Selected Then
    Editor.StoreSelection

    iStartLine = Editor.Selection.StartLine
    iEndLine = Editor.Selection.EndLine

    iIndent = GetIndentWidth(iStartLine, iEndLine)

    Editor.Begin
    For iLine = iStartLine To iEndLine - 1
      Editor.Lines[iLine].Text = Space$(iIndent) & "' " & Mid$(Editor.Lines[iLine].Text, iIndent + 1)
    Next
    Editor.End
    'Modify

    Editor.RecallSelection
  Else
    'Comment only the current line
    iLine = Editor.Line
    Editor.Lines[iLine].Text = Space$(iIndent) & "' " & Mid$(Editor.Lines[iLine].Text, iIndent + 1)
  Endif

End

Public Sub mnuUncomment_Click()

  Dim iLine As Integer
  Dim sLine As String
  Dim iIndent As Integer
  Dim iStartLine As Integer
  Dim iEndLine As Integer

  If Editor.ReadOnly Then Return
  'IF NOT Editor.Selected THEN RETURN

  If Editor.Selected Then
    Editor.StoreSelection

    iStartLine = Editor.Selection.StartLine
    iEndLine = Editor.Selection.EndLine

    iIndent = GetIndentWidth(iStartLine, iEndLine)

    For iLine = iStartLine To iEndLine - 1
      sLine = Editor.Lines[iLine].Text
      If Len(sLine) < (iIndent + 1) Then Break
      If Left(LTrim(sLine), 1) <> "'" Then Break
    Next

    If iLine = iEndLine Then
      Editor.Begin
      For iLine = iStartLine To iEndLine - 1
        If Left(LTrim(Editor.Lines[iLine].Text), 2) = "' " Then
          Editor.Lines[iLine].Text = Space$(iIndent) & Mid$(LTrim(Editor.Lines[iLine].Text), 3)
        Else
          Editor.Lines[iLine].Text = Space$(iIndent) & Mid$(LTrim(Editor.Lines[iLine].Text), 2)
        Endif
      Next
      Editor.End
      'Modify
    Endif

    Editor.RecallSelection
  Else
    iLine = Editor.Line
    sLine = Editor.Lines[iLine].Text
    If Len(sLine) < (iIndent + 1) Then Return
    If Left(LTrim(sLine), 1) <> "'" Then Return
    If Left(LTrim(Editor.Lines[iLine].Text), 2) = "' " Then
      Editor.Lines[iLine].Text = Space$(iIndent) & Mid$(LTrim(Editor.Lines[iLine].Text), 3)
    Else
      Editor.Lines[iLine].Text = Space$(iIndent) & Mid$(LTrim(Editor.Lines[iLine].Text), 2)
    Endif
  Endif

End

Public Sub mnuCut_Click()

  Editor.Cut

End

Public Sub mnuCopy_Click()

  Editor.Copy

End

Public Sub mnuPaste_Click()

  Editor.Paste

End

Public Sub mnuPasteSpecial_Click()

  FPasteSpecial.Run(Editor)

End

Public Sub mnuUndo_Click()

  HideCompletion
  HideSignature
  Editor.Undo

End

Public Sub mnuRedo_Click()

  HideCompletion
  HideSignature
  Editor.Redo

End

Public Sub mnuForm_Click()

  Project.OpenForm(Me.Name, $sModule)

End

Public Sub mnuGotoLine_Click()

  Dim iLine As Integer

  iLine = FGotoLine.Run(Editor.Line + 1)
  If iLine <= 0 Then Return
  GotoCenter(iLine - 1, 0)

End

Public Sub Form_Hide()

  HideCompletion
  'Project.Deactivate(ME)

End

Public Sub mnuSelectAll_Click()

  Editor.SelectAll

End

' Private Sub GotoPreviousProc()
' 
'   Dim iInd As Integer
' 
'   For iInd = Editor.Line - 2 To 0 Step -1
'     If IsProc(Editor.Lines[iInd].Text) Then
'       Me.Goto(iInd, Editor.Column, True)
'       Return
'     Endif
'   Next
' 
'   Me.Goto(0, Editor.Column)
' 
' End
' 
' Private Sub GotoNextProc()
' 
'   Dim iInd As Integer
' 
'   For iInd = Editor.Line + 1 To Editor.Lines.Count - 1
' 
'     If IsProc(Editor.Lines[iInd].Text) Then
'       Me.Goto(iInd, Editor.Column, True)
'       Return
'     Endif
' 
'   Next
' 
'   Me.Goto(Editor.Lines.Count - 1, Editor.Column)
' 
' End

' PUBLIC SUB btnGoto_Click()
'
'   CreateMenu
'   mnuGoto.Popup(btnGoto.ScreenX, btnGoto.ScreenY + btnGoto.H)
'
' END

'' +Description
'' Read the type of a symbol declared globally, or as a method argument, from an analyzed line of code.
'' +Arguments
'' - #aSym# is an array of symbols (like [Highlight.Symbols]).
'' - #iIndex# is the index of the first symbol to take into account into #aSym#.
'' - #sSymbol# is the name of the local symbol. If specified, it must be the first symbol to read.
'' +Return value
'' This function returns the datatype of the symbol.

Static Public Function ReadSymbolType(aSym As String[], iIndex As Integer, Optional sSymbol As String) As String

  Dim sType As String
  Dim bArray As Boolean

  If sSymbol Then
    If UCase(aSym[iIndex]) <> UCase(sSymbol) Then Return
    Inc iIndex
  Endif

  If aSym[iIndex] = "[" Then
    While iIndex < aSym.Count
      If aSym[iIndex] = "]" Then Break
      Inc iIndex
    Wend
    If aSym[iIndex] <> "]" Then Return
    Inc iIndex
    bArray = True
  Endif

  If aSym[iIndex] <> "AS" Then Return
  Inc iIndex
  If aSym[iIndex] = "NEW" Then Inc iIndex
  If aSym[iIndex] = "STRUCT" Then Inc iIndex

  sType = aSym[iIndex]
  sType = UCase(Left(sType)) & Mid$(sType, 2)

  If (iIndex + 2) < aSym.Count Then
    If aSym[iIndex + 1] = "[" Then bArray = True
  Endif

  If bArray Then Return sType & "[]"

  sType = CSymbolInfo.NameToType(sType)
  Return sType

Catch

End

'' +Description
'' Get information about a local symbol declared with DIM from an analyzed line of code.
'' +Arguments
'' - #aSym# is an array of symbols (like [Highlight.Symbols]).
'' - #iIndex# is the index of the first symbol to take into account into #aSym#.
'' - #sSymbol# is the name of the local symbol to search for.
'' - #hSymbol# is a CSymbolInfo object that will be filled with the type information.
'' +Return value
'' This function returns [TRUE] if the symbol has been found, [FALSE] otherwise.

Static Public Function ReadLocalSymbolType(aSym As String[], iIndex As Integer, sSymbol As String, hSymbol As CSymbolInfo) As Boolean

  Dim sType As String
  Dim sWait As String
  Dim sSym As String

  Do

    If UCase(aSym[iIndex]) = UCase(sSymbol) Then

      hSymbol.Name = aSym[iIndex]

      Inc iIndex

      Do
        If aSym[iIndex] = "AS" Then Break
        Inc iIndex
      Loop

      Inc iIndex
      If aSym[iIndex] = "NEW" Then Inc iIndex

      sType = aSym[iIndex]
      sType = UCase(Left(sType)) & Mid$(sType, 2)

      If (iIndex + 2) < aSym.Count Then
        If aSym[iIndex + 1] = "[" Then 'AND aSym[iIndex + 2] = "]" THEN
          hSymbol.Type = sType & "[]"
          Return True
        Endif
      Endif

      sType = CSymbolInfo.NameToType(sType)
      hSymbol.Type = sType
      Return True
    Endif

    Do
      Inc iIndex
      sSym = aSym[iIndex]
      If sWait Then
        If sSym = sWait Then
          sWait = ""
        Endif
      Else If sSym = "(" Then
        sWait = ")"
      Else If sSym = "[" Then
        sWait = "]"
      Else If aSym[iIndex] = "," Then
        Break
      Endif
    Loop

    Inc iIndex

  Loop

Catch

End

Public Sub GetLastSymbolDesc() As CSymbolInfo

  Return $hSymbol

End

'' +Description
'' Return the datatype of a symbol in the context of the current line.
'' +Arguments
'' -#sSymbol# is the symbol to analyze.
'' -#bPoint# tells if there is point just after the symbol.
'' +Return value
'' The datatype of the symbol is returned, or [NULL] if the symbol is not found.

Public Function GetSymbolType(sSymbol As String, Optional bPoint As Boolean) As String

  Dim iLine As Integer
  Dim iInd As Integer
  Dim aSym As String[]
  Dim sType As String

  'sSymbol = UCase(sSymbol)
  $bLastStatic = False
  $hSymbol = Null

  If sSymbol = "ME" Then
    Return Me.Name
  Endif

  If sSymbol = "SUPER" Then
    CComponent.GetClassSymbols(Me.Name)
    Return ParentClass
  Endif

  If Left(sSymbol) = "{" And If Right(sSymbol) = "}" Then sSymbol = Mid$(sSymbol, 2, -1)

  ' Look for local variables

  iLine = Editor.Line

  Do
    Dec iLine
    If iLine < 0 Then Return
    aSym = Highlight.Analyze(Editor.Lines[iLine].Text)
    If aSym.Count >= 1 Then
      If asym.Count = 1 Then
        If aSym[0] = "END" Then Break
      Endif
      If aSym.Count >= 4 Then
        If aSym[0] = "DIM" Then
          If ReadLocalSymbolType(aSym, 1, sSymbol, $hVirtualSymbol) Then
            With $hVirtualSymbol
              '.Name = aSym[1]
              .Class = Me.Name
              .Kind = "l"
              .LineNumber = iLine + 1
              .NotPublic = True
              '.Type = sType
            End With
            $hSymbol = $hVirtualSymbol
            'Debug $hVirtualSymbol.Name;; "->";; $hVirtualSymbol.Type
            Return $hVirtualSymbol.Type
          Endif
        Endif
      Endif
    Endif
    If IsCurrentProc() Then Break
  Loop

  ' Look for parameters

  For iInd = 0 To aSym.Count - 3

    sType = ReadSymbolType(aSym, iInd, sSymbol)
    If sType Then
      With $hVirtualSymbol
        .Name = aSym[0]
        .Class = Me.Name
        .Kind = "l"
        .LineNumber = iLine + 1
        .NotPublic = True
        .Type = sType
      End With
      $hSymbol = $hVirtualSymbol
      Return sType
    Endif

  Next

  'IF UCase($sName) = UCase(sSymbol) THEN
  '  GOTO RETURN_FUNCTION
  'ENDIF

  'PRINT "GetSymbolType: "; sSymbol

  ' Look for private symbols

  Try $hSymbol = CComponent.GetClassSymbols(Me.Name)[sSymbol]
  If Not Error Then
    If $hSymbol Then
      ' A private symbol that is a method or an event cannot be followed by a point
      ' So it must be a static class.
      If Not bPoint Or If InStr("Mm:", $hSymbol.Kind) = 0 Then
        ' This must be a private symbol, and so we must ignore inheritance
        If $hSymbol.Class = Me.Name And If Not $hSymbol.Component Then
          '$bLastStatic = $hSymbol.IsStatic()
          Return $hSymbol.Type
        Endif
      Endif

      $hSymbol = Null

    Endif
  Endif

  ' Look for subroutines

  If Not bPoint Then
    $hSymbol = CComponent.GetClassSymbols(".")[sSymbol]
    If $hSymbol Then
      Return $hSymbol.Type
    Endif
  Endif

  ' Look for static classes

  $bLastStatic = True

  If CComponent.Classes.Exist(sSymbol) Then
    'TRY $hSymbol = CComponent.GetClassSymbols(sSymbol)["_call"]
    Return sSymbol
  Endif

  ' Look for project classes

  If Project.Exist(sSymbol) Then
    If Project.ExistForm(sSymbol) Then $bLastStatic = False
    Return sSymbol
  Endif

End

Private Sub GetSymbolWith(aExpr As String[], aType As Integer[], Optional iInd As Integer = -1)

  Dim iLine As Integer
  Dim aWith As String[]
  Dim aWithType As Integer[]
  Dim iLevel As Integer
  Dim iAssign As Integer

  iLine = Editor.Line

  Do
    Dec iLine
    If iLine < 0 Then Break
    aWith = Highlight.Analyze(Editor.Lines[iLine].Text)
    If aWith.Count >= 2 Then
      If aWith[0] = "WITH" Then
        If iLevel = 0 Then
          aWithType = Highlight.Types
          aWith.Remove(0)
          aWithType.Remove(0)

          For iAssign = 0 To aWith.Max
            If Right(aWith[iAssign]) = "=" Then
              aWith.Remove(iAssign, -1)
              aWithType.Remove(iAssign, -1)
              Break
            Endif
          Next

          aExpr.Insert(aWith, iInd)
          aType.Insert(aWithType, iInd)
          Return
        Else
          Dec iLevel
        Endif
      Else If aWith[0] = "END" Then
        If aWith[1] = "WITH" Then
          Inc iLevel
        Endif
      Endif
    Endif
    If IsCurrentProc() Then Break
  Loop

End

Private Function IsTypeSymbol(sPattern As String, iType As Integer) As Boolean

  If iType = Highlight.Symbol Then Return True
  If iType = Highlight.DataType Then Return True
  If iType = Highlight.Function Then Return True
  If iType = Highlight.Keyword Then
    If sPattern = "ME" Then Return True
    If sPattern = "SUPER" Then Return True
    If sPattern = "LAST" Then Return True
  Endif

End

Private Sub GetExpressionStart(aExpr As String[], aType As Integer[]) As Integer

  Dim iInd As Integer
  Dim aWait As New String[]
  Dim sPattern As String
  Dim bLastSymbol As Boolean

  For iInd = aExpr.Max DownTo 0

    sPattern = aExpr[iInd]
    If sPattern = ")" Then
      aWait.Push("(")
      bLastSymbol = False
      Continue
    Else If sPattern = "]" Then
      aWait.Push("[")
      bLastSymbol = False
      Continue
    Else If aWait.Count Then
      If sPattern = aWait[aWait.Count - 1] Then
        aWait.Pop
      Endif
      bLastSymbol = False
      Continue
    Else If sPattern = "." Then
      bLastSymbol = False
      Continue
    Else If IsTypeSymbol(sPattern, aType[iInd]) Then
      If Not bLastSymbol Then
        bLastSymbol = True
        Continue
      Endif
    Endif

    Break

  Next

  Inc iInd
  ExpressionStart = iInd
  Return iInd

End

Public Function GetExpressionType(aExpr As String[], aType As Integer[], bPointAfter As Boolean) As String

  Dim iInd As Integer
  Dim aWait As New String[]
  Dim sPattern As String
  Dim sType As String
  Dim cSymbol As Collection

  Dim bNeedMethod As Boolean

  $hSymbol = Null

  iInd = GetExpressionStart(aExpr, aType)

  If iInd >= aExpr.Count Then

    If iInd > 0 Then
      If Not bPointAfter Then Return
      Select Case aType[iInd - 1]
        Case Highlight.Operator, Highlight.Keyword
        Default
          Return
      End Select
    Endif

    GetSymbolWith(aExpr, aType)
    'PRINT "#1 WITH: "; aExpr.Join("/")

  Else If aExpr[iInd] = "." Then
    GetSymbolWith(aExpr, aType, iInd)
    'PRINT "#2 WITH: "; aExpr.Join("/")
  Endif

  For iInd = iInd To aExpr.Count - 1

    sPattern = aExpr[iInd]
    'PRINT sPattern

    If sPattern = "(" Then
      'INC $bInMethod
      aWait.Push(")")
      Continue
    Else If sPattern = "[" Then
      aWait.Push("]")
      Continue
    Else If aWait.Count Then
      If sPattern = aWait[aWait.Count - 1] Then
        aWait.Pop
        If aWait.Count Then Continue
      Else
        Continue
      Endif
    Endif

    'IF aType[iInd] = Editor.Symbol OR aType[iInd] = Editor.DataType OR aType[iInd] = Editor.Keyword THEN
    If IsTypeSymbol(sPattern, aType[iInd]) Then
      If Not sType Then
        If iInd >= (aExpr.Count - 1) Then
          sType = GetSymbolType(sPattern, bPointAfter)
        Else
          sType = GetSymbolType(sPattern, aExpr[iInd + 1] = ".")
        Endif
        If $hSymbol Then
          '$bLastStatic = FALSE
          sType = $hSymbol.Type
          bNeedMethod = LCase($hSymbol.Kind) = "m"
        Endif
      Endif
      If Not sType Then Return
    Else If sPattern = "." Then
      If iInd <= (aExpr.Count - 2) Then
        If sType Then
          If aType[iInd + 1] = Highlight.Symbol Then
            'PRINT sType; " ";
            cSymbol = CComponent.GetClassSymbols(sType)
            $hSymbol = Null
            Try $hSymbol = cSymbol[aExpr[iInd + 1]]
            If Not $hSymbol Then Return
            sType = $hSymbol.Type
            $bLastStatic = False ' A property cannot return static classes
            'PRINT sType
            If Not sType Then Return
            If LCase($hSymbol.Kind) = "m" Then bNeedMethod = True
            Inc iInd
          Else
            Return
          Endif
        Else
          Return
        Endif
      Else
        Return
      Endif
    Else If sPattern = ")" Then
      If bNeedMethod Then
        bNeedMethod = False
      Else
        Try $hSymbol = CComponent.GetClassSymbols(sType)["_call"]
        If Not $hSymbol Then Return
        sType = $hSymbol.Type ' A method cannot return static classes
        $bLastStatic = False
      Endif
    Else If sPattern = "]" Then
      
      If Not sType Then ' Array constructor operator [ ... ]
        Return
      Else
        Try $hSymbol = CComponent.GetClassSymbols(sType)["_get"]
        If Not $hSymbol Then Return
        sType = $hSymbol.Type
        $bLastStatic = False ' A method cannot return static classes
      Endif
      
    Endif

  Next

  If bNeedMethod Then Return
  Return sType

End

Private Sub CheckCompletion(sMode As String)

  'DIM sMode AS String
  Dim sLine As String 
  Dim sType As String
  Dim aSymbols As String[]
  Dim aTypes As Integer[]
  Dim sWord As String
  Dim iPos As Integer

  If Not $bCompletion Then Return
  If Editor.Selected Then Return

  'IF Key.Code = Key.Backspace THEN
  '  IF FCompletion.IsMine(edtEditor) THEN
  '    sMode = Mid$(sLig, edtEditor.Column - 1, 1)
  '  ENDIF
  'ELSE
  '  sMode = Key.Text
  'ENDIF

  'IF NOT sMode THEN RETURN

  sLine = String.Left$(Highlight.Purge(Editor.Lines[Editor.Line].Text), Editor.Column)
  If Right$(RTrim(sLine)) = "'" Then Return

  If sMode = " " Then
    If UCase(Right$(sLine, 3)) = " AS" Or UCase(Right$(sLine, 4)) = " NEW" Or UCase(Right$(sLine, 3)) = " IS" Then
      HideCompletion
      FCompletion.Open(Me, sMode)
    Endif
  Else If sMode = "." Then
    Highlight.Analyze(sLine & ".")
    aSymbols = Highlight.Symbols
    aTypes = Highlight.Types
    aSymbols.Remove(aSymbols.Count - 1)
    aTypes.Remove(aTypes.Count - 1)
    sType = GetExpressionType(aSymbols, aTypes, True)
    If sType Then
      'PRINT "Type: "; sType
      FCompletion.Open(Me, sMode, sType, $bLastStatic, False) 'LCase(sType) = LCase(ME.Name))
    Endif
  Else If sMode = "A" Then
    If Not FCompletion.VisibleFrom(Editor) Then
      sWord = GetIdentifier(sLine & Key.Text, Editor.Column + 1)
      If Len(sWord) >= 3 Then FCompletion.Open(Me, sMode, sWord)
      'IF Len(sWord) >= 3 THEN DEBUG FindCompletion(sWord).Join(" ")
    Endif
  Else If sMode = "_" Then
    If Not FCompletion.VisibleFrom(Editor) Then
      sWord = GetIdentifier(sLine, Editor.Column)
      If Len(sWord) >= 3 Then
        FCompletion.Open(Me, "A", sWord & "_")
      Endif
      'IF Len(sWord) >= 3 THEN DEBUG FindCompletion(sWord).Join(" ")
    Endif
  Else If sMode = "<" Then
    If Not Editor.Selected And If Editor.Column >= 1 And If Not FCompletion.VisibleFrom(Editor) Then
      sLine = Left(sLine, -1)
      sWord = GetIdentifier(sLine, Editor.Column - 1)
      If Right(sLine) <> "." And If Len(sLine) > Len(sWord) And If Mid$(sLine, Len(sLine) - Len(sWord), 1) = "." Then
        iPos = Editor.Column
        Editor.Goto(Editor.Line, Editor.Column - String.Len(sWord) - 2)
        CheckCompletion(".")
        FCompletion.SetText(sWord)
        Editor.Goto(Editor.Line, iPos)
        Return
      Endif
      If Len(sWord) >= 3 Then FCompletion.Open(Me, sMode, sWord)
      'IF Len(sWord) >= 3 THEN DEBUG FindCompletion(sWord).Join(" ")
    Endif
  Else
    HideCompletion
  Endif

End

Private Sub HideCompletion()

  FCompletion.HideFrom(Editor)

End

Private Function GetExpressionSignature(aExpr As String[], aType As Integer[]) As CSymbolInfo

  Dim iInd As Integer
  Dim sWait As New String[]
  Dim sPattern As String
  Dim sType As String
  Dim bNew As Boolean

  $hSymbol = Null
  $iArgSignature = 0

  For iInd = aExpr.Count - 1 To 0 Step -1

    sPattern = aExpr[iInd]
    If sPattern = ")" Then
      sWait.Push("(")
      'bLastSymbol = FALSE
      Continue
    Else If sPattern = "]" Then
      sWait.Push("[")
      'bLastSymbol = FALSE
      Continue
    Else If sWait.Count Then
      If sPattern = sWait[sWait.Count - 1] Then
        sWait.Pop
      Endif
      'bLastSymbol = FALSE
      Continue
    Else If sPattern = "(" Or sPattern = "[" Then
      Break
    Else If sPattern = "," Then
      Inc $iArgSignature
    Endif

  Next

  If iInd < 1 Then Return

  $iPosSignature = Editor.ToPosX(Highlight.Positions[iInd - 1])

  If iInd >= 2 Then bNew = aExpr[iInd - 2] = "NEW"

  aExpr.Remove(iInd, -1)
  aType.Remove(iInd, -1)

  sType = GetExpressionType(aExpr, aType, False)
  'IF NOT $hSymbol THEN
  If sType Then
    If sPattern = "(" Then
      If bNew Then
        Try $hSymbol = CComponent.GetClassSymbols(sType)["_new"]
      Else
        Try $hSymbol = CComponent.GetClassSymbols(sType)["_call"]
      Endif
    Else If sPattern = "[" Then
      $hSymbol = Null
      Try $hSymbol = CComponent.GetClassSymbols(sType)["_get"]
    Endif
  Endif

  '   IF $hSymbol THEN
  '     IF $hSymbol.IsStatic() XOR $bLastStatic THEN
  '       hClass = CComponent.Classes[$hSymbol.Component &/ $hSymbol.Class]
  '       IF hClass THEN
  '         IF NOT hClass.AutoCreatable THEN
  '           $hSymbol = NULL
  '         ENDIF
  '       ELSE
  '         $hSymbol = NULL
  '       ENDIF
  '     ENDIF
  '   ENDIF

  'ENDIF

  Return $hSymbol

End

Private Function GetExpressionSymbol(aExpr As String[], aType As Integer[]) As CSymbolInfo

  Dim sPattern As String
  Dim sType As String
  Dim bNew As Boolean

  $hSymbol = Null
  If aExpr.Count = 0 Then Return

  sPattern = aExpr[aExpr.Count - 1]

  If InStr("[(", sPattern) Then
    aType.Remove(aExpr.Count - 1)
    aExpr.Remove(aExpr.Count - 1)
  Endif

  If aExpr.Count >= 2 Then bNew = aExpr[aExpr.Count - 2] = "NEW"

  sType = GetExpressionType(aExpr, aType, False)
  'IF NOT $hSymbol THEN
  'IF sPattern = "(" THEN
  If bNew Then
    Try $hSymbol = CComponent.GetClassSymbols(sType)["_new"]
    'ELSE
    '  TRY $hSymbol = CComponent.GetClassSymbols(sType)["_call"]
  Endif
  'ELSE IF sPattern = "[" THEN
  'TRY $hSymbol = CComponent.GetClassSymbols(sType)["_get"]
  'ENDIF

  '   IF $hSymbol THEN
  '     IF $hSymbol.IsStatic() XOR $bLastStatic THEN
  '       hClass = CComponent.Classes[$hSymbol.Component &/ $hSymbol.Class]
  '       IF hClass THEN
  '         IF NOT hClass.AutoCreatable THEN
  '           $hSymbol = NULL
  '         ENDIF
  '       ELSE
  '         $hSymbol = NULL
  '       ENDIF
  '     ENDIF
  '   ENDIF

  'ENDIF

  Return $hSymbol

End

Private Sub CheckSignature(Optional sText As String)

  Dim sLig As String
  Dim hSymbol As CSymbolInfo
  Dim sKind As String

  If Not $bCompletion Then Return

  'sLig = Left$(edtEditor.GetPurgedLine(edtEditor.Line), edtEditor.Column) & sText
  sLig = String.Left$(Highlight.Purge(Editor.Lines[Editor.Line].Text), Editor.Column) & sText
  Highlight.Analyze(sLig)

  If Not IsCurrentProc() Then

    hSymbol = GetExpressionSignature(Highlight.Symbols, Highlight.Types)

    If hSymbol Then
      sKind = LCase(hSymbol.Kind)
      If InStr(":mx", sKind) Then
        If sKind = ":" Then
          If sLig Not Like ("*RAISE*" & hSymbol.Name & "*") Then Return
        Endif
        FSignature.Open(Me, $iPosSignature, hSymbol, $iArgSignature)
      Endif
      Return
    Endif

  Endif

  HideSignature

End

Private Sub HideSignature()

  FSignature.HideFrom(Editor)

End

Public Sub Editors_Scroll()

  'PRINT "Scroll"
  HideCompletion
  HideSignature
  HideMessage

End

Private Sub SetReadOnly()

  edtEditor.ReadOnly = False
  If Project.ReadOnly Or If Project.Running Or If Project.IsReadOnly(Path) Then
    edtEditor.ReadOnly = True
  Endif

  If $hEditor1 Then $hEditor1.ReadOnly = edtEditor.ReadOnly
  If $hEditor2 Then $hEditor2.ReadOnly = edtEditor.ReadOnly

  UpdateMenu

End

Public Sub Reload()

  Dim sText As String

  sText = File.Load(Path)
  If Right(sText) <> "\n" Then sText &= "\n"
  edtEditor.Text = sText
  $hBookmark.Load()
  If Not Project.RestoringFiles Then
    If Settings["/Editor/Fold"] Then edtEditor.CollapseAll
  Endif

  If Settings["/FormatCode/FormatOnLoad"] Then MPrettyCode.Run(edtEditor)

  Editor.SetFocus
  Modify(True)

End

Public Sub LoadFile() As Boolean

  Reload

  DrawTitle
  UpdateMenu

End

Public Sub mnuReload_Click()

  If IsModified() Then
    If Message.Warning(("The file has been modified.\n\nAll your changes will be lost."), ("Reload"), ("Cancel")) <> 1 Then Return
  Endif

  Reload

End

Private Function GetCurrentProcLine(iLine As Integer) As Integer

  $sName = ""

  ' If $cProc.Count Then
  '
  '   iRes = -1
  '   For Each iProc In $cProc
  '     If iRes < iProc And If iProc <= iLine Then
  '       iRes = iProc
  '       $sName = $cProc.Key
  '     Endif
  '   Next
  '   Return iRes
  '
  ' Else

  Do
    If Editor.Lines[iLine].Limit Then
      If IsProc(Editor.Lines[iLine].Text) Then Return iLine
    Endif
    Dec iLine
    If iLine < 0 Then Return -1
  Loop

  'Endif

End

Public Sub GetProcAt(iLine As Integer) As String

  GetCurrentProcLine(iLine)
  Return $sName

End

Public Sub btnIndent_Click()

  Editor.Indent

End

Public Sub btnUnindent_Click()

  Editor.Unindent

End

Private Function IsKeyword(iCpt As Integer) As Boolean

  If Highlight.Types[iCpt] = Highlight.Keyword Then Return True
  If Highlight.Types[iCpt] = Highlight.Function Then Return True
  If Highlight.Types[iCpt] = Highlight.Operator And If IsLetter(Left$(Highlight.Symbols[iCpt])) Then Return True

End

Private Sub FindDefinition() As Boolean

  Dim sLig As String
  Dim iCol As Integer
  Dim hSymbol As CSymbolInfo
  Dim hClass As CClassInfo
  Dim iCpt As Integer
  Dim sKeyword As String
  Dim iLine As Integer

  iLine = Editor.Line
  iCol = Editor.Column
  If Editor.Selected Then
    If Editor.Selection.EndLine > Editor.Selection.StartLine Then Return
    iCol = Editor.Selection.EndColumn
  Else
    iCol = Editor.Column
  Endif

  sLig = Highlight.Purge(Editor.Lines[iLine].Text)

  Repeat
    Inc iCol
    If iCol > Len(sLig) Then Break
  Until InStr(IDENT_CAR, Mid$(sLig, iCol, 1)) = 0

  If iCol < Len(sLig) Then
    If InStr("[(", Mid$(sLig, iCol, 1)) Then
      Inc iCol
    Endif
  Endif

  sLig = Left$(sLig, iCol - 1)
  If Right(sLig) = "[" Then sLig &= "]"
  'Editor.ShowWord(iLine, iCol, 3)
  Highlight.Analyze(sLig)

  'IF IsCurrentProc() THEN RETURN

  iCpt = Highlight.Types.Max
  sKeyword = ""

  If iCpt >= 0 Then
    sKeyword = Highlight.Symbols[iCpt]

    If IsKeyword(iCpt) Then

      ' If iCpt > 0 Then
      '   Dec iCpt
      '   If IsKeyword(iCpt) Then
      '     sKeyword2 = Highlight.Symbols[iCpt] & sKeyword
      '   Endif
      ' Endif
      '
      ' If sKeyword2 Then
      '   MHelp.ShowWebViewWith(Null, MHelp.TYPE_KEYWORD, sKeyword2)
      '   If FHelpBrowser.Error Then
      '     MHelp.ShowWebViewWith(Null, MHelp.TYPE_KEYWORD, sKeyword)
      '   Endif
      ' Else
      MHelp.ShowHelpBrowserWith(Null, MHelp.TYPE_KEYWORD, sKeyword)
      'Endif
      Return

    Else If Highlight.Types[iCpt] = Highlight.DataType Then

      If System.Datatypes.Exist(sKeyword, gb.IgnoreCase) Then
        MHelp.ShowHelpBrowserWith(Null, MHelp.TYPE_NATIVE, sKeyword)
      Else
        hClass = CComponent.Classes[sKeyword]
        If hClass Then
          'MHelp.GotoClass(hClass.Component, hClass.Name)
          MHelp.ShowHelpBrowserWith(Null, MHelp.TYPE_CLASS, hClass.Name)
        Endif
      Endif
      Return

    Endif
  Endif

  'Editor.Analyze(Left$(sLig, iCol - 1))
  hSymbol = GetExpressionSymbol(Highlight.Symbols, Highlight.Types)
  If Not hSymbol Then
    If sKeyword Then
      If CComponent.Classes.Exist(sKeyword) Then
        MHelp.ShowHelpBrowserWith(Null, MHelp.TYPE_CLASS, sKeyword)
      Endif
    Endif
    Return
  Endif

  'PRINT hSymbol.Class

  If hSymbol.LineNumber Then 'And If Not bPopupHelp Then
    CPosition.SaveCurrent
    Project.OpenFile(hSymbol.Class, hSymbol.LineNumber)
  Else
    MHelp.ShowHelpBrowserWith(Null, MHelp.TYPE_SYMBOL, hSymbol.Name, hSymbol.Class)
  Endif

End

Public Sub OnProjectDebug()

  SetReadOnly
  If Not Project.Running Then Editor.HideMessageLabel

End

Public Sub OnShowString(sStr As String, bIgnoreCase As Boolean)

  edtEditor.ShowString(sStr, bIgnoreCase)
  If $hEditor1 Then $hEditor1.ShowString(sStr, bIgnoreCase)
  If $hEditor2 Then $hEditor2.ShowString(sStr, bIgnoreCase)

End

Static Public Function GetIdentifier(sLine As String, iPos As Integer) As String

  Dim sCar As String
  Dim iPos2 As Integer

  iPos2 = iPos

  Do
    If iPos <= 0 Then Break
    sCar = Mid$(sLine, iPos, 1)
    If sCar = "?" Then Break
    If InStr(IDENT_CAR, sCar) = 0 Then Break
    Dec iPos
  Loop

  Inc iPos

  Do
    If iPos2 > Len(sLine) Then Break
    sCar = Mid$(sLine, iPos, 1)
    If InStr(IDENT_CAR, sCar) = 0 Then Break
    Inc iPos2
  Loop

  Return Mid$(sLine, iPos, iPos2 - iPos)

Catch

End

Public Sub WatchExpression()

  Dim sWatch As String

  If Not Project.Running Then Return
  sWatch = Trim(Editor.Selection.Text)
  If Not sWatch Then Return

  FDebugInfo.AddWatch(Trim(Editor.Selection.Text))

End

Public Sub RunUntil()

  If Not CanSetBreakpoint(Editor.Line) Then Return
  Project.RunUntil(Me, Editor.Line)

End

Public Sub Form_Activate()

  RefreshLineInfo(True)
  Project.SetCurrentPopup(mnuEditor)

End

Private Sub RefreshBackground()

  Dim hEditor As Editor

  For Each hEditor In [$hEditor1, $hEditor2]

    If Not hEditor Then Continue

    If hEditor.HasFocus Then
      ReadConfigEditor(hEditor)
    Else
      hEditor.Styles[Highlight.Background].Color = Color.Background
      hEditor.Flags[Editor.ShowCurrentLine] = False
      hEditor.Flags[Editor.ShowModifiedLines] = False
      hEditor.Flags[Editor.ShowLimits] = False
    Endif

  Next

End

Public Sub Editors_GotFocus()

  Dim hEditor As Editor = Last

  Editor = hEditor
  $hInsertColor.SetEditor(Editor)
  Project.SetCurrentPopup(mnuEditor)

  If hEditor = $hEditor1 Or hEditor = $hEditor2 Then
    RefreshBackground
  Endif

End

' Public Sub Editors_MouseMove()
'
'   If Not Project.Running Then
'     If FDebugInfo.IsHelpVisible() Or $bShowPopupHelp Then
'         timShowHelp.Enabled = True
'     Endif
'     $X = Mouse.X
'     $Y = Mouse.Y
'   Endif
'
' End

Public Sub Editors_MouseDown()
  
  CPosition.Disable
  
End


Public Sub Editors_MouseUp()

  'HideMessage
  
  CPosition.Enable
  CPosition.SaveCurrent

  If Not Editor.Selected Or If Editor.Selection.StartLine < Editor.Selection.EndLine Then
    Return
  Endif

  If Not Project.Running Then
    'FindDefinition(True, Mouse.X, Mouse.Y)
    Return
  Endif

  FDebugInfo.InstantWatch(Trim(Editor.Selection.Text), Me, Editor.ToPosX(Editor.Selection.StartColumn), Editor.CursorY + Editor.LineHeight)

End

' Private Sub ShowMessageLabel(sStr As String, X As Integer, Y As Integer, Optional bError As Boolean)
' 
'   X = Editor.ScreenX + X - lblWatch.Parent.ScreenX
'   Y = Editor.ScreenY + Y - lblWatch.Parent.ScreenY
'   
'   lblWatch.Foreground = Editor.Styles[Highlight.Normal].Foreground
'   If bError Then
'     lblWatch.Background = Editor.Styles[Highlight.Breakpoint].Foreground
'   Else
'     lblWatch.Background = Editor.Styles[Highlight.CurrentLine].Foreground
'   Endif
'   lblWatch.Text = Replace(Replace(sStr, "<p>", " "), "<br>", " ")
' 
'   If (Y + lblWatch.H) > lblWatch.Parent.ClientH Then Y -= lblWatch.H + Editor.LineHeight
'   lblWatch.Move(X, Y)
'   
'   lblWatch.Show
'   lblWatch.Raise
'   timWatch.Start
'   Editor.SetFocus
' 
' End

Public Sub ShowWatchResult(sStr As String, X As Integer, Y As Integer)

  Dim bError As Boolean

  If Left(sStr) = "!" Then
    sStr = Mid$(sStr, 2)
    If sStr = "Syntax error" Or If sStr = "Non terminated string" Or If sStr = "Unknown symbol" Then Return
    If sStr Begins "Unexpected " Then Return
    sStr = Design.MakeMessage(sStr)
    bError = True
  Endif

  Editor.ShowMessageLabel(Html(sStr), X, Y, bError)

End

Public Sub Editors_Margin({Line} As Integer)

  Design.SetBreakpoint(Me.Name, {Line}, Not HasBreakpoint({Line}))

End

Public Sub ShowMessage(sMsg As String, Optional sIcon As String, Optional bNoEscape As Boolean)

  Dim hIcon As Picture
  Dim X, Y As Integer

  If Not bNoEscape Then
    sMsg = Replace(sMsg, "\t", "\n")
    sMsg = Replace(sMsg, "    ", "&nbsp;")
    sMsg = Replace(sMsg, "&", "&amp;")
    sMsg = Replace(sMsg, "<", "&lt;")
    sMsg = Replace(sMsg, ">", "&gt;")
    If Left(sMsg, 2) = "**" Then
      sMsg = Trim(Mid$(sMsg, 3))
      hIcon = Picture["icon:/32/error"]
    Endif
  Endif

  If sIcon Then hIcon = Picture[sIcon]

  X = Editor.CursorX
  Y = Editor.CursorY + Editor.LineHeight \ 2
  If Editor.Selected Then
    If Editor.Selection.StartLine = Editor.Selection.EndLine Then
      X = (Editor.ToPosX(Editor.Selection.StartColumn, Editor.Line) + Editor.ToPosX(Editor.Selection.EndColumn, Editor.Line)) \ 2
    Endif
  Endif

  Balloon(sMsg, Editor, hIcon, X, Y)

End

Public Sub ShowErrorMessage(sMsg As String, (sIcon) As String)

  Editor.SetFocus
  Wait
  Editor.ShowMessageLabel(sMsg, Editor.CursorX, Editor.CursorY + Editor.LineHeight, True)

End

Private Sub HideMessage()

  If Balloon.Control = Editor Then
    Balloon.Hide
  Endif
  'timWatch_Timer

End

Public Sub timProc_Timer()

  CheckBreakpoints
  timProc.Enabled = False

End

Private Sub SetComboProcText(sProc As String)

  btnProc.Text = sProc

End

Private Sub UpdateFunction()

  Dim iLine As Integer = GetCurrentProcLine(Editor.Line)
  Dim sProc As String = $sName

  If Not sProc Then
    sProc = ("(Declarations)")
    iLine = 0
  Endif

  'If Not $cProc.Exist(sProc) Then
  '  $cProc[sProc] = iLine
  '  $aProc.Add(sProc)
  '  $aProc.Sort(gb.IgnoreCase)
  'Endif
  SetComboProcText(sProc)

  ' iIndex = cmbProc.Find(sProc)
  ' If iIndex < 0 Then
  '   cmbProc.Add(sProc)
  '   iIndex = cmbProc.Find(sProc)
  ' Endif
  ' Object.Lock(cmbProc)
  ' cmbProc.Index = iIndex
  ' Object.Unlock(cmbProc)

End

Private Sub FillProcCombo()

  Dim hSymbol As CSymbolInfo
  Dim cSymbol As Collection
  Dim sText As String
  Dim sName As String

  'DIM fTime AS Float
  'DIM iInd AS Integer

  If $cProc.Count Then Return

  Inc Application.Busy

  'fTime = Timer
  'FOR iInd = 1 TO 20
  'aFunc.Clear

  sText = btnProc.Text

  'cmbProc.Clear

  $cProc = New Collection(gb.IgnoreCase)
  $aProc = New String[]
  $iFirstProcLine = 1000000

  {Scan} = Null
  cSymbol = CComponent.GetClassSymbols(Me.Name)

  For Each hSymbol In cSymbol

    If LCase(hSymbol.Kind) <> "m" Then Continue
    If hSymbol.LineNumber = 0 Then Continue
    If hSymbol.Class <> Me.Name Then Continue
    $aProc.Add(hSymbol.Name)

  Next

  $aProc.Sort(gb.IgnoreCase)

  For Each sName In $aProc

    hSymbol = cSymbol[sName]
    'cmbProc.Add(sName)
    $cProc[hSymbol.Name] = hSymbol.LineNumber - 1
    $iFirstProcLine = Min($iFirstProcLine, hSymbol.LineNumber - 1)

  Next

  $aProc.Add(("(Declarations)"), 0)
  $cProc[$aProc[0]] = 0

  SetComboProcText(sText)

  'NEXT
  'DEBUG Timer - fTime

  Dec Application.Busy

End

' Public Sub cmbProc_KeyPress()
'
'   FillProcCombo
'
' End
'
' Public Sub cmbProc_MouseDown()
'
'   FillProcCombo
'
' End

Public Sub GetFunctionLine(sFunc As String) As Integer
  
  Dim iLine As Integer
  
  FillProcCombo
  
  Try iLine = $cProc[sFunc]
  If Not Error Then Return iLine
  
End


Public Sub GotoFunction(iLine As Integer)

  Dim sLine As String
  Dim iCol As Integer
  Dim iStart As Integer

  If iLine < 0 Then
    Editor.Goto(Editor.Lines.Count, 0)
    Return
  Endif

  iStart = iLine

  Do
    Inc iLine
    If iLine >= Editor.Lines.Count Then
      Dec iLine
      Break
    Endif
    sLine = Trim(Editor.Lines[iLine].Text)
    If sLine Then Break
  Loop

  If UCase(sLine) = "END" Or If UCase(sLine) = "END SUB" Then
    iLine = Min(iStart + 2, iLine - 1)
  Endif

  iCol = String.Len(Editor.Lines[iLine].Text) - String.Len(LTrim(Editor.Lines[iLine].Text))

  Me.GotoCenter(iLine, iCol) ', True)
  Editor.SetFocus

End

' Public Sub cmbProc_Click()
'
'   Dim iLine As Integer
'
'   Try iLine = $cProc[cmbProc.Text]
'   GotoProc(iLine)
'
' End
'
' Public Sub cmbProc_MouseWheel()
'
'   FillProcCombo
'
' End
'
' Public Sub cmbProc_GotFocus()
'
'   Editor.SetFocus
'
' End

Private Function ReadOnly_Read() As Boolean

  Return edtEditor.ReadOnly

End

Public Sub GetState() As String

  Return CStr(Editor.Line) & "." & CStr(Editor.Column)

End

Public Sub SetState(sState As String)

  Dim aState As String[] = Split(sState, ".")

  GotoCenter(CInt(aState[0]), CInt(aState[1]))

End

Private Sub InitEditor(hEditor As Editor)

  With hEditor
    .Border = False
    .View = edtEditor
    .Highlight = edtEditor.Highlight
    .Flags[Editor.Highlight] = True
    .ReadOnly = edtEditor.ReadOnly
    .TabSize = edtEditor.TabSize
    '.Flags[Editor.ShowCursorPosition] = edtEditor.Flags[Editor.ShowCursorPosition]
  End With
  ReadConfigEditor(hEditor)

End

Private Sub SetViewMode(iViewMode As Integer)

  If $iViewMode = iViewMode Then Return
  $iViewMode = iViewMode

  If $iViewMode <> VIEWMODE_NORMAL And If Not $hEditor1 Then
    $hEditor1 = New Editor(Me) As "Editors"
    InitEditor($hEditor1)
    $hEditor2 = New Editor(Me) As "Editors"
    InitEditor($hEditor2)
    FSearch.OnNewForm(Me)
  Endif

  Select Case $iViewMode

    Case VIEWMODE_NORMAL
      edtEditor.Show
      splHorizontal.Hide
      splVertical.Hide
      edtEditor.Goto(Editor.Line, Editor.Column, True)
      Editor = edtEditor

    Case VIEWMODE_HORIZONTAL
      $hEditor1.Reparent(splHorizontal)
      $hEditor2.Reparent(splHorizontal)
      edtEditor.Hide
      splHorizontal.Show
      splVertical.Hide
      $hEditor1.Goto(Editor.Line, Editor.Column, True)
      $hEditor2.Goto(Editor.Line, Editor.Column, True)
      Editor = $hEditor1

    Case VIEWMODE_VERTICAL
      $hEditor1.Reparent(splVertical)
      $hEditor2.Reparent(splVertical)
      edtEditor.Hide
      splHorizontal.Hide
      splVertical.Show
      $hEditor1.Goto(Editor.Line, Editor.Column, True)
      $hEditor2.Goto(Editor.Line, Editor.Column, True)
      Editor = $hEditor1

  End Select

  Editor.SetFocus
  Form_Arrange
  Editors_Cursor

End

Public Sub mnuNoSplit_Click()

  SetViewMode(VIEWMODE_NORMAL)

End

Public Sub mnuHorizontalSplit_Click()

  SetViewMode(VIEWMODE_HORIZONTAL)

End

Public Sub mnuVerticalSplit_Click()

  SetViewMode(VIEWMODE_VERTICAL)

End

Public Sub mnuDefinition_Click()

  FindDefinition

End

Public Sub mnuLastPosition_Click()

  CPosition.MovePrevious

End

Public Sub GetFoldedProc() As Integer[]

  Dim aFold As New Integer[]
  Dim iLine As Integer

  Do
    If Not Editor.Lines[iLine].Expanded Then
      'DEBUG Name;; iLine
      aFold.Add(iLine)
    Endif
    iLine = Editor.FindNextLimit(iLine)
    If iLine < 0 Then Break
  Loop

  Return aFold

End

Public Sub SetFoldedProc(aFold As Integer[])

  Dim iLine As Integer

  'Editor.Lines.ExpandAll
  For Each iLine In aFold
    'DEBUG Name;; iLine
    Editor.Lines[iLine].Expanded = False
  Next

End

Public Sub mnuStartup_Click()

  If mnuStartup.Checked Then Return
  mnuStartup.Checked = True
  Project.DefineStartup(Path)

End

Public Sub mnuPasteAsString_Click()

  FPasteSpecial.Run(Editor, FPasteSpecial.MODE_STRING)

End

Public Sub mnuPasteAsStringSplit_Click()

  FPasteSpecial.Run(Editor, FPasteSpecial.MODE_STRING_SPLIT)

End

Public Sub mnuPasteAsComment_Click()

  FPasteSpecial.Run(Editor, FPasteSpecial.MODE_COMMENT)

End

Public Sub panToolBar_Configure()

  UpdateMenu
  
  If $sModule Then
    Action[".show-form"].Picture = Picture["img/16/" & $sModule & ".png"]
    btnForm.ToolTip = CModule[$sModule].Name
    btnForm.Show
  Else
    btnForm.Hide
  Endif

End

' Private Sub ResizeProcList()
' 
'   panProc.Resize(btnProc.W, Min(panProc.Parent.ClientH - panProc.Y + 1, gvwProc.Rows.Count * gvwProc.Rows.H + 2))
' 
' End

Private Sub ToggleProcList()

  Dim iCurrent As Integer
  Dim iLine As Integer

  FillProcCombo
  iCurrent = $aProc.Find(btnProc.Text)

  iCurrent = FProcedureList.Popup(Me.Name, $aProc, iCurrent, btnProc.ScreenX, btnProc.ScreenY + btnProc.H, btnProc.W, Me.ClientH - panToolbar.H - Desktop.Scale)
  If iCurrent >= 0 Then
    Try iLine = $cProc[$aProc[iCurrent]]
    GotoFunction(iLine)
  Endif

End

Public Sub btnProc_MouseDown()

  If Not Mouse.Left Then Return
  ToggleProcList
  Stop Event

End

' Public Sub gvwProc_LostFocus()
'
'   panProc.Hide
'
' End
'
' Public Sub gvwProc_Data(Row As Integer, Column As Integer)
'
'   Dim cSymbol As Collection
'   Dim hSymbol As CSymbolInfo
'   Dim sName As String
'
'   'Dim hColor As Color
'
'   Try sName = $aProc[Row]
'   If Not sName Then Return
'
'   cSymbol = CComponent.GetClassSymbols(Me.Name)
'   hSymbol = cSymbol[sName]
'
'   gvwProc.Data.Text = sName
'   If hSymbol Then
'     If hSymbol.Kind = "M" Then gvwProc.Data.Font.Bold = True
'     If hSymbol.NotPublic Then
'       'hColor = Color(Color.Foreground)
'       'hColor.Value = 255 - (255 - hColor.Value) * 0.6
'       gvwProc.Data.Foreground = Color.Lighter(Color.Foreground)
'     Endif
'     'gvwProc.Data.Picture = Picture[hSymbol.GetIcon()]
'   Else
'     gvwProc.Data.Foreground = Color.Lighter(Color.Foreground)
'   Endif
'   If Left(sName) = "_" Then
'     'gvwProc.Data.Picture = Picture["img/16/point.png"]
'     'gvwProc.Data.Foreground = Color.Lighter(Color.Foreground)
'   Else If InStr(sName, "_") Then
'     'gvwProc.Data.Picture = Picture["img/16/event.png"]
'     gvwProc.Data.Font.Italic = True
'   Endif
'
'   If sName = btnProc.Text Then
'     gvwProc.Data.Background = Color.LightBackground
'   Endif
'
' End
'
' Public Sub gvwProc_Click()
'
'   Dim iLine As Integer
'
'   Try iLine = $cProc[$aProc[gvwProc.Row]]
'   GotoProc(iLine)
'
' End
'
' Public Sub gvwProc_MouseMove()
'
'   Dim iRow As Integer = gvwProc.RowAt(Mouse.Y)
'
'   Try gvwProc.Rows[iRow].Selected = True
'
' End
'
' Public Sub btnProc_DblClick()
'
'   btnProc_MouseDown
'
' End

'' Update a control name and its event handler in the source code when it is renamed

Public Sub RenameControl(sOld As String, sNew As String)

  Dim iLine As Integer
  Dim sLine As String
  Dim aSym As String[]
  Dim iInd As Integer
  Dim sSym As String
  Dim bChange As Boolean
  Dim bInProc As Boolean

  sOld = UCase(sOld)

  Editor.Begin

  For iLine = 0 To Editor.Lines.Count - 1

    sLine = Editor.Lines[iLine].Text
    aSym = Highlight.Analyze(sLine)
    bChange = False
    
    If Not bInProc Then
      If IsCurrentProc() Then
        bInProc = True
      Else
        Continue
      Endif
    Else
      If IsCurrentEndProc() Then
        bInProc = False
        Continue
      Endif
    Endif
    
    If aSym.Count Then
     If aSym[0] = "Dim" Then Continue
    Endif

    For iInd = aSym.Max DownTo 0

      If Highlight.Types[iInd] <> Highlight.Symbol Then Continue

      sSym = UCase(aSym[iInd])

      If sSym <> sOld Then
        If Not (sSym Begins (sOld & "_")) Then Continue
      Else
        If iInd > 0 Then
          sSym = aSym[iInd - 1]
          If sSym = "." Then
            If iInd <= 1 Or If aSym[iInd - 2] <> "ME" Then Continue
          Else If sSym = "!" Or If sSym = "AS" Or If sSym = "NEW" Then 
            Continue
          Endif
        Endif
      Endif

      sLine = Left$(sLine, Highlight.Positions[iInd]) & sNew & Mid$(sLine, Highlight.Positions[iInd] + Len(sOld) + 1)
      bChange = True

    Next

    If bChange Then Editor.Lines[iLine].Text = sLine
  Next

  Editor.End

End

Public Sub GetText() As String

  Return Editor.Text

End

Public Sub GetPosition() As Integer

  Return Editor.GetPosition()

End

Public Sub SetPosition(hResult As CFindResult, Optional bJustCheck As Boolean) As Boolean

  Dim bResult As Boolean

  If FSearch.CurrentProcedure Then
    bResult = Editor.SetPosition(hResult, True)
    If Not bResult Then
      If FSearch.CurrentProcedureName <> GetProcAt(hResult.Line) Then bResult = True
    Endif
    If Not bResult And If Not bJustCheck Then Editor.SetPosition(hResult, False)
  Else
    bResult = Editor.SetPosition(hResult, bJustCheck)
  Endif
  Return bResult

End

Public Sub Replace(sReplace As String)

  Editor.Replace(sReplace)

End

Public Sub GetSelection() As String

  Return Editor.GetSelection()

End

Public Sub mnuInsertColor_Click()

  $hInsertColor.Insert

End

Public Sub mnuBreakpoint_Click()

  Design.SetBreakpoint(Me.Name, Editor.Line, Not HasBreakpoint(Editor.Line))

End

Public Sub mnuWatch_Click()

  WatchExpression
  FDebugInfo.ShowWatchTab

End

Public Sub mnuUntil_Click()

  RunUntil

End

Public Sub mnuPretty_Click()

  Dim iStart, iEnd As Integer

  If Editor.Selected Then
    iStart = Editor.Selection.StartLine
    iEnd = Editor.Selection.EndLine
  Else
    iStart = 0
    iEnd = Editor.Lines.Count - 1
  Endif

  MPrettyCode.Run(Editor, iStart, iEnd)

End

Public Sub mnuLowerCase_Click()
  
  If Editor.ReadOnly Then Return
  If Not Editor.Selected Then Return
  
  Editor.StoreSelection
  Editor.Begin
  Editor.Insert(String.LCase(Editor.Selection.Text))
  Editor.End
  Editor.RecallSelection
  
End

Public Sub mnuUpperCase_Click()
  
  If Editor.ReadOnly Then Return
  If Not Editor.Selected Then Return
  
  Editor.StoreSelection
  Editor.Begin
  Editor.Insert(String.UCase(Editor.Selection.Text))
  Editor.End
  Editor.RecallSelection
  
End

Public Sub GetFunctionSource(Optional sFunc As String) As String

  Dim sCode As String
  Dim iLine As Integer
  Dim sLine As String
  
  If sFunc Then
    FillProcCombo
    Try iLine = $cProc[sFunc]
    If Error Then Return
  Endif
  
  sLine = Editor.Lines[iLine].Text
  Do
    sCode &= sLine & "\n"
    Inc iLine
    If iLine >= Editor.Lines.Count Then Break
    sLine = Editor.Lines[iLine].Text
    If IsProc(sLine) Then Break
  Loop
  
  Return sCode
  
End

Private Sub FindNextBracket(aSym As String[], I As Integer, sCar1 As String, sCar2 As String) As Integer
  
  Dim iLevel As Integer
  
  While I < aSym.Count
    If aSym[I] = sCar1 Then
      Inc iLevel
    Else If aSym[I] = sCar2 Then
      Dec iLevel
      If iLevel = 0 Then Break
    Endif
    Inc I
  Wend
  
  Return I
  
End


Private Sub GetExpressionTypeWithEval(aSym As String[], aType As Integer[]) As String
  
  Dim I, I2, N As Integer
  Dim cExpr As New Collection
  Dim sExpr As String
  Dim sType As String
  Dim hSymbol As CSymbolInfo
  Dim hType As CDatatype
  Dim vVal As Variant
  Dim bMakeArray As Boolean
  
  While I < aSym.Count
    
    hType = Null
    hSymbol = Null
    sType = ""
    
    If aType[I] = Highlight.Keyword Then
      
      If aSym[I] = "ME" Then
        sType = GetSymbolType("ME")
      Else If aSym[I] = "SUPER" Then
        sType = GetSymbolType("SUPER")
      Endif
      
    Else If aType[I] = Highlight.Symbol Then
      
      If I = 0 Or If aSym[I - 1] <> "." Then
      
        If I < aSym.Max And If aSym[I + 1] = "." Then
          sType = GetSymbolType(aSym[I], True)
        Else
          sType = GetSymbolType(aSym[I])
          If $hSymbol And If $hSymbol.IsFunction() And If I < aSym.Max And If aSym[I + 1] = "(" Then
            I = FindNextBracket(aSym, I, "(", ")")
          Endif
        Endif
        
      Endif
      'If $bLastStatic Then sType = ""
      
    Else If aType[I] = Highlight.Function Then
      
      I2 = FindNextBracket(aSym, I, "(", ")")
      hSymbol = CComponent.GetClassSymbols(".")[aSym[I]]
      Try sType = hSymbol.Type
      If sType Then I = I2
        
    Else If aSym[I] = "[" Then
      
      bMakeArray = True
      If I > 0 Then 
        If aType[I - 1] = Highlight.Symbol Or If aSym[I - 1] = ")" Then bMakeArray = False
      Endif
      
      If bMakeArray Then
        I2 = FindNextBracket(aSym, I, "[", "]")
        sExpr &= "CDatatype.__Make("
        aSym.Add(")", I2 + 1)
        aType.Add(Highlight.Operator, I2 + 1)
      Endif
      
    Endif
    
    If sType Then
      
      Inc N
      sExpr &= " __" & CStr(N)
      cExpr["__" & CStr(N)] = CDatatype.__Get(sType)
      
    Else
      If InStr(".!()[],;", aSym[I]) = 0 Then sExpr &= " "
      sExpr &= aSym[I]
    Endif
    
    Inc I
  Wend
  
  'Print sExpr
  vVal = Eval(sExpr, cExpr)
  Try hType = vVal
  If Error Then 
    Select TypeOf(vVal)
      Case gb.Boolean
        Return "b"
      Case gb.Byte
        Return "c"
      Case gb.Date
        Return "d"
      Case gb.Float
        Return "f"
      Case gb.Integer
        Return "i"
      Case gb.Long
        Return "l"
      Case gb.Object
        Return "o"
      Case gb.Pointer
        Return "p"
      Case gb.Short
        Return "h"
      Case gb.Single
        Return "g"
      Case gb.String
        Return "s"
      Case gb.Variant
        Return "v"
    End Select
  Else
    Return hType.__GetType()
  Endif
  
Catch
  
  'Debug Error.Where; ":"; Error.Text
  
End

Private Sub AddLocalVariable(sName As String, sType As String)
  
  Dim iProc As Integer = GetCurrentProcLine(Editor.Line)
  Dim iLine As Integer
  Dim I As Integer
  Dim sLine As String
  Dim iIndent As Integer = Project.TabSize
  
  I = iProc
  
  Do
    Inc I
    If I >= (Editor.Line - 1) Then Break
    sLine = Trim(Highlight.Purge(Editor.Lines[I].Text))
    If sLine And If Left(sLine) <> "'" Then Break
  Loop
  
  iLine = I
  
  Do
    If I >= (Editor.Line - 1) Then Break
    
    sLine = Trim(Highlight.Purge(Editor.Lines[I].Text))
    
    If sLine And If Left(sLine) <> "'" Then
      Highlight.Analyze(sLine)
      If Highlight.Symbols[0] <> "DIM" Then Break
      iIndent = Editor.GetIndent(Editor.Lines[I].Text)
      iLine = I + 1
    Endif
    
    Inc I
  Loop
  
  sLine = Space$(iIndent) & "Dim " & sName & " As " & sType & "\n"
  If Trim(Editor.Lines[iLine].Text) Then sLine &= Space$(iIndent) & "\n"
  If iLine = (iProc + 1) Then sLine = "\n" & sLine
  Editor.Insert(sLine, iLine, 0)
  
End


Private Sub CreateLocalVariable() As Boolean

  Dim aSym As String[] = Highlight.Symbols.Copy()
  Dim aType As Integer[] = Highlight.Types.Copy()
  Dim sName As String
  Dim sType As String
  Dim I As Integer
 
  If aSym.Count < 3 Then Return
 
  If aSym[0] = "TRY" Then
    aSym.Remove(0)
    aType.Remove(0)
  Endif
 
  ' Assignment
  If aSym.Count >= 3 And If aType[0] = Highlight.Symbol And If aSym[1] = "=" Then
    
    sName = aSym[0]
    sType = GetSymbolType(sName)
    If sType Then Return
    
    aSym.Remove(0, 2)
    aType.Remove(0, 2)
    
    If aSym[0] = "NEW" Then
      If aSym.Count >= 2 Then
        sType = aSym[1]
        If aSym.Count >= 3 And If aSym[2] = "[" Then sType = Left(sType) & LCase(Mid$(sType, 2)) & "[]"
      Endif
    Else If aSym[0] = "OPEN" Or If aSym[0] = "PIPE" Or If aSym[0] = "LOCK" Or If aSym[0] = "MEMORY" Then
      sType = "File"
    Else If aSym[0] = "SHELL" Or If aSym[0] = "EXEC" Then
      sType = "Process"
    Else If aSym[0] = "RAISE"
      sType = "b"
    Else If aSym[0] = "READ" And If aSym.Count >= 4 Then
      If aSym[aSym.Max - 1] = "AS" And If aType[aSym.Max] = Highlight.DataType Then
        sType = CSymbolInfo.NameToType(aSym[aSym.Max])
      Else
        sType = "s"
      Endif
    Else
      sType = GetExpressionTypeWithEval(aSym, aType)
    Endif

  ' For ... To
  Else If aSym.Count >= 6 And If aSym[0] = "FOR" And If aType[1] = Highlight.Symbol And If aSym[2] = "=" Then
    
    sName = aSym[1]
    sType = GetSymbolType(sName)
    If sType Then Return
  
    aSym.Remove(0, 3)
    aType.Remove(0, 3)
    
    For I = 0 To aSym.Max
      If aSym[I] = "TO" Or If aSym[I] = "DOWNTO" Then
        aSym.Remove(I, -1)
        aType.Remove(I, -1)
        Break
      Endif
    Next
    
    sType = GetExpressionTypeWithEval(aSym, aType)
  
  ' For Each ... In
  Else If aSym.Count >= 5 And If aSym[0] = "FOR" And If asym[1] = "EACH" And If aType[2] = Highlight.Symbol And If aSym[3] = "IN" Then
    
    sName = aSym[2]
    sType = GetSymbolType(sName)
    If sType Then Return
  
    aSym.Remove(0, 4)
    aType.Remove(0, 4)
    
    aSym.Insert([".", "_next", "(", ")"])
    aType.Insert([Highlight.Operator, Highlight.Symbol, Highlight.Operator, Highlight.Operator])
    
    sType = GetExpressionTypeWithEval(aSym, aType)
    
  ' Line Input
  Else If aSym.Count >= 3 And If aSym[0] = "LINE" And If aSym[1] = "INPUT" Then
    
    I = aSym.Max
    While I > 2
      If aType[I] = Highlight.Symbol Then Break
      Dec I
    Wend
    
    If I > 2 Then
      sName = aSym[I]
      sType = GetSymbolType(sName)
      If sType Then Return
  
      sType = "s"
    Endif
  
  Endif

  If sType Then
    AddLocalVariable(sName, CSymbolInfo.GetType(sType))
    Return True
  Endif
  
End

Public Sub mnuBookmark_Show()
  
  $hBookmark.Update
  
End
