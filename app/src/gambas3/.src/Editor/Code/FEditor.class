' Gambas class file

Public Path As String '' Source file absolute path.
Public RichText As String
Public Scan As Collection '' The result of the class symbol analyze.
Public ParentClass As String '' The parent class.
Public ParentComponent As String '' The component of the parent class.
Public AutoCreatable As Boolean '' If the class has `CREATE STATIC`.
Public NotCreatable As Boolean '' If the class has `CREATE PRIVATE`.
Public Age As Integer '' The text age. It is incremented each time the text is modified

Property Read ReadOnly As Boolean '' If the editor is read-only.

Public Const IDENT_CAR As String = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_$"
Public Const NBR_COLOR As Integer = 15

Static Public StructControlCompletion As Boolean = True
Static Public LocalVariableDeclaration As Boolean = False
Static Public AutoComment As Boolean = True
Static Public ExpressionStart As Integer

Static Private $cStructClose As New Collection(gb.IgnoreCase)

Static Private $hVirtualSymbol As New CSymbolInfo(Project.Documentation)

Static Private $bPublic As Boolean
Static Private $bStatic As Boolean
Static Private $sName As String

Private $hEditor As TextEditor
Private $bModify As Boolean
'PRIVATE $cLine AS NEW Collection
Private $bToolbar As Boolean
Private $iLastLine As Integer
Private $hSymbol As CSymbolInfo
Private $bCheckSignature As Boolean
Private $iArgSignature As Integer
Private $iPosSignature As Integer
Private $bCleanOnSave As Boolean
Private $bShowPopupHelp As Boolean

Private $bDoNotSavePosition As Boolean

Private Const TYPE_SYMBOL As Integer = 0
Private Const TYPE_FUNCTION As Integer = 1
Private Const TYPE_ARRAY As Integer = 2

Private $bLastStatic As Boolean

Private $iViewMode As Integer
Private VIEWMODE_NORMAL As Integer = 0
Private VIEWMODE_HORIZONTAL As Integer = 1
Private VIEWMODE_VERTICAL As Integer = 2

Private $hEditor1 As TextEditor
Private $hEditor2 As TextEditor

Private $cProc As New Collection(gb.IgnoreCase)
Private $aProc As New String[]
Private $iFirstProcLine As Integer

Private $sModule As String

Private $hSampleCode As CSampleCode
Private $iSampleStart As Integer
Private $iSampleEnd As Integer
Private $iSamplePos As Integer

Private $hInsertColor As CInsertColor
Private $hBookmark As CBookmark
Private $hCompletion As CCompletion

'Static Private $cLastClassCount As New Collection


Static Public Sub _init()

  $cStructClose["DO"] = "Loop"
  $cStructClose["WHILE"] = "Wend"
  $cStructClose["REPEAT"] = "Until"
  $cStructClose["SELECT"] = "End Select"
  $cStructClose["FOR"] = "Next"
  $cStructClose["WITH"] = "End With"
  $cStructClose["ELSE"] = "<"
  $cStructClose["CASE"] = "<"
  $cStructClose["DEFAULT"] = "<"
  $cStructClose["CATCH"] = "<"
  $cStructClose["FINALLY"] = "<"
  
  StructControlCompletion = Settings["/Editor/ControlStructCompletion", 1]
  LocalVariableDeclaration = Settings["/Editor/LocalVariableDeclaration", 0]
  AutoComment = Settings["/Editor/AutoComment", 1]
  
End

Public Sub _new(sPath As String)

  Dim hModule As CModule

  $iLastLine = -1

  Path = sPath
  Me.Name = File.BaseName(Path)

  $hEditor = edtEditor
  edtEditor.ShowIcon = True
  edtEditor.ShowBraces = True 
  edtEditor.Highlight = "gambas"

  $hInsertColor = New CInsertColor(Me, btnInsertColor)
  $hBookmark = New CBookmark(Me, btnBookmark, mnuBookmark)
  $hCompletion = New CCompletion(Me)

  ReadConfig
  Refresh

  'Editor = edtEditor
  Me.Icon = Picture["img/16/" &/ File.ext(sPath) & ".png"]

  For Each hModule In CModule.All
    If Exist(File.SetExt(Path, hModule.Key)) Then
      $sModule = hModule.Key
      btnForm.Visible = True
    Endif
  Next

  $bDoNotSavePosition = True

End

Public Sub GetEditor() As TextEditor
  
  Return $hEditor
  
End


Public Sub Refresh()

  edtEditor.TabSize = Project.TabSize
  If $hEditor1 Then $hEditor1.TabSize = Project.TabSize
  If $hEditor2 Then $hEditor1.TabSize = Project.TabSize

End

Public Sub ReadConfig()

  $bToolBar = Settings["/Editor/Toolbar", True]
  panToolbar.Visible = $bToolbar
  Form_Arrange

  edtEditor.ReadConfig
  'edtEditor.Parent.Background = edtEditor.Styles[Highlight.Background].Color
  If $hEditor1 Then $hEditor1.ReadConfig
  If $hEditor2 Then $hEditor2.ReadConfig

  $hCompletion.ReadConfig
  $bCleanOnSave = Settings["/Editor/CleanOnSave", False]

  $bShowPopupHelp = Settings["/Editor/ShowPopupHelp", True]

  Project.SetSmallFont(panToolbar)

  RefreshBackground

End

Public Function Save() As Boolean

  Dim sHeader As String

  If Me.ReadOnly Then Return
  
  If Not $bModify Then
    ' TODO: If bReset Then $hEditor.Reset
    Return
  Endif

  Editors_Scroll
  
  Save.Begin(Path)

  sHeader = "' Gambas " & File.Ext(Path) & " file"

  $hEditor.Begin

  If RTrim($hEditor[0].Text) <> sHeader Then
    $hEditor.Goto(0, 0)
    $hEditor.Insert(sHeader & "\n")
  Endif

  If $hEditor.Count < 2 Or If $hEditor[1].Text Then
    $hEditor.Goto(0, 1)
    $hEditor.Insert("\n")
  Endif

  $hEditor.End
  
  If Settings["/FormatCode/FormatOnLoad"] Then 
    MPrettyCode.Run(edtEditor)
  Endif

  ' Now the Editor.Save() method automatically cancels pending Change events.
  $hEditor.Save(Path)
  
  ' ENDIF

  $bModify = False
  DrawTitle

  ' TODO: If bReset Then $hEditor.Reset

  Save.End()

Catch

  Return Save.Error()

End

Private Sub DrawTitle()

  Project.DrawTitle(Me)

End

' Private Sub DrawInfo()
'
'   lblEditor.Text = CStr(Editor.Line + 1) & ":" & CStr(Editor.Column + 1)
'
' End

Public Sub Modify(Optional bReset As Boolean)

  If Me.ReadOnly Then Return

  If bReset Then

    If Not $bModify Then Return
    $bModify = False

  Else

    $bModify = True
    Inc Project.TimeStamp
    Inc Age
    $cProc.Clear ' = New Collection
    $aProc.Clear ' = New String[]

    FSearch.OnFileChange(Me.Path)
    FDebugInfo.RefreshTabs(Me.Path, Me.Name)

  Endif

  DrawTitle

End

Public Sub Delete()
  
  FSearch.OnFileChange(Me.Path)
  FDebugInfo.RefreshTabs(Me.Path, Me.Name)

  $hBookmark = Null
  $hCompletion = Null
  $hInsertColor = Null

  Super.Delete
  
End

Public Sub Rename(sNewName As String, sNewPath As String)

  Dim sOldName As String = Me.Name
  Dim sOldPath As String = Me.Path

  Me.Name = sNewName
  Path = sNewPath 'File.Dir(Path) &/ sNewName & "." & File.Ext(Path)
  DrawTitle

  FSearch.OnFileChange(sOldPath)
  FDebugInfo.RefreshTabs(sOldPath, sOldName)

  FSearch.OnFileChange(Me.Path)
  FDebugInfo.RefreshTabs(Me.Path, Me.Name)

End


Public Function IsModified() As Boolean

  Return $bModify

End

Public Sub Form_Arrange()

  ' Dim iToolbarOffset As Integer
  '
  ' If $bToolbar Then
  '   panToolBar.Move(0, 0, Me.ClientW)
  '   iToolbarOffset = panToolBar.H
  ' Else
  '   iToolbarOffset = 0
  ' Endif
  '
  ' Select Case $iViewMode
  '   Case VIEWMODE_NORMAL
  '     edtEditor.Move(0, iToolbarOffset, Me.ClientW, Me.ClientH - iToolbarOffset)
  '   Case VIEWMODE_HORIZONTAL
  '     splHorizontal.Move(0, iToolbarOffset, Me.ClientW, Me.ClientH - iToolbarOffset)
  '   Case VIEWMODE_VERTICAL
  '     splVertical.Move(0, iToolbarOffset, Me.ClientW, Me.ClientH - iToolbarOffset)
  ' End Select

  'ResizeProcList

End

Public Sub Editors_Change()
  
  Modify

End

Private Sub RefreshLineInfo(Optional bForce As Boolean) As Boolean

  Dim bNewLine As Boolean

  If bForce Then
    $iLastLine = -1
  Endif

  If $hEditor.Line <> $iLastLine Then

    $iLastLine = $hEditor.Line

    UpdateCurrentProc
    timProc.Stop
    timProc.Start

    If IsModified() Then {Scan} = Null

    If $hSampleCode Then
      If $hEditor.Line < $iSampleStart Or If $hEditor.Line >= $iSampleEnd Then
        $hSampleCode = Null
      Endif
    Endif
    
    bNewLine = True

  Else If $bCheckSignature Or If FSignature.VisibleFrom($hEditor) Then
    
    $bCheckSignature = False
    CheckSignature
    
  Endif

  Return bNewLine

End

Public Sub Editors_Cursor()

  If RefreshLineInfo() Then
    HideMessage
    $hCompletion.Hide
    HideSignature
  Endif

  If $hEditor.Line = $hEditor.StopLine Then Design.CheckErrorMessage(Me)

  CPosition.SaveCurrent(Me)

End

Public Sub Form_GotFocus()

  $hEditor.SetFocus

End

Public Sub Form_Deactivate()

End

Public Sub Goto(iLine As Integer, Optional iColumn As Integer = -1, Optional bCenter As Boolean)

  'DEC iLine
  If iColumn < 0 Then iColumn = $hEditor.Column

  If iLine < 0 Then
    iLine = 0
  Else If iLine >= $hEditor.Count Then
    iLine = $hEditor.Count - 1
    iColumn = $hEditor[iLine].Length
  Endif

  'If Not Editor[iLine].Limit Then Editor[iLine].Expanded = True
  If bCenter Then
    $hEditor.GotoCenter(iColumn, iLine)
  Else
    $hEditor.Goto(iColumn, iLine)
  Endif

End

Public Sub GotoCenter(iLine As Integer, Optional iColumn As Integer = -1)

  Me.Goto(iLine, iColumn, True)

End

Public Sub Editors_Menu()

  If Mouse.Control Then Return

  mnuForm.Visible = Project.ExistForm(Me.Name)
  CreateMenu
  mnuEditor.Popup

End

Private Sub CreateMenu()

  Dim sName As String
  Dim hMenu As Menu
  Dim cFunc As New String[]
  Dim sParent As String
  Dim sNewParent As String
  Dim hParent As Menu
  Dim sFullName As String
  Dim iPos As Integer
  Dim hSymbol As CSymbolInfo
  Dim cSymbol As Collection

  'DIM hPoint AS Picture

  'IF $hMenuGo THEN $hMenuGo.Delete

  '$hMenuGo = NEW Menu(mnuEditor)
  '$hMenuGo.Caption = "&Go to"

  Inc Application.Busy

  mnuGoto.Children.Clear

  cSymbol = Project.Documentation.GetClassSymbols(Me.Name)
  If cSymbol Then
    For Each hSymbol In cSymbol
  
      If LCase(hSymbol.Kind) <> "m" Then Continue
      If hSymbol.LineNumber = 0 Then Continue
      cFunc.Add(hSymbol.Name)
  
    Next
  Endif

  cFunc.Sort(gb.IgnoreCase + gb.Natural)
  hParent = mnuGoto

  'hPoint = Picture["img/16/point.png"]

  For Each sName In cFunc

    hSymbol = cSymbol[sName]
    sFullName = sName

    iPos = InStr(sName, "_")
    If iPos Then
      sNewParent = Left$(sName, iPos - 1)
      sName = Mid$(sName, iPos + 1)
      If Len(sNewParent) = 0 Then
        sNewParent = "(Special)"
        sName = "_" & sName
      Endif
    Else
      sNewParent = ""
    Endif

    If UCase(sNewParent) <> UCase(sParent) Then

      If sNewParent Then

        hParent = New Menu(mnuGoto)
        hParent.Text = sNewParent

      Else

        hParent = mnuGoto

      Endif

      sParent = sNewParent

    Endif

    hMenu = New Menu(hParent) As "mnuGoto"
    hMenu.Text = sName
    hMenu.Tag = hSymbol.LineNumber - 1
    'IF NOT hSymbol.NotPublic THEN hMenu.Picture = hPoint

  Next

  mnuGoto.Visible = cFunc.count > 0
  mnuSepGoto.Visible = cFunc.count > 0
  'mnuStartup.Checked = Project.Startup = File.BaseName(Path)

  UpdateMenu

  Dec Application.Busy

End

Private Sub UpdateMenu()

  Dim bVisible As Boolean

  Action["watch"].Enabled = Project.Running 'AND Len(Trim(edtEditor.Selection.Text)) > 0

  bVisible = Not edtEditor.ReadOnly

  Action[".save,.undo,.redo,.cut,.paste,.paste-special,.comment,.uncomment,.color,.indent,.unindent,.lcase,.ucase,.pretty", Me].Visible = bVisible
  Action[".watch", Me].Visible = Project.Running
  
  mnuAdvanced.Visible = bVisible
  
End

Public Sub mnuGoto_Click()

  GotoFunction(CInt(Last.Tag))

End

Private Function InsertFunction(sProc As String, sType As String, bPublic As Boolean, sSign As String, Optional bStatic As Boolean) As Integer

  Dim iLine As Integer
  Dim iCol As Integer
  Dim sPublic As String
  Dim sStatic As String

  ' For iLine = 0 To Editor.Lines.Count - 1
  '   If IsProc($hEditor[iLine].Text) Then
  '     If Comp($sName, sProc, gb.Text) = 0 Then
  '       Return iLine
  '     Endif
  '   Endif
  ' Next

  FillProcCombo
  Try iLine = $cProc[sProc]
  If Not Error Then Return iLine

  If Me.ReadOnly Then Return -1

  $hEditor.Begin

  iLine = $hEditor.Count - 1
  iCol = $hEditor[iLine].Length
  If iCol Then
    $hEditor.Goto(iCol, iLine)
    $hEditor.Insert("\n")
    Inc iLine
  Endif

  sPublic = If(bPublic, "Public", "Private")
  sStatic = If(bStatic, "Static ", "")
  
  $hEditor.Goto(0, iLine)

  If sType Then
    $hEditor.Insert("\n" & sStatic & sPublic & " Function " & sProc & "(" & sSign & ") As " & sType & "\n\n" & Space$(Project.TabSize) & "\n\nEnd\n")
  Else
    $hEditor.Insert("\n" & sStatic & sPublic & " Sub " & sProc & "(" & sSign & ")\n\n" & Space$(Project.TabSize) & "\n\nEnd\n")
  Endif

  $hEditor.End

  Return iLine + 1

End

Public Sub GotoEvent(sName As String, sEvent As String, Optional sSign As String) As Boolean

  Dim sProc As String
  Dim iLine As Integer

  sProc = sName & "_" & sEvent
  iLine = InsertFunction(sProc, "", True, sSign)
  If iLine < 0 Then Return True
  GotoFunction(iLine) ' + 1, Len(edt$hEditor[iLine]))

End

Public Sub mnuSave_Click()

  Save

End

Public Sub mnuClose_Click()
  
  Me.Close
  
End


Private Sub InsertProperty()

  Dim iPos As Integer
  Dim bStatic As Boolean
  Dim bRead As Boolean
  Dim sName As String
  Dim sName2 As String
  Dim sType As String
  Dim iLine As Integer
  Dim iCol As Integer

  If Highlight.Symbols[0] = "STATIC" Then
    bStatic = True
    iPos = 2
  Else
    iPos = 1
  Endif

  If Highlight.Symbols[iPos] = "READ" Then
    bRead = True
    Inc iPos
  Endif

ANOTHER_SYMBOL: 

  sName = Highlight.Symbols[iPos]
  If sName = "{" Then
    Inc iPos
    If Highlight.Types[iPos] <> Highlight.Symbol Then Return
    sName = Highlight.Symbols[iPos]
    Inc iPos
    If Highlight.Symbols[iPos] <> "}" Then Return
  Else
    If Highlight.Types[iPos] <> Highlight.Symbol Then Return
  Endif
  If Not sName2 Then sName2 = sName

  Inc iPos
  
  If Highlight.Symbols[iPos] = "," Then
    Inc iPos
    Goto ANOTHER_SYMBOL
  Endif
  
  sName = sName2
  
  If Highlight.Symbols[iPos] <> "AS" Then Return
  Inc iPos
  sType = Highlight.Symbols[iPos]
  If Highlight.Types[iPos] <> Highlight.DataType Then Return
  Inc iPos
  If Highlight.Symbols.Max >= iPos Then
    If Highlight.Symbols[iPos] = "[" Then
      sType &= "[]"
    Endif
  Endif

  iLine = $hEditor.Line
  iCol = $hEditor.Column

  $hEditor.Begin
  InsertFunction(sName & "_Read", sType, False, "", bStatic)
  If Not bRead Then
    InsertFunction(sName & "_Write", "", False, "Value As " & sType, bStatic)
  Endif
  $hEditor.End

  $hEditor.Goto(iCol, iLine)

Catch

End

Private Sub CheckCodeSnippet() As Boolean

  Dim sLine As String
  Dim iPos As Integer
  Dim iLine, iCol As Integer

  If Settings["/Editor/CodeSnippet", 1] = 0 Then Return

  If Not $hSampleCode Then

    If $hEditor.Column < $hEditor[$hEditor.Line].Length Then Return

    sLine = String.Left($hEditor[$hEditor.Line].Text, $hEditor.Column)
    For iPos = 1 To Len(sLine)
      If Not IsSpace(Mid$(sLine, iPos, 1)) Then Break
    Next
    If iPos > Len(sLine) Then Return

    sLine = String.Mid$(sLine, iPos)

    CSampleCode.Init
    $hSampleCode = CSampleCode.All[sLine]
    If Not $hSampleCode Then Return

    $iSampleStart = $hEditor.Line
    $iSampleEnd = $iSampleStart + $hSampleCode.GetLineCount()

    $hEditor.Begin
    $hEditor.Remove($hEditor.Column - String.Len(sLine), $hEditor.Line, $hEditor.Column, $hEditor.Line)
    iLine = $hEditor.Line
    iCol = $hEditor.Column
    $iSamplePos = iCol
    $hSampleCode.Insert($hEditor)
    'Editor.Insert($hSampleCode.Make(iIndent), Editor.Line, Editor.Column)
    $hEditor.Goto(iCol, iLine)
    $hEditor.End

  Endif

  If $hSampleCode.GotoNextPos($hEditor, $iSampleStart, $iSampleEnd, $iSamplePos) Then
    $hSampleCode = Null
    Return CheckCodeSnippet()
  Endif

  Return True

End

Private Sub SymbolBegins(aSym As String[], sWith As String) As Boolean

  Dim aWith As String[] = Split(UCase(Trim(sWith)), " ")
  Dim iInd As Integer

  For iInd = 0 To aWith.Max
    If aSym[iInd] <> aWith[iInd] Then Return False
  Next

  Return True

Catch

End

Private Sub DoStructControlCompletion(iLine As Integer, sLine As String, aSymbol As String[]) As Boolean

  Dim bIndent, bUnindent As Boolean
  Dim sClose, sClose2 As String
  Dim iPos, iInd As Integer
  Dim iIndent As Integer
  Dim sIndent As String

  If aSymbol.Count >= 1 Then
    If aSymbol[0] = "IF" And If aSymbol[aSymbol.Max] = "THEN" Then
      bIndent = True
      bUnindent = False
      sClose = "Endif"
      sClose2 = "Else"
    Else If SymbolBegins(aSymbol, "Public Struct") Or If aSymbol[0] = "STRUCT" Then
      bIndent = True
      bUnindent = False
      sClose = "End Struct"
    Else
      sClose = $cStructClose[aSymbol[0]]
      If sClose Then
        bIndent = True
        If sClose = "<" Then sClose = ""
        'bUnindent = sClose = "<"
      Endif
    Endif
  Endif

  If bIndent Then

    iIndent = $hEditor.GetIndent(sLine)

    If sClose Then
      For iInd = $hEditor.Line + 1 To $hEditor.Count - 1
        sLine = $hEditor[iInd].Text
        If Not Trim(sLine) Then Continue
        If Right(RTrim(sLine)) = ":" Then Continue ' Ignore labels
        If Left(LTrim(sLine)) = "'" Then Continue ' Ignore comments
        iPos = $hEditor.GetIndent(sLine)
        If iPos < iIndent Then Break
        If iPos > iIndent Then Continue
        Highlight.Analyze(sLine)
        If SymbolBegins(Highlight.Symbols, sClose) Then
          sClose = ""
        Else If sClose2 And If SymbolBegins(Highlight.Symbols, sClose2) Then
          sClose = ""
        Endif
        Break
      Next
    Endif

    $hEditor.Begin
    If bUnindent And If Not Key.Shift Then
      If IsSpace(Left(sLine, Project.TabSize)) Then
        sLine = Mid$(sLine, Project.TabSize + 1)
        $hEditor[$hEditor.Line].Text = sLine
        iIndent -= Project.TabSize
      Endif
    Endif
    sIndent = Space$(iIndent)
    $hEditor.Insert("\n" & Space$(Project.TabSize) & sIndent)
    If StructControlCompletion Then
      If Not bUnindent And If sClose And If Not Key.Shift Then $hEditor.Insert("\n" & sIndent & sClose)
    Endif
    $hEditor.End
    $hEditor.Goto(Project.TabSize + Len(sIndent), iLine + 1)
    Stop Event
    Return True
  Endif

End


Public Sub Editors_KeyPress()

  Dim sLine As String
  Dim iLine As Integer
  Dim iInd As Integer
  Dim iPos As Integer
  Dim bStop As Boolean
  Dim aSymbol As String[]
  Dim aScan As String[]
  
  'Dim hClass As Class
  'Dim aClass As String[]
  'Dim sClass As String
  'Dim iOldCount As Integer
  
  If $hCompletion.OnKeyPress() Then Return

  If Not $hEditor.ReadOnly Then

    iLine = $hEditor.Line

    If FSignature.VisibleFrom($hEditor) Then
      bStop = bStop Or FSignature.ManageKey()
      'IF Key.Text THEN CheckSignature(Key.Text)
    Endif

    If bStop Then
      Stop Event
      Return
    Endif

  Endif

  If Key.Code = Key.F6 Then

    ToggleProcList
    Stop Event
    
  Else If Key.Code = Key.Pause Then

    '     IF Key.Alt THEN
    '       Design.Stop
    '       STOP EVENT
    '     ENDIF

  Else If Key.Control Then

    If Key.Code = Key.F12 Then
      
      For Each sLine In Split(File.Load("/proc/self/maps"), "\n")
        If InStr(sLine, "[heap]") Then
          aScan = Scan(sLine, "*-* *")
          Print "------------ Heap size is " & Format(Val("&H" & aScan[1] & "&") - Val("&H" & aScan[0] & "&"), "#,##0") & " bytes."
          Break
        Endif
      Next
      
      ' aClass = New String[]
      ' 
      ' For Each hClass In Classes
      '   aClass.Add(hClass.Name)
      ' Next
      ' 
      ' aClass.Sort
      ' 
      ' For Each sClass In aClass
      '   Try hClass = Classes[sClass]
      '   If Error Then Continue
      '   With hClass
      '     iOldCount = 0
      '     Try iOldCount = $cLastClassCount[sClass]
      '     If .Count = iOldCount Then Continue
      '     Print sClass; ": "; .Count;; "("; Format(.Count - iOldCount, "+0"); ")"
      '     $cLastClassCount[sClass] = .Count
      '   End With
      ' Next
    
    Endif

    Return
    
  Endif

  If $hEditor.ReadOnly Then Return

  If Asc(Key.Text) = 13 Then

    sLine = $hEditor[iLine].Text

    If AutoComment And If IsComment(sLine) And If Key.Shift Then

      iInd = $hEditor.GetIndent(sLine)
      If $hEditor.Column > iInd Then
        iPos = iInd + 1
        While Mid$(sLine, iPos, 1) = "'"
          Inc iPos
        Wend
        While Mid$(sLine, iPos, 1) = " "
          Inc iPos
        Wend
        $hEditor.Begin
        $hEditor.Insert("\n" & Space$(iInd))
        $hEditor.End
        $hEditor.Begin
        $hEditor.Insert(Mid$(Left$(sLine, iPos - 1), iInd + 1))
        $hEditor.End
        Stop Event
      Endif

      Return

    Endif

    If $hEditor.Column < String.Len(sLine) Then Return

    If IsProc(sLine) And If Not Key.Shift Then

      For iInd = iLine + 1 To $hEditor.Count - 1
        sLine = $hEditor[iInd].Text
        If IsEndProc(sLine) Then Return
        If IsProc(sLine) Then Break
      Next

      sLine = Trim($hEditor[iLine].Text)

      $hEditor.Begin
      If InStr(sLine, "(") = 0 Then $hEditor.Insert("()")
      $hEditor.Insert(Replace("\n\t\n\t\n\t\nEnd\n", "\t", Space$(Project.TabSize)))
      'edtEditor.Line = iLine + 2
      'edtEditor.Column = 2
      $hEditor.Goto(2, iLine + 2)
      $hEditor.End

      Stop Event
      Return

    Endif

    aSymbol = Highlight.Symbols

    If aSymbol.Count >= 4 Then
      If aSymbol[0] = "PROPERTY" Or If aSymbol[0] = "STATIC" And aSymbol[1] = "PROPERTY" Then
        InsertProperty
        '$hEditor.Insert("\n")
        'Stop Event
        Return
      Endif
    Endif

    If Not Key.Shift And If LocalVariableDeclaration Then
      If CreateLocalVariable() Then
        $hEditor.Goto(-1, $hEditor.Line) 
        iLine = $hEditor.Line
      Endif
    Endif
    
    If DoStructControlCompletion(iLine, sLine, aSymbol) Then Return
    
    
  Else If Key.Code = Key.Space Then

    $bCheckSignature = True
    
  Else If InStr("(),[]", Key.Text) Then

    $bCheckSignature = True

  Else If Key.Code = Key.Tab Then

    If Not $hEditor.Selected Or If $hEditor.Line = $hEditor.SelectionLine Then
      If CheckCodeSnippet() Then Stop Event
    Endif

  Endif
  
End

Static Public Function IsCurrentProc() As Boolean

  Dim aLine As String[]
  Dim bProc As Boolean
  Dim iPos As Integer

  aLine = Highlight.Symbols

  $bPublic = False
  $bStatic = False
  $sName = ""

  For iPos = 0 To aLine.Count - 1

    If aLine[iPos] = "FAST" Then
      Continue
    Endif

    If aLine[iPos] = "PUBLIC" Then
      $bPublic = True
      Continue
    Endif

    If aLine[iPos] = "PRIVATE" Then
      $bPublic = False
      Continue
    Endif

    If aLine[iPos] = "STATIC" Then
      $bStatic = True
      Continue
    Endif

    If aLine[iPos] = "SUB" Then
      bProc = True
      Break
    Endif

    If aLine[iPos] = "PROCEDURE" Then
      bProc = True
      Break
    Endif

    If aLine[iPos] = "FUNCTION" Then
      bProc = True
      Break
    Endif

    Break

  Next

  If Not bProc Then Return

  Inc iPos
  If iPos >= aLine.Count Then Return

  $sName = aLine[iPos]
  If $sName = "{" Then
    Inc iPos
    If iPos >= aLine.Count Then Return
    $sName = aLine[iPos + 1]
  Endif

  Return True

End

Static Public Function IsProc(sLine As String) As Boolean

  Highlight.Analyze(sLine)
  Return IsCurrentProc()

End

Static Public Sub IsComment(sLine As String) As Boolean

  Return Left(LTrim(sLine)) = "'"

End

Static Public Sub IsCurrentEndProc() As Boolean

  Dim aLine As String[]

  aLine = Highlight.Symbols

  If aLine.Count = 1 Then Return aLine[0] = "END"
  If aLine.Count = 2 Then Return aLine[0] = "END" And (aLine[1] = "PROCEDURE" Or aLine[1] = "FUNCTION" Or aLine[1] = "SUB")

End

Static Public Function IsEndProc(sLine As String) As Boolean

  Highlight.Analyze(sLine)
  Return IsCurrentEndProc()

End

Public Function CanSetBreakpoint(iLine As Integer) As Boolean

  Dim sLine As String
  Dim iPos As Integer

  If iLine < 0 Or If iLine >= $hEditor.Count Then Return

  '$hEditor[iLine].Refresh
  sLine = Trim($hEditor[iLine].Text)
  iPos = InStr(sLine, "'")
  If iPos Then sLine = Trim(Left$(sLine, iPos - 1))
  If Len(Trim(sLine)) = 0 Then Return False

  If $cProc.Count Then
    If iLine < $iFirstProcLine Then Return False
    If iLine = $cProc[btnProc.Text] Then Return False
  Else
    If GetCurrentProcLine(iLine) < 0 Then Return False
    If IsProc($hEditor[iLine].Text) Then Return False
  Endif

  Return True

End

Public Sub SetBreakpoint(iLine As Integer, bVal As Boolean) As Boolean

  If bVal And If Not CanSetBreakpoint(iLine) Then Return True

  ' Update debug window
  FDebugInfo.AddBreakpoint(Me.Name, GetProcAt(iLine), iLine, bVal)

  'Editor.Lines.SetFlag(iLine, Editor.Breakpoint, bVal)
  $hEditor[iLine].Breakpoint = bVal
  If iLine = $hEditor.Line Then RefreshLineInfo(True)

End

Private Sub HasBreakpoint(iLine As Integer) As Boolean

  Return $hEditor[iLine].Breakpoint

End

Public Sub CheckBreakpoints()

  Dim iLine As Integer

  For Each iLine In $hEditor.Breakpoints
    If Not CanSetBreakpoint(iLine) Then SetBreakpoint(iLine, False)
  Next

End

Public Function GetBreakpoints(Optional bCheck As Boolean) As Integer[]

  If bCheck Then CheckBreakpoints
  Return $hEditor.Breakpoints
  
End

Private Sub GetIndentWidth(iStart As Integer, iEnd As Integer) As Integer

  Dim iLine As Integer
  Dim sLine As String
  Dim iInd As Integer
  Dim iIndent As Integer = 0

  For iLine = iStart To iEnd - 1
    sLine = $hEditor[iLine].Text
    If LTrim(sLine) Then
      iInd = Len(sLine) - Len(LTrim(sLine))
      If iIndent = 0 Then
        iIndent = iInd
      Else
        iIndent = Min(iIndent, iInd)
      Endif
      If iIndent = 0 Then Break
    Endif
  Next

  Return iIndent

End

Public Sub mnuComment_Click()

  Dim iStartLine As Integer
  Dim iEndLine As Integer
  Dim iLine As Integer
  Dim iIndent As Integer

  If $hEditor.ReadOnly Then Return
  'IF NOT Editor.Selected THEN RETURN

  If $hEditor.Selected Then
    $hEditor.StoreSelection

    iStartLine = Min($hEditor.SelectionLine, $hEditor.Line)
    iEndLine = Max($hEditor.SelectionLine, $hEditor.Line)

    iIndent = GetIndentWidth(iStartLine, iEndLine)

    $hEditor.Begin
    For iLine = iStartLine To iEndLine - 1
      $hEditor[iLine].Text = Space$(iIndent) & "' " & Mid$($hEditor[iLine].Text, iIndent + 1)
    Next
    $hEditor.End
    'Modify

    $hEditor.RecallSelection
  Else
    'Comment only the current line
    iLine = $hEditor.Line
    $hEditor[iLine].Text = Space$(iIndent) & "' " & Mid$($hEditor[iLine].Text, iIndent + 1)
  Endif

End

Public Sub mnuUncomment_Click()

  Dim iLine As Integer
  Dim sLine As String
  Dim iIndent As Integer
  Dim iStartLine As Integer
  Dim iEndLine As Integer

  If $hEditor.ReadOnly Then Return
  'IF NOT Editor.Selected THEN RETURN

  If $hEditor.Selected Then
    $hEditor.StoreSelection

    iStartLine = Min($hEditor.SelectionLine, $hEditor.Line)
    iEndLine = Max($hEditor.SelectionLine, $hEditor.Line)

    iIndent = GetIndentWidth(iStartLine, iEndLine)

    For iLine = iStartLine To iEndLine - 1
      sLine = $hEditor[iLine].Text
      If Len(sLine) < (iIndent + 1) Then Break
      If Left(LTrim(sLine), 1) <> "'" Then Break
    Next

    If iLine = iEndLine Then
      $hEditor.Begin
      For iLine = iStartLine To iEndLine - 1
        If Left(LTrim($hEditor[iLine].Text), 2) = "' " Then
          $hEditor[iLine].Text = Space$(iIndent) & Mid$(LTrim($hEditor[iLine].Text), 3)
        Else
          $hEditor[iLine].Text = Space$(iIndent) & Mid$(LTrim($hEditor[iLine].Text), 2)
        Endif
      Next
      $hEditor.End
      'Modify
    Endif

    $hEditor.RecallSelection
  Else
    iLine = $hEditor.Line
    sLine = $hEditor[iLine].Text
    If Len(sLine) < (iIndent + 1) Then Return
    If Left(LTrim(sLine), 1) <> "'" Then Return
    If Left(LTrim($hEditor[iLine].Text), 2) = "' " Then
      $hEditor[iLine].Text = Space$(iIndent) & Mid$(LTrim($hEditor[iLine].Text), 3)
    Else
      $hEditor[iLine].Text = Space$(iIndent) & Mid$(LTrim($hEditor[iLine].Text), 2)
    Endif
  Endif

End

Public Sub mnuCut_Click()

  $hEditor.Cut

End

Public Sub mnuCopy_Click()

  $hEditor.Copy

End

Public Sub mnuPaste_Click()

  $hEditor.Paste
  $hEditor.SetFocus

End

Public Sub mnuPasteSpecial_Click()

  FPasteSpecial.Run($hEditor)

End

Public Sub mnuUndo_Click()

  $hCompletion.Hide
  HideSignature
  $hEditor.Undo

End

Public Sub mnuRedo_Click()

  $hCompletion.Hide
  HideSignature
  $hEditor.Redo

End

Public Sub mnuForm_Click()

  Project.OpenForm(Me.Name, $sModule)

End

Public Sub mnuGotoLine_Click()

  Dim iLine As Integer

  iLine = FGotoLine.Run($hEditor.Line + 1)
  If iLine <= 0 Then Return
  GotoCenter(iLine - 1, 0)

End

Public Sub Form_Hide()

  Try $hCompletion.Hide
  'Project.Deactivate(ME)

End

Public Sub mnuSelectAll_Click()

  $hEditor.SelectAll

End

' Private Sub GotoPreviousProc()
' 
'   Dim iInd As Integer
' 
'   For iInd = Editor.Line - 2 To 0 Step -1
'     If IsProc($hEditor[iInd].Text) Then
'       Me.Goto(iInd, Editor.Column, True)
'       Return
'     Endif
'   Next
' 
'   Me.Goto(0, Editor.Column)
' 
' End
' 
' Private Sub GotoNextProc()
' 
'   Dim iInd As Integer
' 
'   For iInd = Editor.Line + 1 To Editor.Lines.Count - 1
' 
'     If IsProc($hEditor[iInd].Text) Then
'       Me.Goto(iInd, Editor.Column, True)
'       Return
'     Endif
' 
'   Next
' 
'   Me.Goto(Editor.Lines.Count - 1, Editor.Column)
' 
' End

' PUBLIC SUB btnGoto_Click()
'
'   CreateMenu
'   mnuGoto.Popup(btnGoto.ScreenX, btnGoto.ScreenY + btnGoto.H)
'
' END

'' +Description
'' Read the type of a symbol declared globally, or as a method argument, from an analyzed line of code.
'' +Arguments
'' - #aSym# is an array of symbols (like [Highlight.Symbols]).
'' - #iIndex# is the index of the first symbol to take into account into #aSym#.
'' - #sSymbol# is the name of the local symbol. If specified, it must be the first symbol to read.
'' +Return value
'' This function returns the datatype of the symbol.

Static Public Function ReadSymbolType(aSym As String[], iIndex As Integer, Optional sSymbol As String) As String

  Dim sType As String
  Dim bArray As Boolean

  If sSymbol Then
    If UCase(aSym[iIndex]) <> UCase(sSymbol) Then Return
    Inc iIndex
  Endif

  If aSym[iIndex] = "[" Then
    While iIndex < aSym.Count
      If aSym[iIndex] = "]" Then Break
      Inc iIndex
    Wend
    If aSym[iIndex] <> "]" Then Return
    Inc iIndex
    bArray = True
  Endif

  If aSym[iIndex] <> "AS" Then Return
  Inc iIndex
  If aSym[iIndex] = "NEW" Then Inc iIndex
  If aSym[iIndex] = "STRUCT" Then Inc iIndex

  sType = aSym[iIndex]
  sType = UCase(Left(sType)) & Mid$(sType, 2)

  If (iIndex + 2) < aSym.Count Then
    If aSym[iIndex + 1] = "[" Then bArray = True
  Endif

  If bArray Then Return sType & "[]"

  sType = CSymbolInfo.NameToType(sType)
  Return sType

Catch

End

'' +Description
'' Get information about a local symbol declared with DIM from an analyzed line of code.
'' +Arguments
'' - #aSym# is an array of symbols (like [Highlight.Symbols]).
'' - #iIndex# is the index of the first symbol to take into account into #aSym#.
'' - #sSymbol# is the name of the local symbol to search for.
'' - #hSymbol# is a CSymbolInfo object that will be filled with the type information.
'' +Return value
'' This function returns [TRUE] if the symbol has been found, [FALSE] otherwise.

Static Public Function ReadLocalSymbolType(aSym As String[], iIndex As Integer, sSymbol As String, hSymbol As CSymbolInfo) As Boolean

  Dim sType As String
  Dim sWait As String
  Dim sSym As String

  Do

    If UCase(aSym[iIndex]) = UCase(sSymbol) Then

      hSymbol.Name = aSym[iIndex]

      Inc iIndex

      Do
        If aSym[iIndex] = "AS" Then Break
        Inc iIndex
      Loop

      Inc iIndex
      If aSym[iIndex] = "NEW" Then Inc iIndex

      sType = aSym[iIndex]
      sType = UCase(Left(sType)) & Mid$(sType, 2)

      If (iIndex + 2) < aSym.Count Then
        If aSym[iIndex + 1] = "[" Then 'AND aSym[iIndex + 2] = "]" THEN
          hSymbol.Type = sType & "[]"
          Return True
        Endif
      Endif

      sType = CSymbolInfo.NameToType(sType)
      hSymbol.Type = sType
      Return True
    Endif

    Do
      Inc iIndex
      sSym = aSym[iIndex]
      If sWait Then
        If sSym = sWait Then
          sWait = ""
        Endif
      Else If sSym = "(" Then
        sWait = ")"
      Else If sSym = "[" Then
        sWait = "]"
      Else If aSym[iIndex] = "," Then
        Break
      Endif
    Loop

    Inc iIndex

  Loop

Catch

End

Public Sub GetLastSymbolDesc() As CSymbolInfo

  Return $hSymbol

End

'' +Description
'' Return the datatype of a symbol in the context of the current line.
'' +Arguments
'' -#sSymbol# is the symbol to analyze.
'' -#bPoint# tells if there is point just after the symbol.
'' +Return value
'' The datatype of the symbol is returned, or [NULL] if the symbol is not found.

Public Function GetSymbolType(sSymbol As String, Optional bPoint As Boolean) As String

  Dim iLine As Integer
  Dim iInd As Integer
  Dim aSym As String[]
  Dim sType As String

  'sSymbol = UCase(sSymbol)
  $bLastStatic = False
  $hSymbol = Null

  If sSymbol = "ME" Then
    Return Me.Name
  Endif

  If sSymbol = "SUPER" Then
    Project.Documentation.GetClassSymbols(Me.Name)
    Return ParentClass
  Endif

  If Left(sSymbol) = "{" And If Right(sSymbol) = "}" Then sSymbol = Mid$(sSymbol, 2, -1)

  ' Look for local variables

  iLine = $hEditor.Line

  Do
    Dec iLine
    If iLine < 0 Then Return
    aSym = Highlight.Analyze($hEditor[iLine].Text)
    If aSym.Count >= 1 Then
      If asym.Count = 1 Then
        If aSym[0] = "END" Then Break
      Endif
      If aSym.Count >= 4 Then
        If aSym[0] = "DIM" Then
          If ReadLocalSymbolType(aSym, 1, sSymbol, $hVirtualSymbol) Then
            With $hVirtualSymbol
              '.Name = aSym[1]
              .Class = Me.Name
              .Kind = "l"
              .LineNumber = iLine + 1
              .NotPublic = True
              '.Type = sType
            End With
            $hSymbol = $hVirtualSymbol
            'Debug $hVirtualSymbol.Name;; "->";; $hVirtualSymbol.Type
            Return $hVirtualSymbol.Type
          Endif
        Endif
      Endif
    Endif
    If IsCurrentProc() Then Break
  Loop

  ' Look for parameters

  For iInd = 0 To aSym.Count - 3

    sType = ReadSymbolType(aSym, iInd, sSymbol)
    If sType Then
      With $hVirtualSymbol
        .Name = aSym[iInd]
        .Class = Me.Name
        .Kind = "l"
        .LineNumber = iLine + 1
        .NotPublic = True
        .Type = sType
      End With
      $hSymbol = $hVirtualSymbol
      Return sType
    Endif

  Next

  'IF UCase($sName) = UCase(sSymbol) THEN
  '  GOTO RETURN_FUNCTION
  'ENDIF

  'PRINT "GetSymbolType: "; sSymbol

  ' Look for private symbols

  Try $hSymbol = Project.Documentation.GetClassSymbols(Me.Name)[sSymbol]
  If Not Error Then
    If $hSymbol Then
      ' A private symbol that is a method or an event cannot be followed by a point
      ' So it must be a static class.
      If Not bPoint Or If InStr("Mm:", $hSymbol.Kind) = 0 Then
        ' This must be a private symbol, and so we must ignore inheritance
        If $hSymbol.Class = Me.Name And If Not $hSymbol.Component Then
          '$bLastStatic = $hSymbol.IsStatic()
          Return $hSymbol.Type
        Endif
      Endif

      $hSymbol = Null

    Endif
  Endif

  ' Look for subroutines

  If Not bPoint Then
    $hSymbol = Project.Documentation.GetClassSymbols(".")[sSymbol]
    If $hSymbol Then
      Return $hSymbol.Type
    Endif
  Endif

  ' Look for static classes

  $bLastStatic = True

  If Project.Documentation.Classes.Exist(sSymbol) Then
    'TRY $hSymbol = CComponent.GetClassSymbols(sSymbol)["_call"]
    Return sSymbol
  Endif

  ' Look for project classes

  If Project.Exist(sSymbol) Then
    If Project.ExistForm(sSymbol) Then $bLastStatic = False
    Return sSymbol
  Endif

End

Private Sub GetSymbolWith(aExpr As String[], aType As Integer[], Optional iInd As Integer = -1)

  Dim iLine As Integer
  Dim aWith As String[]
  Dim aWithType As Integer[]
  Dim iLevel As Integer
  Dim iAssign As Integer

  iLine = $hEditor.Line

  Do
    Dec iLine
    If iLine < 0 Then Break
    aWith = Highlight.Analyze($hEditor[iLine].Text)
    If aWith.Count >= 2 Then
      If aWith[0] = "WITH" Then
        If iLevel = 0 Then
          aWithType = Highlight.Types
          aWith.Remove(0)
          aWithType.Remove(0)

          For iAssign = 0 To aWith.Max
            If Right(aWith[iAssign]) = "=" Then
              aWith.Remove(iAssign, -1)
              aWithType.Remove(iAssign, -1)
              Break
            Endif
          Next

          aExpr.Insert(aWith, iInd)
          aType.Insert(aWithType, iInd)
          Return
        Else
          Dec iLevel
        Endif
      Else If aWith[0] = "END" Then
        If aWith[1] = "WITH" Then
          Inc iLevel
        Endif
      Endif
    Endif
    If IsCurrentProc() Then Break
  Loop

End

Private Function IsTypeSymbol(sPattern As String, iType As Integer) As Boolean

  If iType = Highlight.Symbol Then Return True
  If iType = Highlight.DataType Then Return True
  If iType = Highlight.Function Then Return True
  If iType = Highlight.Keyword Then
    If sPattern = "ME" Then Return True
    If sPattern = "SUPER" Then Return True
    If sPattern = "LAST" Then Return True
  Endif

End

Private Sub GetExpressionStart(aExpr As String[], aType As Integer[]) As Integer

  Dim iInd As Integer
  Dim aWait As New String[]
  Dim sPattern As String
  Dim bLastSymbol As Boolean

  For iInd = aExpr.Max DownTo 0

    sPattern = aExpr[iInd]
    If sPattern = ")" Then
      aWait.Push("(")
      bLastSymbol = False
      Continue
    Else If sPattern = "]" Then
      aWait.Push("[")
      bLastSymbol = False
      Continue
    Else If aWait.Count Then
      If sPattern = aWait[aWait.Count - 1] Then
        aWait.Pop
      Endif
      bLastSymbol = False
      Continue
    Else If sPattern = "." Then
      bLastSymbol = False
      Continue
    Else If IsTypeSymbol(sPattern, aType[iInd]) Then
      If Not bLastSymbol Then
        bLastSymbol = True
        Continue
      Endif
    Endif

    Break

  Next

  Inc iInd
  ExpressionStart = iInd
  Return iInd

End

Public Function GetExpressionType(aExpr As String[], aType As Integer[], bPointAfter As Boolean) As String

  Dim iInd As Integer
  Dim aWait As New String[]
  Dim sPattern As String
  Dim sType As String
  Dim cSymbol As Collection

  Dim bNeedMethod As Boolean

  $hSymbol = Null

  iInd = GetExpressionStart(aExpr, aType)

  If iInd >= aExpr.Count Then

    If iInd > 0 Then
      If Not bPointAfter Then Return
      Select Case aType[iInd - 1]
        Case Highlight.Operator, Highlight.Keyword
        Default
          Return
      End Select
    Endif

    GetSymbolWith(aExpr, aType)
    'PRINT "#1 WITH: "; aExpr.Join("/")

  Else If aExpr[iInd] = "." Then
    GetSymbolWith(aExpr, aType, iInd)
    'PRINT "#2 WITH: "; aExpr.Join("/")
  Endif

  For iInd = iInd To aExpr.Count - 1

    sPattern = aExpr[iInd]
    'PRINT sPattern

    If sPattern = "(" Then
      'INC $bInMethod
      aWait.Push(")")
      Continue
    Else If sPattern = "[" Then
      aWait.Push("]")
      Continue
    Else If aWait.Count Then
      If sPattern = aWait[aWait.Count - 1] Then
        aWait.Pop
        If aWait.Count Then Continue
      Else
        Continue
      Endif
    Endif

    'IF aType[iInd] = Editor.Symbol OR aType[iInd] = Editor.DataType OR aType[iInd] = Editor.Keyword THEN
    If IsTypeSymbol(sPattern, aType[iInd]) Then
      If Not sType Then
        If iInd >= (aExpr.Count - 1) Then
          sType = GetSymbolType(sPattern, bPointAfter)
        Else
          sType = GetSymbolType(sPattern, aExpr[iInd + 1] = ".")
        Endif
        If $hSymbol Then
          '$bLastStatic = FALSE
          sType = $hSymbol.Type
          bNeedMethod = LCase($hSymbol.Kind) = "m"
        Endif
      Endif
      If Not sType Then Return
    Else If sPattern = "." Then
      If iInd <= (aExpr.Count - 2) Then
        If sType Then
          If aType[iInd + 1] = Highlight.Symbol Then
            'PRINT sType; " ";
            cSymbol = Project.Documentation.GetClassSymbols(sType)
            $hSymbol = Null
            Try $hSymbol = cSymbol[aExpr[iInd + 1]]
            If Not $hSymbol Then Return
            sType = $hSymbol.Type
            $bLastStatic = False ' A property cannot return static classes
            'PRINT sType
            If Not sType Then Return
            If LCase($hSymbol.Kind) = "m" Then bNeedMethod = True
            Inc iInd
          Else
            Return
          Endif
        Else
          Return
        Endif
      Else
        Return
      Endif
    Else If sPattern = ")" Then
      If bNeedMethod Then
        bNeedMethod = False
      Else
        Try $hSymbol = Project.Documentation.GetClassSymbols(sType)["_call"]
        If Not $hSymbol Then Return
        sType = $hSymbol.Type ' A method cannot return static classes
        $bLastStatic = False
      Endif
    Else If sPattern = "]" Then
      
      If Not sType Then ' Array constructor operator [ ... ]
        Return
      Else
        Try $hSymbol = Project.Documentation.GetClassSymbols(sType)["_get"]
        If Not $hSymbol Then Return
        sType = $hSymbol.Type
        $bLastStatic = False ' A method cannot return static classes
      Endif
      
    Endif

  Next

  If bNeedMethod Then Return
  Return sType

End

Private Sub GetRightString(sLine As String) As String

  Dim I, iPos As Integer
  Dim sCar As String
  Dim bInside As Boolean
  
  For I = 1 To Len(sLine)
    sCar = Mid$(sLine, I, 1)
    If bInside Then
      If sCar = "\\" Then
        Inc I
      Else If sCar = Chr$(34) Then
        bInside = False
      Endif
    Else If sCar = Chr$(34) Then
      bInside = True
      iPos = I
    Endif
  Next
  
  If bInside Then Return Mid$(sLine, iPos + 1)
  
End


Public Sub CheckCompletion(sMode As String)

  'DIM sMode AS String
  Dim sLine As String
  Dim sType As String
  Dim aSymbols As String[]
  Dim aTypes As Integer[]
  Dim sWord As String
  Dim iPos As Integer

  'IF Key.Code = Key.Backspace THEN
  '  IF FCompletion.IsMine(edtEditor) THEN
  '    sMode = Mid$(sLig, edtEditor.Column - 1, 1)
  '  ENDIF
  'ELSE
  '  sMode = Key.Text
  'ENDIF

  'IF NOT sMode THEN RETURN

  sLine = String.Left$(Highlight.Purge($hEditor.Current.Text, False, True), $hEditor.Column)
  If Right$(RTrim(sLine)) = "'" Then Return

  If sMode = " " Then
    
    If GetRightString(sLine) Then Return
    
    If UCase(Right$(sLine, 3)) = " AS" Or If UCase(Right$(sLine, 4)) = " NEW" Or If UCase(Right$(sLine, 3)) = " IS" Or If UCase(sLine) = "INHERITS" Then
      $hCompletion.Hide
      FCompletion.Open(Me, sMode)
    Endif
    
  Else If sMode = "." Then
    
    If GetRightString(sLine) Then Return
    
    Highlight.Analyze(sLine & ".")
    aSymbols = Highlight.Symbols
    aTypes = Highlight.Types
    aSymbols.Remove(aSymbols.Count - 1)
    aTypes.Remove(aTypes.Count - 1)
    sType = GetExpressionType(aSymbols, aTypes, True)
    If sType Then
      'PRINT "Type: "; sType
      FCompletion.Open(Me, sMode, sType, $bLastStatic, False) 'LCase(sType) = LCase(ME.Name))
    Endif
    
  Else If sMode = "A" Then
    
    If GetRightString(sLine) Then sMode = "I"
    
    If Not FCompletion.VisibleFrom($hEditor) Then
      sWord = $hCompletion.GetWord(sLine & Key.Text, $hEditor.Column + 1)
      If Len(sWord) >= 3 Then FCompletion.Open(Me, sMode, sWord)
      'IF Len(sWord) >= 3 THEN DEBUG FindCompletion(sWord).Join(" ")
    Endif
    
  Else If sMode = "_" Then
    
    If Not FCompletion.VisibleFrom($hEditor) Then
      sWord = $hCompletion.GetWord(sLine, $hEditor.Column)
      If Len(sWord) >= 3 Then
        FCompletion.Open(Me, "A", sWord & "_")
      Endif
      'IF Len(sWord) >= 3 THEN DEBUG FindCompletion(sWord).Join(" ")
    Endif
    
  Else If sMode = "<" Then
    
    If Not $hEditor.Selected And If $hEditor.Column >= 1 And If Not FCompletion.VisibleFrom($hEditor) Then
      
      sLine = String.Left(sLine, -1)
      sWord = GetRightString(sLine)
      
      If sWord Then
        
        If FCompletion.IsPath(sWord) Then
          FCompletion.Open(Me, "/", sWord)
          Return
        Endif
        
      Else
        
        $bCheckSignature = True
        
        sWord = $hCompletion.GetWord(sLine, $hEditor.Column - 1)
        If Right(sLine) <> "." And If Len(sLine) > Len(sWord) And If Mid$(sLine, Len(sLine) - Len(sWord), 1) = "." Then
          iPos = $hEditor.Column
          $hEditor.Goto($hEditor.Column - String.Len(sWord) - 2, $hEditor.Line)
          CheckCompletion(".")
          FCompletion.SetText(sWord)
          $hEditor.Goto(iPos, $hEditor.Line)
          Return
        Endif
        
        If Len(sWord) >= 3 Then 
          FCompletion.Open(Me, sMode, sWord)
          Return
        Endif
        
      Endif
      
      $hCompletion.Hide
        
    Endif
    
  Else If sMode = "/" Then
    
    sWord = GetRightString(sLine & "/")
    If sWord Then FCompletion.Open(Me, "/", sWord)
    
  Else
    
    $hCompletion.Hide
    
  Endif

End

Private Function GetExpressionSignature(aExpr As String[], aType As Integer[]) As CSymbolInfo

  Dim iInd As Integer
  Dim sWait As New String[]
  Dim sPattern As String
  Dim sType As String
  Dim bNew As Boolean

  $hSymbol = Null
  $iArgSignature = 0

  For iInd = aExpr.Count - 1 To 0 Step -1

    sPattern = aExpr[iInd]
    If sPattern = ")" Then
      sWait.Push("(")
      'bLastSymbol = FALSE
      Continue
    Else If sPattern = "]" Then
      sWait.Push("[")
      'bLastSymbol = FALSE
      Continue
    Else If sWait.Count Then
      If sPattern = sWait[sWait.Count - 1] Then
        sWait.Pop
      Endif
      'bLastSymbol = FALSE
      Continue
    Else If sPattern = "(" Or sPattern = "[" Then
      Break
    Else If sPattern = "," Then
      Inc $iArgSignature
    Endif

  Next

  If iInd < 1 Then Return

  $iPosSignature = Highlight.Positions[iInd - 1]

  If iInd >= 2 Then bNew = aExpr[iInd - 2] = "NEW"

  aExpr.Remove(iInd, -1)
  aType.Remove(iInd, -1)

  sType = GetExpressionType(aExpr, aType, False)
  'IF NOT $hSymbol THEN
  If sType Then
    If sPattern = "(" Then
      If bNew Then
        Try $hSymbol = Project.Documentation.GetClassSymbols(sType)["_new"]
      Else
        Try $hSymbol = Project.Documentation.GetClassSymbols(sType)["_call"]
      Endif
    Else If sPattern = "[" Then
      $hSymbol = Null
      Try $hSymbol = Project.Documentation.GetClassSymbols(sType)["_get"]
    Endif
  Endif

  '   IF $hSymbol THEN
  '     IF $hSymbol.IsStatic() XOR $bLastStatic THEN
  '       hClass = CComponent.Classes[$hSymbol.Component &/ $hSymbol.Class]
  '       IF hClass THEN
  '         IF NOT hClass.AutoCreatable THEN
  '           $hSymbol = NULL
  '         ENDIF
  '       ELSE
  '         $hSymbol = NULL
  '       ENDIF
  '     ENDIF
  '   ENDIF

  'ENDIF

  Return $hSymbol

End

Private Function GetExpressionSymbol(aExpr As String[], aType As Integer[]) As CSymbolInfo

  Dim sPattern As String
  Dim sType As String
  Dim bNew As Boolean

  $hSymbol = Null
  If aExpr.Count = 0 Then Return

  sPattern = aExpr[aExpr.Count - 1]

  If InStr("[(", sPattern) Then
    aType.Remove(aExpr.Count - 1)
    aExpr.Remove(aExpr.Count - 1)
  Endif

  If aExpr.Count >= 2 Then bNew = aExpr[aExpr.Count - 2] = "NEW"

  sType = GetExpressionType(aExpr, aType, False)
  'IF NOT $hSymbol THEN
  'IF sPattern = "(" THEN
  If bNew Then
    Try $hSymbol = Project.Documentation.GetClassSymbols(sType)["_new"]
    'ELSE
    '  TRY $hSymbol = CComponent.GetClassSymbols(sType)["_call"]
  Endif
  'ELSE IF sPattern = "[" THEN
  'TRY $hSymbol = CComponent.GetClassSymbols(sType)["_get"]
  'ENDIF

  '   IF $hSymbol THEN
  '     IF $hSymbol.IsStatic() XOR $bLastStatic THEN
  '       hClass = CComponent.Classes[$hSymbol.Component &/ $hSymbol.Class]
  '       IF hClass THEN
  '         IF NOT hClass.AutoCreatable THEN
  '           $hSymbol = NULL
  '         ENDIF
  '       ELSE
  '         $hSymbol = NULL
  '       ENDIF
  '     ENDIF
  '   ENDIF

  'ENDIF

  If Not $hSymbol Then
    If sPattern = "(" Then
      Try $hSymbol = Project.Documentation.GetClassSymbols(sType)["_call"]
    Else If sPattern = "[" Then
      Try $hSymbol = Project.Documentation.GetClassSymbols(sType)["_get"]
    Endif
  Endif

  Return $hSymbol

End

Private Sub CheckSignature(Optional sText As String)

  Dim sLig As String
  Dim hSymbol As CSymbolInfo
  Dim sKind As String

  If Not $hCompletion.Enabled Then Return

  'sLig = Left$(edtEditor.GetPurgedLine(edtEditor.Line), edtEditor.Column) & sText
  sLig = String.Left$(Highlight.Purge($hEditor.Current.Text), $hEditor.Column) & sText
  Highlight.Analyze(sLig)

  If Not IsCurrentProc() Then

    hSymbol = GetExpressionSignature(Highlight.Symbols, Highlight.Types)

    If hSymbol Then
      sKind = LCase(hSymbol.Kind)
      If InStr(":mx", sKind) Then
        If sKind = ":" Then
          If sLig Not Like ("*RAISE*" & hSymbol.Name & "*") Then Return
        Endif
        FSignature.Open(Me, $iPosSignature, hSymbol, $iArgSignature)
      Endif
      Return
    Endif

  Endif

  HideSignature

End

Private Sub HideSignature()

  FSignature.HideFrom($hEditor)

End

Public Sub Editors_Scroll()

  $hCompletion.Hide
  HideSignature
  HideMessage

End

Public Sub SetReadOnly()

  Dim bReadOnly As Boolean
  
  If Project.ReadOnly Or If Project.Running Or If Project.IsReadOnly(Path) Then
    bReadOnly = True
  Endif

  edtEditor.ReadOnly = bReadOnly
  If $hEditor1 Then $hEditor1.ReadOnly = bReadOnly
  If $hEditor2 Then $hEditor2.ReadOnly = bReadOnly

  Project.UpdateLockedAction(Me)

  DrawTitle
  UpdateMenu

End

Public Sub Reload()

  edtEditor.Load(Path, True)
  $hBookmark.Load()
  If Not Project.RestoringFiles Then
    ' TODO: If Settings["/Editor/Fold"] Then edtEditor.CollapseAll
  Endif

  If Settings["/FormatCode/FormatOnLoad"] Then MPrettyCode.Run(edtEditor)

  $hEditor.SetFocus
  Modify(True)
  
  SetReadOnly

End

Public Sub LoadFile() As Boolean

  Reload

End

Public Sub mnuReload_Click()

  If IsModified() Then
    If Message.Warning(("The file has been modified.\n\nAll your changes will be lost."), ("Reload"), ("Cancel")) <> 1 Then Return
  Endif

  Reload

End

Private Function GetCurrentProcLine(iLine As Integer) As Integer

  $sName = ""

  ' If $cProc.Count Then
  '
  '   iRes = -1
  '   For Each iProc In $cProc
  '     If iRes < iProc And If iProc <= iLine Then
  '       iRes = iProc
  '       $sName = $cProc.Key
  '     Endif
  '   Next
  '   Return iRes
  '
  ' Else

  Do
    If $hEditor[iLine].Limit Then
      If IsProc($hEditor[iLine].Text) Then Return iLine
    Endif
    Dec iLine
    If iLine < 0 Then Return -1
  Loop

  'Endif

End

Public Sub GetProcAt(iLine As Integer) As String

  GetCurrentProcLine(iLine)
  Return $sName

End

Public Sub btnIndent_Click()

  $hEditor.Indent

End

Public Sub btnUnindent_Click()

  $hEditor.Unindent

End

Private Function IsKeyword(iCpt As Integer) As Boolean

  If Highlight.Types[iCpt] = Highlight.Keyword Then Return True
  If Highlight.Types[iCpt] = Highlight.Function Then Return True
  If Highlight.Types[iCpt] = Highlight.Operator And If IsLetter(Left$(Highlight.Symbols[iCpt])) Then Return True

End

Private Sub FindDefinition() As Boolean

  Dim sLig As String
  Dim iCol As Integer
  Dim hSymbol As CSymbolInfo
  Dim hClass As CClassInfo
  Dim iCpt As Integer
  Dim sKeyword As String
  Dim iLine As Integer
  Dim aSym As String[]
  Dim hForm As Object

  iLine = $hEditor.Line
  iCol = $hEditor.Column
  If $hEditor.Selected Then
    If $hEditor.Line <> $hEditor.SelectionLine Then Return
  Endif
  iCol = $hEditor.Column

  sLig = Highlight.Purge($hEditor[iLine].Text)

  Repeat
    Inc iCol
    If iCol > Len(sLig) Then Break
  Until InStr(IDENT_CAR, Mid$(sLig, iCol, 1)) = 0

  If iCol < Len(sLig) Then
    If InStr("[(", Mid$(sLig, iCol, 1)) Then
      Inc iCol
    Endif
  Endif

  sLig = Left$(sLig, iCol - 1)
  If Right(sLig) = "[" Then sLig &= "]"
  'Editor.ShowWord(iLine, iCol, 3)
  Highlight.Analyze(sLig)

  'IF IsCurrentProc() THEN RETURN

  iCpt = Highlight.Types.Max
  sKeyword = ""

  If iCpt >= 0 Then
    sKeyword = Highlight.Symbols[iCpt]

    If IsKeyword(iCpt) Then

      ' If iCpt > 0 Then
      '   Dec iCpt
      '   If IsKeyword(iCpt) Then
      '     sKeyword2 = Highlight.Symbols[iCpt] & sKeyword
      '   Endif
      ' Endif
      '
      ' If sKeyword2 Then
      '   MHelp.ShowWebViewWith(Null, MHelp.TYPE_KEYWORD, sKeyword2)
      '   If FHelpBrowser.Error Then
      '     MHelp.ShowWebViewWith(Null, MHelp.TYPE_KEYWORD, sKeyword)
      '   Endif
      ' Else
      MHelp.ShowHelpBrowserWith(MHelp.TYPE_KEYWORD, sKeyword)
      'Endif
      Return

    Else If Highlight.Types[iCpt] = Highlight.DataType Then

      If System.Datatypes.Exist(sKeyword, gb.IgnoreCase) Then
        MHelp.ShowHelpBrowserWith(MHelp.TYPE_NATIVE, sKeyword)
      Else
        hClass = Project.Documentation.Classes[sKeyword]
        If hClass Then
          'MHelp.GotoClass(hClass.Component, hClass.Name)
          MHelp.ShowHelpBrowserWith(MHelp.TYPE_CLASS, hClass.Name)
        Endif
      Endif
      Return

    Else If iCpt >= 1 And If Highlight.Types[iCpt] = Highlight.Symbol Then
      
      If Highlight.Symbols[iCpt - 1] = "GOTO" Or If Highlight.Symbols[iCpt - 1] = "GOSUB" Then
        
        While iLine > 0
          Dec iLine
          Highlight.Analyze($hEditor[iLine].Text)
          If IsCurrentProc() Then Break
        Wend
        
        While iLine < ($hEditor.Count - 1)
          Inc iLine
          sLig = $hEditor[iLine].Text
          aSym = Highlight.Analyze(Highlight.Purge(sLig))
          If IsCurrentEndProc() Then Break
          If aSym.Count = 2 And If aSym[1] = ":" And If aSym[0] == sKeyWord Then
            CPosition.SaveCurrent(Me)
            GotoCenter(iLine)
            Return
          Endif
        Wend
        
      Endif
    Endif
  Endif

  'Editor.Analyze(Left$(sLig, iCol - 1))
  hSymbol = GetExpressionSymbol(Highlight.Symbols, Highlight.Types)
  If Not hSymbol Then
    If sKeyword Then
      If Project.Documentation.Classes.Exist(sKeyword) Then
        MHelp.ShowHelpBrowserWith(MHelp.TYPE_CLASS, sKeyword)
      Endif
    Endif
    Return
  Endif

  'PRINT hSymbol.Class

  If hSymbol.LineNumber Then 'And If Not bPopupHelp Then
    CPosition.SaveCurrent(Me)
    hForm = Project.OpenFile(hSymbol.Class, hSymbol.LineNumber)
    CPosition.SaveCurrent(hForm)
  Else
    MHelp.ShowHelpBrowserWith(MHelp.TYPE_SYMBOL, hSymbol.Name, hSymbol.Class)
  Endif

End

Public Sub OnProjectDebug()

  SetReadOnly
  If Not Project.Running Then $hEditor.HideMessageLabel

End

Public Sub OnShowString(sStr As String, bIgnoreCase As Boolean)

  edtEditor.ShowString(sStr, bIgnoreCase)
  If $hEditor1 Then $hEditor1.ShowString(sStr, bIgnoreCase)
  If $hEditor2 Then $hEditor2.ShowString(sStr, bIgnoreCase)

End

' Static Public Function GetIdentifier(sLine As String, iPos As Integer) As String
' 
'   Dim sCar As String
'   Dim iPos2 As Integer
' 
'   iPos2 = iPos
' 
'   Do
'     If iPos <= 0 Then Break
'     sCar = String.Mid$(sLine, iPos, 1)
'     If sCar = "?" Then Break
'     If InStr(IDENT_CAR, sCar) = 0 Then Break
'     Dec iPos
'   Loop
' 
'   Inc iPos
' 
'   Do
'     If iPos2 > String.Len(sLine) Then Break
'     sCar = String.Mid$(sLine, iPos, 1)
'     If InStr(IDENT_CAR, sCar) = 0 Then Break
'     Inc iPos2
'   Loop
' 
'   Return String.Mid$(sLine, iPos, iPos2 - iPos)
' 
' Catch
' 
' End

Public Sub WatchExpression()

  Dim sWatch As String

  If Not Project.Running Then Return
  sWatch = Trim($hEditor.SelectedText)
  If Not sWatch Then Return

  FDebugInfo.AddWatch(Trim($hEditor.SelectedText))

End

Public Sub RunUntil()

  If Not CanSetBreakpoint($hEditor.Line) Then Return
  Project.RunUntil(Me, $hEditor.Line)

End

Public Sub Form_Activate()

  RefreshLineInfo(True)
  Project.SetCurrentPopup(mnuEditor)

End

Private Sub RefreshBackground()

  Dim aEditor As TextEditor[] = [$hEditor1, $hEditor2]
  Dim hEditor As TextEditor
  Dim bHasFocus As Boolean

  If aEditor.Exist($hEditor) Then
    
    ' It does not work anymore. Both splitted editors are desaturated!
    Return

    For Each hEditor In aEditor
      If hEditor And If hEditor.HasFocus Then 
        bHasFocus = True
        Break
      Endif
    Next
  
    For Each hEditor In aEditor
  
      If Not hEditor Then Continue
  
      hEditor.ReadConfig
      If Not hEditor.HasFocus Then
        If bHasFocus Then MTheme.InitEditor(hEditor, True)
        hEditor.ShowCurrent = False
        hEditor.ShowModified = False
      Endif
  
    Next
    
  Endif

End

Public Sub Editors_GotFocus()

  $hEditor = Last
  Project.SetCurrentPopup(mnuEditor)

  RefreshBackground
  UpdateCurrentProc

End

Public Sub Editors_LostFocus()
  
  RefreshBackground
  
End

Public Sub Editors_MouseDown()
  
  CPosition.Disable
  
End

Public Sub Editors_MouseUp()

  'HideMessage
  
  CPosition.Enable
  CPosition.SaveCurrent(Me)

  If Mouse.Control Then 
    If Mouse.Left Then
      FindDefinition
    Else If Mouse.Right Then
      CPosition.MovePrevious
    Endif
    Return
  Endif

  If Not $hEditor.Selected Or If $hEditor.SelectionLine <> $hEditor.Line Then
    Return
  Endif

  If Not Project.Running Then
    'FindDefinition(True, Mouse.X, Mouse.Y)
    Return
  Endif

  FDebugInfo.InstantWatch(Trim($hEditor.SelectedText), Me, $hEditor.ToPosX($hEditor.Column), $hEditor.ToPosY() + $hEditor.LineHeight)

End

' Private Sub ShowMessageLabel(sStr As String, X As Integer, Y As Integer, Optional bError As Boolean)
' 
'   X = Editor.ScreenX + X - lblWatch.Parent.ScreenX
'   Y = Editor.ScreenY + Y - lblWatch.Parent.ScreenY
'   
'   lblWatch.Foreground = Editor.Styles[Highlight.Normal].Foreground
'   If bError Then
'     lblWatch.Background = Editor.Styles[Highlight.Breakpoint].Foreground
'   Else
'     lblWatch.Background = Editor.Styles[Highlight.CurrentLine].Foreground
'   Endif
'   lblWatch.Text = Replace(Replace(sStr, "<p>", " "), "<br>", " ")
' 
'   If (Y + lblWatch.H) > lblWatch.Parent.ClientH Then Y -= lblWatch.H + Editor.LineHeight
'   lblWatch.Move(X, Y)
'   
'   lblWatch.Show
'   lblWatch.Raise
'   timWatch.Start
'   Editor.SetFocus
' 
' End

Public Sub ShowWatchResult(sStr As String, X As Integer, Y As Integer)

  Dim bError As Boolean

  If Left(sStr) = "!" Then
    sStr = Mid$(sStr, 2)
    If sStr = "Syntax error" Or If sStr = "Non terminated string" Or If sStr = "Unknown symbol" Then Return
    If sStr Begins "Unexpected " Then Return
    sStr = Design.MakeMessage(sStr)
    bError = True
  Endif

  $hEditor.ShowMessageLabel(Html(sStr), X, Y, bError)

End

Public Sub Editors_Margin()

  Dim Y As Integer
  Y = Last.Line
  Design.SetBreakpoint(Me.Name, Y, Not HasBreakpoint(Y))

End

Public Sub ShowMessage(sMsg As String, Optional sIcon As String, Optional bNoEscape As Boolean)

  Dim hIcon As Picture
  Dim X, Y As Integer

  If Not bNoEscape Then
    sMsg = Replace(sMsg, "\t", "\n")
    sMsg = Replace(sMsg, "    ", "&nbsp;")
    sMsg = Replace(sMsg, "&", "&amp;")
    sMsg = Replace(sMsg, "<", "&lt;")
    sMsg = Replace(sMsg, ">", "&gt;")
    If Left(sMsg, 2) = "**" Then
      sMsg = Trim(Mid$(sMsg, 3))
      hIcon = Picture["icon:/32/error"]
    Endif
  Endif

  If sIcon Then hIcon = Picture[sIcon]

  X = $hEditor.ToPosX()
  Y = $hEditor.ToPosY() + $hEditor.LineHeight \ 2
  If $hEditor.Selected Then
    If $hEditor.SelectionLine = $hEditor.Line Then
      X = ($hEditor.ToPosX($hEditor.Column) + $hEditor.ToPosX($hEditor.SelectionColumn)) \ 2
    Endif
  Endif

  Balloon(sMsg, $hEditor, hIcon, X, Y)

End

Public Sub ShowErrorMessage(sMsg As String, (sIcon) As String)

  $hEditor.SetFocus
  Wait
  $hEditor.ShowMessageLabel(sMsg, $hEditor.ToPosX(), $hEditor.ToPosY() + $hEditor.LineHeight, True)

End

Private Sub HideMessage()

  If Balloon.Control = $hEditor Then
    Balloon.Hide
  Endif
  'timWatch_Timer

End

Public Sub timProc_Timer()

  CheckBreakpoints
  timProc.Enabled = False

End

Private Sub SetComboProcText(sProc As String)

  btnProc.Text = sProc

End

Private Sub UpdateCurrentProc()

  Dim iLine As Integer = GetCurrentProcLine($hEditor.Line)
  Dim sProc As String = $sName

  If Not sProc Then
    sProc = ("(Declarations)")
    iLine = 0
  Endif

  SetComboProcText(sProc)

End

Private Sub FillProcCombo()

  Dim hSymbol As CSymbolInfo
  Dim cSymbol As Collection
  Dim sText As String
  Dim sName As String
  Dim aPrivate As String[]
  Dim aStaticPrivate As String[]
  Dim aStaticPublic As String[]
  Dim aPublic As String[]

  'DIM fTime AS Float
  'DIM iInd AS Integer

  If $cProc.Count Then Return

  Inc Application.Busy

  'fTime = Timer
  'FOR iInd = 1 TO 20
  'aFunc.Clear

  sText = btnProc.Text

  'cmbProc.Clear

  $cProc = New Collection(gb.IgnoreCase)
  $aProc = New String[]
  $iFirstProcLine = 1000000

  {Scan} = Null
  
  If Project.IsSourcePath(Path) Then
    cSymbol = Project.Documentation.GetClassSymbols(Me.Name)
    If Not cSymbol Then cSymbol = New Collection
  Else
    cSymbol = Project.Documentation.ScanSingleClass(Me)
  Endif

  aStaticPrivate = New String[]
  aPrivate = New String[]
  aStaticPublic = New String[]
  aPublic = New String[]
  
  For Each hSymbol In cSymbol

    If LCase(hSymbol.Kind) <> "m" Then Continue
    If hSymbol.LineNumber = 0 Then Continue
    If hSymbol.Class <> Me.Name Then Continue
    
    sName = hSymbol.Name
    
    If hSymbol.IsStatic() Then
      If hSymbol.NotPublic Then
        aStaticPrivate.Add(sName)
      Else
        aStaticPublic.Add(sName)
      Endif
    Else
      If hSymbol.NotPublic Then
        aPrivate.Add(sName)
      Else
        aPublic.Add(sName)
      Endif
    Endif
    
  Next

  aStaticPrivate.Sort(gb.IgnoreCase)
  aPrivate.Sort(gb.IgnoreCase)
  aStaticPublic.Sort(gb.IgnoreCase)
  aPublic.Sort(gb.IgnoreCase)

  If aStaticPublic.Count Then
    $aProc.Add("-STATIC PUBLIC")
    $aProc.Insert(aStaticPublic)
  Endif
  If aPublic.Count Then
    $aProc.Add("-PUBLIC")
    $aProc.Insert(aPublic)
  Endif
  If aStaticPrivate.Count Then
    $aProc.Add("-STATIC PRIVATE")
    $aProc.Insert(aStaticPrivate)
  Endif
  If aPrivate.Count Then
    $aProc.Add("-PRIVATE")
    $aProc.Insert(aPrivate)
  Endif

  For Each sName In $aProc

    If sName Begins "-" Then Continue
    hSymbol = cSymbol[sName]
    'cmbProc.Add(sName)
    $cProc[hSymbol.Name] = hSymbol.LineNumber - 1
    $iFirstProcLine = Min($iFirstProcLine, hSymbol.LineNumber - 1)

  Next

  $aProc.Add(("(Declarations)"), 0)
  $cProc[$aProc[0]] = 0

  SetComboProcText(sText)

  'NEXT
  'DEBUG Timer - fTime

  Dec Application.Busy

End

' Public Sub cmbProc_KeyPress()
'
'   FillProcCombo
'
' End
'
' Public Sub cmbProc_MouseDown()
'
'   FillProcCombo
'
' End

Public Sub GetFunctionLine(sFunc As String) As Integer
  
  Dim iLine As Integer
  
  FillProcCombo
  
  Try iLine = $cProc[sFunc]
  If Not Error Then Return iLine
  
End


Public Sub GotoFunction(iLine As Integer)

  Dim sLine As String
  Dim iCol As Integer
  Dim iStart As Integer

  If iLine < 0 Then
    $hEditor.Goto(0, $hEditor.Count)
    Return
  Endif

  iStart = iLine

  Do
    Inc iLine
    If iLine >= $hEditor.Count Then
      Dec iLine
      Break
    Endif
    sLine = Trim($hEditor[iLine].Text)
    If sLine Then Break
  Loop

  If UCase(sLine) = "END" Or If UCase(sLine) = "END SUB" Then
    iLine = Min(iStart + 2, iLine - 1)
  Endif

  iCol = String.Len($hEditor[iLine].Text) - String.Len(LTrim($hEditor[iLine].Text))

  Me.GotoCenter(iLine, iCol) ', True)
  $hEditor.SetFocus

End

' Public Sub cmbProc_Click()
'
'   Dim iLine As Integer
'
'   Try iLine = $cProc[cmbProc.Text]
'   GotoProc(iLine)
'
' End
'
' Public Sub cmbProc_MouseWheel()
'
'   FillProcCombo
'
' End
'
' Public Sub cmbProc_GotFocus()
'
'   Editor.SetFocus
'
' End

Private Function ReadOnly_Read() As Boolean

  Return edtEditor.ReadOnly

End

Public Sub GetState() As String

  Return CStr($hEditor.Column) & "." & CStr($hEditor.Line)

End

Public Sub SetState(sState As String)

  Dim aState As String[] = Split(sState, ".")

  GotoCenter(CInt(aState[1]), CInt(aState[0]))

End

Private Sub InitEditor(hEditor As TextEditor)

  With hEditor
    .Border = False
    .View = edtEditor
    .Highlight = edtEditor.Highlight
    '.Flags[Editor.Highlight] = True
    .ReadOnly = edtEditor.ReadOnly
    .TabSize = edtEditor.TabSize
    .ShowIcon = True
    .Wrap = edtEditor.Wrap
    '.Flags[Editor.ShowCursorPosition] = edtEditor.Flags[Editor.ShowCursorPosition]
  End With
  hEditor.ReadConfig

End

Private Sub SetViewMode(iViewMode As Integer)

  If $iViewMode = iViewMode Then iViewMode = VIEWMODE_NORMAL
  $iViewMode = iViewMode

  If $iViewMode <> VIEWMODE_NORMAL And If Not $hEditor1 Then
    $hEditor1 = New TextEditor(Me) As "Editors"
    InitEditor($hEditor1)
    $hEditor2 = New TextEditor(Me) As "Editors"
    InitEditor($hEditor2)
    FSearch.OnNewForm(Me)
  Endif

  Select Case $iViewMode

    Case VIEWMODE_NORMAL
      edtEditor.Show
      splHorizontal.Hide
      splVertical.Hide
      edtEditor.GotoCenter($hEditor.Column, $hEditor.Line)
      $hEditor = edtEditor

    Case VIEWMODE_HORIZONTAL
      $hEditor1.Reparent(splHorizontal)
      $hEditor2.Reparent(splHorizontal)
      edtEditor.Hide
      splHorizontal.Show
      splVertical.Hide
      $hEditor1.GotoCenter($hEditor.Column, $hEditor.Line)
      $hEditor2.GotoCenter($hEditor.Column, $hEditor.Line)
      $hEditor = $hEditor1

    Case VIEWMODE_VERTICAL
      $hEditor1.Reparent(splVertical)
      $hEditor2.Reparent(splVertical)
      edtEditor.Hide
      splHorizontal.Hide
      splVertical.Show
      $hEditor1.GotoCenter($hEditor.Column, $hEditor.Line)
      $hEditor2.GotoCenter($hEditor.Column, $hEditor.Line)
      $hEditor = $hEditor1

  End Select

  $hEditor.SetFocus
  Form_Arrange
  Editors_Cursor

End

Public Sub mnuNoSplit_Click()

  SetViewMode(VIEWMODE_NORMAL)

End

Public Sub mnuHorizontalSplit_Click()

  SetViewMode(VIEWMODE_HORIZONTAL)

End

Public Sub mnuVerticalSplit_Click()

  SetViewMode(VIEWMODE_VERTICAL)

End

Public Sub mnuDefinition_Click()

  FindDefinition

End

Public Sub mnuLastPosition_Click()

  CPosition.MovePrevious

End

Public Sub GetFoldedProc() As Integer[]

  Dim aFold As New Integer[]
  Dim iLine As Integer
  
  Do
    If Not $hEditor[iLine].Expanded Then
      'DEBUG Name;; iLine
      aFold.Add(iLine)
    Endif
    iLine = $hEditor.FindNextLimit(iLine)
    If iLine < 0 Then Break
  Loop
  
  Return aFold

End

Public Sub SetFoldedProc(aFold As Integer[])

  Dim iLine As Integer
  
  $hEditor.ExpandAll
  For Each iLine In aFold
    'DEBUG Name;; iLine
    $hEditor[iLine].Expanded = False
  Next

End

' Public Sub mnuStartup_Click()
' 
'   If mnuStartup.Checked Then Return
'   mnuStartup.Checked = True
'   Project.DefineStartup(Path)
' 
' End

Public Sub mnuPasteAsString_Click()

  FPasteSpecial.Run($hEditor, FPasteSpecial.MODE_STRING)

End

Public Sub mnuPasteAsStringSplit_Click()

  FPasteSpecial.Run($hEditor, FPasteSpecial.MODE_STRING_SPLIT)

End

Public Sub mnuPasteAsComment_Click()

  FPasteSpecial.Run($hEditor, FPasteSpecial.MODE_COMMENT)

End

Public Sub panToolBar_Configure()

  UpdateMenu
  
  If $sModule Then
    'Action[".show-form"].Picture = Project.GetFileIcon(File.SetExt(Path, $sModule), 16)
    btnForm.ToolTip = CModule[$sModule].Name
    btnForm.Show
    mnuForm.Show
  Else
    btnForm.Hide
    mnuForm.Hide
  Endif

End

' Private Sub ResizeProcList()
' 
'   panProc.Resize(btnProc.W, Min(panProc.Parent.ClientH - panProc.Y + 1, gvwProc.Rows.Count * gvwProc.Rows.H + 2))
' 
' End

Private Sub ToggleProcList()

  Dim iCurrent As Integer
  Dim iLine As Integer

  FillProcCombo
  iCurrent = $aProc.Find(btnProc.Text)

  iCurrent = FProcedureList.Popup(Me, Me.Name, $aProc, iCurrent, btnProc.ScreenX, btnProc.ScreenY + btnProc.H, Desktop.Scale * 48, Me.ClientH - panToolbar.H - Desktop.Scale)
  If iCurrent >= 0 Then
    Try iLine = $cProc[$aProc[iCurrent]]
    GotoFunction(iLine)
  Endif

End

Public Sub btnProc_MouseDown()

  If Not Mouse.Left Then Return
  ToggleProcList
  Stop Event

End

' Public Sub gvwProc_LostFocus()
'
'   panProc.Hide
'
' End
'
' Public Sub gvwProc_Data(Row As Integer, Column As Integer)
'
'   Dim cSymbol As Collection
'   Dim hSymbol As CSymbolInfo
'   Dim sName As String
'
'   'Dim hColor As Color
'
'   Try sName = $aProc[Row]
'   If Not sName Then Return
'
'   cSymbol = CComponent.GetClassSymbols(Me.Name)
'   hSymbol = cSymbol[sName]
'
'   gvwProc.Data.Text = sName
'   If hSymbol Then
'     If hSymbol.Kind = "M" Then gvwProc.Data.Font.Bold = True
'     If hSymbol.NotPublic Then
'       'hColor = Color(Color.Foreground)
'       'hColor.Value = 255 - (255 - hColor.Value) * 0.6
'       gvwProc.Data.Foreground = Color.Lighter(Color.Foreground)
'     Endif
'     'gvwProc.Data.Picture = Picture[hSymbol.GetIcon()]
'   Else
'     gvwProc.Data.Foreground = Color.Lighter(Color.Foreground)
'   Endif
'   If Left(sName) = "_" Then
'     'gvwProc.Data.Picture = Picture["img/16/point.png"]
'     'gvwProc.Data.Foreground = Color.Lighter(Color.Foreground)
'   Else If InStr(sName, "_") Then
'     'gvwProc.Data.Picture = Picture["img/16/event.png"]
'     gvwProc.Data.Font.Italic = True
'   Endif
'
'   If sName = btnProc.Text Then
'     gvwProc.Data.Background = Color.LightBackground
'   Endif
'
' End
'
' Public Sub gvwProc_Click()
'
'   Dim iLine As Integer
'
'   Try iLine = $cProc[$aProc[gvwProc.Row]]
'   GotoProc(iLine)
'
' End
'
' Public Sub gvwProc_MouseMove()
'
'   Dim iRow As Integer = gvwProc.RowAt(Mouse.Y)
'
'   Try gvwProc.Rows[iRow].Selected = True
'
' End
'
' Public Sub btnProc_DblClick()
'
'   btnProc_MouseDown
'
' End

'' Update a control name and its event handler in the source code when it is renamed

Public Sub RenameControl(sOld As String, sNew As String)

  Dim iLine As Integer
  Dim sLine As String
  Dim aSym As String[]
  Dim iInd As Integer
  Dim sSym As String
  Dim bChange As Boolean
  Dim bInProc As Boolean

  sOld = UCase(sOld)

  $hEditor.Begin

  For iLine = 0 To $hEditor.Count - 1

    sLine = $hEditor[iLine].Text
    aSym = Highlight.Analyze(sLine)
    bChange = False
    
    If Not bInProc Then
      If IsCurrentProc() Then
        bInProc = True
      Else
        Continue
      Endif
    Else
      If IsCurrentEndProc() Then
        bInProc = False
        Continue
      Endif
    Endif
    
    If aSym.Count Then
     If aSym[0] = "Dim" Then Continue
    Endif

    For iInd = aSym.Max DownTo 0

      If Highlight.Types[iInd] <> Highlight.Symbol Then Continue

      sSym = UCase(aSym[iInd])

      If sSym <> sOld Then
        If Not (sSym Begins (sOld & "_")) Then Continue
      Else
        If iInd > 0 Then
          sSym = aSym[iInd - 1]
          If sSym = "." Then
            If iInd <= 1 Or If aSym[iInd - 2] <> "ME" Then Continue
          Else If sSym = "!" Or If sSym = "AS" Or If sSym = "NEW" Then 
            Continue
          Endif
        Endif
      Endif

      sLine = Left$(sLine, Highlight.Positions[iInd]) & sNew & Mid$(sLine, Highlight.Positions[iInd] + Len(sOld) + 1)
      bChange = True

    Next

    If bChange Then $hEditor[iLine].Text = sLine
  Next

  $hEditor.End

End

Public Sub GetText() As String

  Return $hEditor.Text

End

Public Sub GetPosition() As Integer

  Return $hEditor.GetPosition()

End

Public Sub SetPosition(hResult As CFindResult, Optional bJustCheck As Boolean) As Boolean

  Dim bResult As Boolean

  If FSearch.CurrentProcedure Then
    bResult = $hEditor.SetPosition(hResult, True)
    If Not bResult Then
      If FSearch.CurrentProcedureName <> GetProcAt(hResult.Line) Then bResult = True
    Endif
    If Not bResult And If Not bJustCheck Then $hEditor.SetPosition(hResult, False)
  Else
    bResult = $hEditor.SetPosition(hResult, bJustCheck)
  Endif
  Return bResult

End

Public Sub Replace(sReplace As String)

  $hEditor.Replace(sReplace)

End

Public Sub GetSelection() As String

  Return $hEditor.GetSelection()

End

Public Sub mnuInsertColor_Click()

  $hInsertColor.Insert

End

Public Sub mnuBreakpoint_Click()

  Design.SetBreakpoint(Me.Name, $hEditor.Line, Not HasBreakpoint($hEditor.Line))

End

Public Sub mnuWatch_Click()

  WatchExpression
  FDebugInfo.ShowWatchTab

End

Public Sub mnuUntil_Click()

  RunUntil

End

Public Sub mnuPretty_Click()

  Dim iStart, iEnd As Integer

  If $hEditor.Selected Then
    iStart = Min($hEditor.Line, $hEditor.SelectionLine)
    iEnd = Max($hEditor.Line, $hEditor.SelectionLine)
  Else
    iStart = 0
    iEnd = $hEditor.Count - 1
  Endif

  MPrettyCode.Run($hEditor, iStart, iEnd)

End

Public Sub mnuLowerCase_Click()
  
  If $hEditor.ReadOnly Then Return
  $hEditor.LowerCase
  
End

Public Sub mnuUpperCase_Click()
  
  If $hEditor.ReadOnly Then Return
  $hEditor.UpperCase
  
End

Public Sub GetFunctionSource(Optional sFunc As String) As String

  Dim sCode As String
  Dim iLine As Integer
  Dim sLine As String
  
  If sFunc Then
    FillProcCombo
    Try iLine = $cProc[sFunc]
    If Error Then Return
  Endif
  
  sLine = $hEditor[iLine].Text
  Do
    sCode &= sLine & "\n"
    Inc iLine
    If iLine >= $hEditor.Count Then Break
    sLine = $hEditor[iLine].Text
    If IsProc(sLine) Then Break
  Loop
  
  Return sCode
  
End

Private Sub FindNextBracket(aSym As String[], I As Integer, sCar1 As String, sCar2 As String) As Integer
  
  Dim iLevel As Integer
  
  While I < aSym.Count
    If aSym[I] = sCar1 Then
      Inc iLevel
    Else If aSym[I] = sCar2 Then
      Dec iLevel
      If iLevel = 0 Then Break
    Endif
    Inc I
  Wend
  
  Return I
  
End


Private Sub GetExpressionTypeWithEval(aSym As String[], aType As Integer[]) As String
  
  Dim I, I2, N As Integer
  Dim cExpr As New Collection
  Dim sExpr As String
  Dim sType As String
  Dim hSymbol As CSymbolInfo
  Dim hType As CDatatype
  Dim vVal As Variant
  Dim bMakeArray As Boolean
  
  While I < aSym.Count
    
    hType = Null
    hSymbol = Null
    sType = ""
    
    If aType[I] = Highlight.Keyword Then
      
      If aSym[I] = "ME" Then
        sType = GetSymbolType("ME")
      Else If aSym[I] = "SUPER" Then
        sType = GetSymbolType("SUPER")
      Endif
      
    Else If aType[I] = Highlight.Symbol Then
      
      If I = 0 Or If aSym[I - 1] <> "." Then
      
        If I < aSym.Max And If aSym[I + 1] = "." Then
          sType = GetSymbolType(aSym[I], True)
        Else
          sType = GetSymbolType(aSym[I])
          If $hSymbol And If $hSymbol.IsFunction() And If I < aSym.Max And If aSym[I + 1] = "(" Then
            I = FindNextBracket(aSym, I, "(", ")")
          Endif
        Endif
        
      Endif
      'If $bLastStatic Then sType = ""
      
    Else If aType[I] = Highlight.Function Then
      
      I2 = FindNextBracket(aSym, I, "(", ")")
      hSymbol = Project.Documentation.GetClassSymbols(".")[aSym[I]]
      Try sType = hSymbol.Type
      If sType Then I = I2
        
    Else If aSym[I] = "[" Then
      
      bMakeArray = True
      If I > 0 Then 
        If aType[I - 1] = Highlight.Symbol Or If aSym[I - 1] = ")" Or If aSym[I - 1] = "ME" Or If aSym[I - 1] = "SUPER" Then bMakeArray = False
      Endif
      
      If bMakeArray Then
        I2 = FindNextBracket(aSym, I, "[", "]")
        sExpr &= "CDatatype.__Make("
        aSym.Add(")", I2 + 1)
        aType.Add(Highlight.Operator, I2 + 1)
      Endif
      
    Endif
    
    If sType Then
      
      Inc N
      sExpr &= " __" & CStr(N)
      cExpr["__" & CStr(N)] = CDatatype.__Get(sType)
      
    Else
      If InStr(".!()[],;", aSym[I]) = 0 Then sExpr &= " "
      sExpr &= aSym[I]
    Endif
    
    Inc I
  Wend
  
  'Print sExpr
  vVal = Eval(sExpr, cExpr)
  Try hType = vVal
  If Error Then 
    Select TypeOf(vVal)
      Case gb.Boolean
        Return "b"
      Case gb.Byte
        Return "c"
      Case gb.Date
        Return "d"
      Case gb.Float
        Return "f"
      Case gb.Integer
        Return "i"
      Case gb.Long
        Return "l"
      Case gb.Object
        Return "o"
      Case gb.Pointer
        Return "p"
      Case gb.Short
        Return "h"
      Case gb.Single
        Return "g"
      Case gb.String
        Return "s"
      Case gb.Variant
        Return "v"
    End Select
  Else
    Return hType.__GetType()
  Endif
  
Catch
  
  'Debug Error.Where; ":"; Error.Text
  
End

Private Sub AddLocalVariable(sName As String, sType As String)
  
  Dim iProc As Integer = GetCurrentProcLine($hEditor.Line)
  Dim iLine As Integer
  Dim I As Integer
  Dim sLine As String
  Dim iIndent As Integer = Project.TabSize
  Dim X As Integer
  Dim Y As Integer
  
  X = $hEditor.Column
  Y = $hEditor.Line
  
  I = iProc
  
  Do
    Inc I
    If I >= ($hEditor.Line - 1) Then Break
    sLine = Trim(Highlight.Purge($hEditor[I].Text))
    If sLine And If Left(sLine) <> "'" Then Break
  Loop
  
  iLine = I
  
  Do
    If I >= ($hEditor.Line - 1) Then Break
    
    sLine = Trim(Highlight.Purge($hEditor[I].Text))
    
    If sLine And If Left(sLine) <> "'" Then
      Highlight.Analyze(sLine)
      If Highlight.Symbols[0] = "DIM" Then
        iIndent = $hEditor.GetIndent($hEditor[I].Text)
      Else If $hEditor.GetIndent($hEditor[I].Text) <= iIndent Then
        Break
      Endif
      iLine = I + 1
    Endif
    
    Inc I
  Loop
  
  sLine = Space$(iIndent) & "Dim " & sName & " As " & sType & "\n"
  Inc Y
  If Trim($hEditor[iLine].Text) Then 
    sLine &= Space$(iIndent) & "\n"
    Inc Y
  Endif
  If iLine = (iProc + 1) Then 
    sLine = "\n" & sLine
    Inc Y
  Endif
  
  $hEditor.Goto(0, iLine)
  $hEditor.Insert(sLine)
  $hEditor.Goto(X, Y)
  
End

Private Sub AddGlobalVariable(sName As String, sType As String)
  
  Dim I, iLast As Integer
  Dim sLine As String
  Dim X As Integer
  Dim Y As Integer
  
  X = $hEditor.Column
  Y = $hEditor.Line
  
  For I = 0 To $hEditor.Count - 1
    
    sLine = Trim(Highlight.Purge($hEditor[I].Text))
    If IsProc(sLine) Then Break
    If sLine And If sLine <> "'" Then iLast = I
    
  Next
  
  sLine = "Private " & sName & " As " & sType & "\n"
  Inc Y
  If iLast = 0 Then 
    sLine = "\n" & sLine
    Inc Y
  Endif
  
  $hEditor.Goto(0, iLast + 1)
  $hEditor.Insert(sLine)
  $hEditor.Goto(X, Y)
  
End


Private Sub CreateLocalVariable() As Boolean

  Dim aSym As String[] = Highlight.Symbols.Copy()
  Dim aType As Integer[] = Highlight.Types.Copy()
  Dim sName As String
  Dim sType As String
  Dim I As Integer
 
  If aSym.Count < 3 Then Return
 
  If aSym[0] = "TRY" Then
    aSym.Remove(0)
    aType.Remove(0)
  Endif
  
  If aSym[0] = "IF" Or If aSym[0] = "ELSE" And aSym[1] = "IF" Then
    I = aSym.Find("THEN") + 1
    If I <= 0 Then Return
    aSym.Remove(0, I)
    aType.Remove(0, I)
  Endif
 
  ' Assignment
  If aSym.Count >= 3 And If aType[0] = Highlight.Symbol And If Len(aSym[1]) <= 2 And If Right(aSym[1]) = "=" Then
    
    sName = aSym[0]
    sType = GetSymbolType(sName)
    If sType Then Return
    
    aSym.Remove(0, 2)
    aType.Remove(0, 2)
    
    If aSym[0] = "NEW" Then
      If aSym.Count >= 2 Then
        sType = aSym[1]
        If aSym.Count >= 3 And If aSym[2] = "[" Then sType = Left(sType) & LCase(Mid$(sType, 2)) & "[]"
      Endif
    Else If aSym[0] = "OPEN" Or If aSym[0] = "PIPE" Or If aSym[0] = "LOCK" Or If aSym[0] = "MEMORY" Then
      sType = "File"
    Else If aSym[0] = "SHELL" Or If aSym[0] = "EXEC" Then
      sType = "Process"
    Else If aSym[0] = "RAISE"
      sType = "b"
    Else If aSym[0] = "READ" And If aSym.Count >= 4 Then
      If aSym[aSym.Max - 1] = "AS" And If aType[aSym.Max] = Highlight.DataType Then
        sType = CSymbolInfo.NameToType(aSym[aSym.Max])
      Else
        sType = "s"
      Endif
    Else
      sType = GetExpressionTypeWithEval(aSym, aType)
    Endif

  ' For ... To
  Else If aSym.Count >= 6 And If aSym[0] = "FOR" And If aType[1] = Highlight.Symbol And If aSym[2] = "=" Then
    
    sName = aSym[1]
    sType = GetSymbolType(sName)
    If sType Then Return
  
    aSym.Remove(0, 3)
    aType.Remove(0, 3)
    
    For I = 0 To aSym.Max
      If aSym[I] = "TO" Or If aSym[I] = "DOWNTO" Then
        aSym.Remove(I, -1)
        aType.Remove(I, -1)
        Break
      Endif
    Next
    
    sType = GetExpressionTypeWithEval(aSym, aType)
  
  ' For Each ... In
  Else If aSym.Count >= 5 And If aSym[0] = "FOR" And If asym[1] = "EACH" And If aType[2] = Highlight.Symbol And If aSym[3] = "IN" Then
    
    sName = aSym[2]
    sType = GetSymbolType(sName)
    If sType Then Return
  
    aSym.Remove(0, 4)
    aType.Remove(0, 4)
    
    aSym.Insert([".", "_next", "(", ")"])
    aType.Insert([Highlight.Operator, Highlight.Symbol, Highlight.Operator, Highlight.Operator])
    
    sType = GetExpressionTypeWithEval(aSym, aType)
    
  ' Line Input
  Else If aSym.Count >= 3 And If aSym[0] = "LINE" And If aSym[1] = "INPUT" Then
    
    I = aSym.Max
    While I > 2
      If aType[I] = Highlight.Symbol Then Break
      Dec I
    Wend
    
    If I > 2 Then
      sName = aSym[I]
      sType = GetSymbolType(sName)
      If sType Then Return
  
      sType = "s"
    Endif
  
  Endif

  If sType Then
    $hEditor.Begin
    If Left(sName) = "$" Then
      AddGlobalVariable(sName, CSymbolInfo.GetType(sType))
    Else
      AddLocalVariable(sName, CSymbolInfo.GetType(sType))
    Endif
    $hEditor.End
    Return True
  Endif
  
End

Public Sub mnuBookmark_Show()
  
  $hBookmark.Update
  
End

Public Sub IsWordChar(sCar As String) As Boolean
  
  Return InStr(FEditor.IDENT_CAR, sCar) > 0
  
End

Public Sub Action_Activate((Key) As String) As Boolean
  
  Select Case Key
    
    Case ".locked"
      Project.SetReadOnly(Path, Action[Key, Me].Value)
      
    Case ".run-me"
      Project.Run(False, 0, Me.Name)
      
    Case ".wrap"
      $hEditor.Wrap = mnuWrap.Value
      If $hEditor1 Then
        $hEditor1.Wrap = $hEditor.Wrap
        $hEditor2.Wrap = $hEditor.Wrap
      Endif
    
    Case Else
      Return True
      
  End Select
  
End

Public Sub Form_Close()

  Project.AddRecentFile(Me)
  
End


Public Sub Form_Open()

  Action[".wrap", Me].Value = Settings["/Editor/WrapTextByDefault", False]

End
