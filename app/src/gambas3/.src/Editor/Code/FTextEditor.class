' Gambas class file

'
' Copyright (C) Benoît Minisini
'
' This program is free software; you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation; either version 2 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 51 Franklin St, Fifth Floor, 
' Boston, MA  02110-1301  USA
'

Static Public CompressMessage As String

Public Path As String
Public RichText As String
Private Editor As Editor
Public Age As Integer

Property Read ReadOnly As Boolean

Static Private $aExt As String[] = ["htm", "html", "xml", "kml", "svg", "css", "webpage", "js", "c", "h", "cpp", "gbs"]

Private $bNoHighlight As Boolean
Private $bShowCompress As Boolean
Private $bModule As Boolean

Private $bModify As Boolean

Private $iViewMode As Integer
Private Const VIEWMODE_NORMAL As Integer = 0 
Private Const VIEWMODE_HORIZONTAL As Integer = 1
Private Const VIEWMODE_VERTICAL As Integer = 2

Private $hEditor1 As Editor
Private $hEditor2 As Editor
Private $hInsertColor As CInsertColor
Private $hBookmark As CBookmark
Private $hCompletion As CCompletion

Private $cProc As Collection
Private $aProc As String[]

Private $bWebPage As Boolean
Private $iLastLine As Integer

Public Sub _new(sPath As String, Optional bModule As Boolean)

  $iLastLine = -1

  Path = sPath
  Editor = edtEditor
  
  If bModule Then
    mnuShowCode.Show
    Me.Name = File.BaseName(Path)
  Else
    mnuShowCode.Hide
    Me.Name = File.Name(Path)
  Endif
  
  $bModule = bModule
  
  'edtEditor.Flags[Editor.ShowCursorPosition] = True
  
End

Public Sub GetEditor() As Editor
  
  Return Editor
  
End


Public Sub LoadFile() As Boolean
  
  Dim sExt As String = LCase(File.Ext(Path))
  
  With edtEditor
    .Clear
    .Flags[Editor.HighlightBraces] = True
  End With
  
  $bWebPage = False
  
  If $aExt.Exist(sExt) Then

    Select Case sExt
      Case "css"
        edtEditor.Highlight = Highlight.CSS
      Case "webpage"
        edtEditor.Highlight = Highlight.WebPage
        $bWebPage = True
      Case "js"
        edtEditor.Highlight = Highlight.JavaScript
      Case "c"
        edtEditor.Highlight = Highlight.C
      Case "cpp", "h"
        edtEditor.Highlight = Highlight.CPlusPlus
      Case "gbs"
        edtEditor.Highlight = Highlight.Gambas
      Case Else 
        edtEditor.Highlight = Highlight.HTML
    End Select
    
    $bShowCompress = MCompressFile.CanCompress(Path) And Not Project.IsHiddenPath(Path)
    
    $bNoHighlight = False
  Else
    $bNoHighlight = True
  Endif

  $hInsertColor = New CInsertColor(Me, btnInsertColor)
  $hBookmark = New CBookmark(Me, btnBookmark, mnuBookmark)
  $hCompletion = New CCompletion(Me)

  ReadConfig

  Reload

  $bModify = False
  edtEditor.SetFocus

  SetReadOnly
  
End

Public Sub Form_Arrange()
  
  Dim iToolbarOffset As Integer
  
  'If we add the ability to hide the toolbar then uncomment this code 
  'IF $bToolbar THEN
  '  panToolBar.Move(0, 0, ME.CLientW)
  '  iToolbarOffset = panToolBar.H
  'ELSE
  '  iToolbarOffset = 0
  'ENDIF
  
  iToolbarOffset = panToolBar.H
  
  Select Case $iViewMode
    Case 0
      edtEditor.Move(0, iToolbarOffset, Me.ClientW, Me.ClientH - iToolbarOffset)
    Case 1
      splHorizontal.Move(0, iToolbarOffset, Me.ClientW, Me.ClientH - iToolbarOffset)
    Case 2
      splVertical.Move(0, iToolbarOffset, Me.ClientW, Me.ClientH - iToolbarOffset)
  End Select 

End

Public Sub ReadConfig()

  Project.SetSmallFont(panToolbar)
  edtEditor.ReadConfig
  If $hEditor1 Then $hEditor1.ReadConfig
  If $hEditor2 Then $hEditor2.ReadConfig
  $hCompletion.ReadConfig

End

Public Function Save() As Boolean

  'Project.Config.WriteString("/Window" &/ Name &/ "Pos",
  '  CStr(ME.X) & "," & CStr(ME.Y) & "," & CStr(ME.Width) & "," & CStr(ME.Height))

  If Not $bModify Then Return

  Save.Begin(Path)

  File.Save(Path, Editor.Text)
  Editor.Reset
  $bModify = False
  DrawTitle

  Save.End()

Catch

  Return Save.Error()

End

Private Sub DrawTitle()

  Project.DrawTitle(Me)

End

Public Sub Modify(Optional bReset As Boolean)

  If Project.ReadOnly Then Return
  
  If bReset Then
    
    If Not $bModify Then Return
    $bModify = False
    
  Else

    $bModify = True
    Inc Project.TimeStamp
    Inc Age
    FSearch.OnFileChange(Me.Path)
    
  Endif

  DrawTitle
  
End


Public Function IsModified() As Boolean

  Return $bModify

End


Public Sub Editors_Change()

  $cProc = Null
  Modify

End


Private Sub InAlternate() As Boolean

  Dim sText As String = String.Left(Editor.Lines[Editor.Line].Text, Editor.Column)
  Dim bAlt As Boolean
  Dim I As Integer
  Dim bQuote As Boolean
  Dim sCar As String
  
  Editor.Lines[Editor.Line].GetInitialState()
  bAlt = Highlight.AlternateState
  
  I = 1
  While I <= String.Len(sText)
    
    sCar = String.Mid$(sText, I, 1)
    
    If bAlt Then
      
      If bQuote Then
        If sCar = "\\" Then
          Inc I
        Else If sCar = Chr$(34) Then
          bQuote = False
        Endif
      Else
        If sCar = Chr$(34) Then
          bQuote = True
        Else If String.Mid$(sText, I, 2) = "%>" Then
          bAlt = False
        Endif
      Endif
      
    Else
      If String.Mid$(sText, I, 2) = "<%" Then
        bAlt = True
        Inc I
      Endif
    Endif
    
    Inc I
    
  Wend
  
  Return bAlt

End

Private Sub FindCloseAlternate() As Boolean
  
  Dim sLine As String
  Dim I, J, A, B As Integer
  
  I = Editor.Line 
  J = Editor.Column
  
  While I < Editor.Lines.Count
    sLine = Editor.Lines[I].Text
    A = String.InStr(sLine, "<%", J + 1)
    B = String.InStr(sLine, "%>", J + 1)
    If B > 0 And If A = 0 Or A > B Then Return True
    If A > 0 Then Return False
    Inc I
    J = 0
  Wend
    
End


Public Sub Editors_KeyPress()
  
  If $hCompletion.OnKeyPress() Then Return

  If Key.Code = Key.Escape Then 
    
    Action["find"].Value = False
  
  Else If Key.Code = Key.Insert Then

    If Key.Shift Then
      If Not Editor.ReadOnly Then
        Editor.Paste
      Endif 
    Else If Key.Control Then
      Editor.Copy
    Endif 
    
  Else If Key.Code = Key.Delete Then

    If Key.Shift Then
      If Not Editor.ReadOnly Then
        Editor.Cut
      Endif 
    Endif 
    
  Else If Key.Code = Key.Return Then 
      
    If Key.Control Then
      
      If Key.Shift Then 
        If Editor.Lines[Editor.Line].Expanded Then
          Editor.CollapseAll
        Else
          Editor.ExpandAll
        Endif
      Else
        Editor.Lines[Editor.Line].Expanded = Not Editor.Lines[Editor.Line].Expanded
      Endif
      Stop Event
      
    Endif
    
  ' Else If Key.Code = Key["L"] And If Key.Control Then
  '   
  '   FMain.SearchProject
  '   
  Endif 
  
  If Editor.ReadOnly Then Return
   
  If Key.Code = Key.Return Or If Key.Code = Key.Enter Then
    If Key.Normal Then
      If $bWebPage Then
        If InAlternate() And If Not FindCloseAlternate() Then
          Editor.Insert("\n%>")
          Editor.Goto(Editor.Line, 0)
          Stop Event
        Endif
      Endif
    Endif
  Endif
  
End



'PUBLIC SUB Form_KeyPress(Ascii AS String, Code AS Integer, State AS Integer)
'
'  IF Code = Asc("S") AND State = Mouse.Control THEN
'    ME.Save
'  ENDIF
'
'END



Public Sub Form_GotFocus()
  
  Editor.SetFocus
  
End

Public Sub Goto(iLine As Integer, Optional iColumn As Integer = -1)

  'DEC iLine
  If iColumn < 0 Then iColumn = Editor.Column
  Editor.Goto(iLine, iColumn, True)

End


Public Sub GotoCenter(iLine As Integer, Optional iColumn As Integer = -1)

  Goto(iLine, iColumn)

End


Public Sub Editors_Menu()

  mnuEditor.Popup

End

Private Sub RefreshBackground()

  Dim aEditor As Editor[] = [$hEditor1, $hEditor2]
  Dim hEditor As Editor
  Dim bHasFocus As Boolean

  If aEditor.Exist(Editor) Then

    For Each hEditor In aEditor
      If hEditor And If hEditor.HasFocus Then 
        bHasFocus = True
        Break
      Endif
    Next
  
    For Each hEditor In aEditor
  
      If Not hEditor Then Continue
  
      hEditor.ReadConfig
      If Not hEditor.HasFocus Then
        If bHasFocus Then MTheme.InitEditor(hEditor, True)
        hEditor.Flags[Editor.ShowCurrentLine] = False
        hEditor.Flags[Editor.ShowModifiedLines] = False
      Endif
  
    Next
    
  Endif

End

Public Sub Editors_GotFocus()

  Editor = Last
  Project.SetCurrentPopup(mnuEditor)
  RefreshBackground

End

Public Sub Editors_LostFocus()
  
  RefreshBackground
  
End

Public Sub mnuSave_Click()

  Save

End


' PUBLIC SUB mnuFind_Click()
'
'   DIM sSel AS String
'   DIM iPos AS Integer
'
'   sSel = Left$(Trim(edtEditor.Selection.Text), 64)
'   iPos = Instr(sSel, gb.NewLine)
'   IF iPos THEN sSel = Left$(sSel, iPos - 1)
'
'   Project.FindForm.Find(sSel)
'
' END
'
'
' PUBLIC SUB mnuFindNext_Click()
'
'   Project.FindForm.FindNext
'
' END
'
'
' PUBLIC SUB mnuFindPrevious_Click()
'
'   Project.FindForm.FindPrevious
'
' END


Public Sub Rename(sNewName As String, sNewPath As String)

  Me.Name = sNewName
  Path = sNewPath 'File.Dir(Path) &/ sNewName & "." & File.Ext(Path)
  DrawTitle

End


Public Sub mnuCut_Click()

  Editor.Cut

End

Public Sub mnuCopy_Click()

  Editor.Copy

End

Public Sub mnuPaste_Click()

  Editor.Paste
  Editor.SetFocus

End

Public Sub mnuUndo_Click()

  $hCompletion.Hide
  Editor.Undo

End

Public Sub mnuRedo_Click()

  $hCompletion.Hide
  Editor.Redo

End


Public Sub mnuGotoLine_Click()

  Dim iLine As Integer

  iLine = FGotoLine.Run(Editor.Line + 1)
  If iLine <= 0 Then Return
  GotoCenter(iLine - 1)

End


' PUBLIC SUB mnuWordWrap_Click()
'
'   edtEditor.Wrap = NOT edtEditor.Wrap
'   mnuWordWrap.Checked = edtEditor.Wrap
'
' END


Public Sub mnuSelectAll_Click()

  Editor.SelectAll()

End


Public Sub SetReadOnly()

  Dim bReadOnly As Boolean

  If Project.ReadOnly Or If Project.Running Or If Project.IsReadOnly(Path) Then
    bReadOnly = True
  Endif

  edtEditor.ReadOnly = bReadOnly
  If $hEditor1 Then $hEditor1.ReadOnly = bReadOnly
  If $hEditor2 Then $hEditor2.ReadOnly = bReadOnly

  Project.UpdateLockedAction(Me)

  UpdateMenu
  DrawTitle

End

Public Sub OnProjectDebug()

  SetReadOnly

End

Public Sub OnShowString(sStr As String, bIgnoreCase As Boolean)
  
  edtEditor.ShowString(sStr, bIgnoreCase)
  If $hEditor1 Then $hEditor1.ShowString(sStr, bIgnoreCase)
  If $hEditor2 Then $hEditor2.ShowString(sStr, bIgnoreCase)
  
End

' Private Sub AnalyzeCode(sText As String) As String
'   
'   Dim iInd As Integer
'   Dim iPos As Integer
'   Dim iLen As Integer
'   
'   If Not sText Then Return
'   
'   Highlight.Analyze(sText, True)
'   
'   iPos = 0
'   For iInd = 0 To Highlight.Symbols.Max
'     
'     If iPos < Highlight.Positions[iInd] Then 
'       Highlight.Add(Highlight.Normal, Highlight.Positions[iInd] - iPos)
'       iPos = Highlight.Positions[iInd]
'     Endif
'     
'     iLen = String.Len(Highlight.Symbols[iInd])
'     Highlight.Add(Highlight.Types[iInd], iLen)
'     iPos += iLen
'     
'   Next
' 
'   If iPos < String.Len(Highlight.TextAfter) Then 
'     Highlight.Add(Highlight.Normal, String.Len(Highlight.TextAfter) - iPos)
'   Endif
'   
'   Return Highlight.TextAfter
' 
' End


Public Sub Form_Activate()

  RefreshLineInfo(True)
  Project.SetCurrentPopup(mnuEditor)

End

Private Function ReadOnly_Read() As Boolean

  Return edtEditor.ReadOnly  

End

Private Sub UpdateEndOfLine()

  Select Case edtEditor.EndOfLine
    Case gb.Windows
      mnuEolWindows.Checked = True
      btnEndOfLine.Text = mnuEolWindows.Text
    Case gb.Mac
      mnuEolMac.Checked = True
      btnEndOfLine.Text = mnuEolMac.Text
    Default
      mnuEolUnix.Checked = True
      btnEndOfLine.Text = mnuEolUnix.Text
  End Select

End
  
Public Sub Reload()

  Dim sText As String
  sText = File.Load(Path)
  
  If $bNoHighlight Then
    If LTrim(sText) Like "<!DOCTYPE*" Or If LTrim(sText) Like "<html*" Then
      edtEditor.Highlight = Highlight.HTML
    Else
      edtEditor.Highlight = Highlight.None
    Endif
  Endif
  
  edtEditor.Text = sText
  
  UpdateEndOfLine
  
  Editor.SetFocus
  Editors_Cursor
  Modify(True)

End

Public Sub mnuReload_Click()

  If IsModified() Then
    If Message.Warning(("The file has been modified.\n\nAll your changes will be lost."), ("Reload"), ("Cancel")) <> 1 Then Return
  Endif

  Reload

End

Public Sub GetState() As String
  
  Return CStr(Editor.Line) & "." & CStr(Editor.Column)
  
End

Public Sub SetState(sState As String)
  
  Dim aState As String[] = Split(sState, ".")
  
  Editor.Goto(CInt(aState[0]), CInt(aState[1]))
  
End

Private Sub InitEditor(hEditor As Editor)
  
  With hEditor
    .Border = False
    .View = edtEditor
    .Highlight = edtEditor.Highlight
    '.Flags[Editor.HighlightImmediately] = edtEditor.Flags[Editor.HighlightImmediately]
    .Flags[Editor.HighlightBraces] = edtEditor.Flags[Editor.HighlightBraces]
    '.Flags[Editor.ShowCursorPosition] = edtEditor.Flags[Editor.ShowCursorPosition]
    .ReadOnly = edtEditor.ReadOnly
    .TabSize = edtEditor.TabSize
  End With 
  hEditor.ReadConfig
  
End

Private Sub SetViewMode(iViewMode As Integer)

  If $iViewMode = iViewMode Then iViewMode = VIEWMODE_NORMAL
  $iViewMode = iViewMode

  If $iViewMode <> VIEWMODE_NORMAL And If Not $hEditor1 Then
    $hEditor1 = New Editor(Me) As "Editors"
    InitEditor($hEditor1)
    $hEditor2 = New Editor(Me) As "Editors"
    InitEditor($hEditor2)
    FSearch.OnNewForm(Me)
  Endif

  Select Case $iViewMode

    Case VIEWMODE_NORMAL
      edtEditor.Show
      splHorizontal.Hide
      splVertical.Hide
      edtEditor.Goto(Editor.Line, Editor.Column, True)
      Editor = edtEditor

    Case VIEWMODE_HORIZONTAL
      $hEditor1.Reparent(splHorizontal)
      $hEditor2.Reparent(splHorizontal)
      edtEditor.Hide
      splHorizontal.Show
      splVertical.Hide
      $hEditor1.Goto(Editor.Line, Editor.Column, True)
      $hEditor2.Goto(Editor.Line, Editor.Column, True)
      Editor = $hEditor1

    Case VIEWMODE_VERTICAL
      $hEditor1.Reparent(splVertical)
      $hEditor2.Reparent(splVertical)
      edtEditor.Hide
      splHorizontal.Hide
      splVertical.Show
      $hEditor1.Goto(Editor.Line, Editor.Column, True)
      $hEditor2.Goto(Editor.Line, Editor.Column, True)
      Editor = $hEditor1

  End Select

  Editor.SetFocus
  Form_Arrange
  Editors_Cursor

End


Public Sub mnuNoSplit_Click()
  
  SetViewMode(VIEWMODE_NORMAL)

End

Public Sub mnuHorizontalSplit_Click()

  SetViewMode(VIEWMODE_HORIZONTAL)

End

Public Sub mnuVerticalSplit_Click()

  SetViewMode(VIEWMODE_VERTICAL)

End

Public Sub mnuShowCode_Click()

  Project.OpenFile(Me.Name)

End

Public Sub GetText() As String
  
  Return Editor.Text
  
End

Public Sub GetPosition() As Integer
  
  Return Editor.GetPosition()

End

Public Sub SetPosition(hResult As CFindResult, Optional bJustCheck As Boolean) As Boolean
  
  Return Editor.SetPosition(hResult, bJustCheck)
  
End

Public Sub Replace(sReplace As String)
  
  Editor.Replace(sReplace)
  
End

Public Sub GetSelection() As String
  
  Return Editor.GetSelection()
  
End

Public Sub mnuInsertColor_Click()

  $hInsertColor.Insert

End

Private Sub SetText(sText As String)
  
  Editor.Text = sText
  Me.Save
  UpdateCurrentProc
  'Editor.Begin
  'Editor.SelectAll
  'Editor.Insert(sText)
  'Editor.End
  
End

Private Sub GetUncompressPath() As String
  
  Return Project.Dir &/ ".hidden/Uncompressed" &/ Mid$(Path, Len(Project.Dir) + 1)
  
End

Public Sub Compress() As Boolean
  
  Dim sText As String
  Dim iLen As Integer
  Dim fGain As Float
  Dim sPath As String
  
  CompressMessage = ""
  
  If Project.IsHiddenPath(Path) Then Return
  
  Inc Application.Busy
  Me.Save
  sText = Editor.Text
  iLen = Len(sText)
  
  If iLen > 0 Then
  
    Select Case Editor.Highlight 
      Case Highlight.JavaScript
        sText = MCompressFile.Javascript(sText)
      Case Highlight.CSS
        sText = MCompressFile.Css(sText)
      Case Highlight.HTML
        sText = MCompressFile.Html(sText)
    End Select
    
    fGain = Len(sText) / iLen
    
  Else
    
    fGain = 1
    
  Endif
    
  Dec Application.Busy
  
  If fGain < 0.95 Then 'Or If (iLen - Len(sText)) >= 256 Then
    sPath = GetUncompressPath()
    If Not Exist(File.Dir(sPath)) Then Project.InsertDirectory(File.Dir(sPath))
    If Not Exist(sPath) Then 
      Project.InsertFile(File.Name(sPath), File.Dir(sPath), Path, True)
    Else
      File.Save(sPath, Editor.Text)
    Endif
    SetText(sText)
    CompressMessage = "<b>" & Subst(("The file has been compressed from &1 to &2 bytes (&3)."), Str(iLen), Str(Len(sText)), Format(fGain, "#.##%")) & "</b><p>" & ("Original file has been saved in the <b>Project</b> folder.")
  Endif
  
Catch
  
  Dec Application.Busy
  CompressMessage = "<b>" & ("Unable to compress file.") & "</b><p>" & Error.Text
  Return True
  
End


Public Sub mnuCompress_Click()

  If Compress() Then
    Message.Error(CompressMessage)
  Else
    If CompressMessage Then Message.Info(CompressMessage)
  Endif
  
End

Public Sub Uncompress()
  
  Dim sPath As String
  
  If Project.IsHiddenPath(Path) Then Return
  
  sPath = GetUncompressPath()
  If Not Exist(sPath) Then Return
  SetText(File.Load(sPath))
  
End


Public Sub mnuUncompress_Click()
  
  Uncompress
  
End

Private Sub RefreshLineInfo(Optional bForce As Boolean) As Boolean

  Dim bNewLine As Boolean

  If bForce Then
    $iLastLine = -1
  Endif

  If Editor.Line <> $iLastLine Then

    $iLastLine = Editor.Line

    UpdateCurrentProc
    bNewLine = True

  Endif

  lblInfo.Text = CStr(Editor.Column + 1) & " : " & CStr(Editor.Line + 1)
  Return bNewLine

End

Public Sub Editors_Cursor()

  If RefreshLineInfo() Then
    $hCompletion.Hide
  Endif
  
  CPosition.SaveCurrent(Me)

End

Public Sub Editors_MouseDown()
  
  CPosition.Disable
  
End

Public Sub Editors_MouseUp()
  
  CPosition.Enable
  CPosition.SaveCurrent(Me)
  
End



Public Sub mnuLowerCase_Click()
  
  If Editor.ReadOnly Then Return
  If Not Editor.Selected Then Return
  
  Editor.StoreSelection(True)
  Editor.Begin
  Editor.Insert(String.LCase(Editor.Selection.Text))
  Editor.End
  Editor.RecallSelection
  
End

Public Sub mnuUpperCase_Click()
  
  If Editor.ReadOnly Then Return
  If Not Editor.Selected Then Return
  
  Editor.StoreSelection(True)
  Editor.Begin
  Editor.Insert(String.UCase(Editor.Selection.Text))
  Editor.End
  Editor.RecallSelection
  
End

Public Sub ShowErrorMessage(sMsg As String, (sIcon) As String)

  Editor.SetFocus
  Wait
  Editor.ShowMessageLabel(sMsg, Editor.CursorX, Editor.CursorY + Editor.LineHeight, True)

End

' Private Sub RemoveFromBegin(sStr As String, sBegin As String) As String
'   
'   If sStr Begins sBegin Then
'     Return Mid$(sStr, Len(sBegin) + 1)
'   Else
'     Return sStr
'   Endif
'   
' End

Private Sub GetProc(sLine As String) As String

  Dim iPos As Integer
  Dim aStr As String[]
  Dim iInd As Integer
  Dim sStr As String
  Dim sProc As String

  sLine = Trim(sLine)

  Select Case Editor.Highlight
    
    Case Highlight.CSS
      
      iPos = InStr(sLine, "{")
      If iPos Then sProc = Trim(Left(sLine, iPos - 1))      
      
    Case Highlight.HTML, Highlight.WebPage
      
      If Left(sLine) = "<" Then
        iPos = InStr(sLine, " ")
        If iPos Then sProc = Left$(sLine, iPos - 1) & ">"
      Endif
      
    Case Highlight.JavaScript
      
      If sLine Begins "function " Then
        sLine = Mid$(sLine, 10)
        iPos = InStr(sLine, "(")
        If iPos Then
          sProc = Trim(Left$(sLine, iPos - 1))
        Endif
      Endif
      
    Case Highlight.C, Highlight.CPlusPlus
      
      aStr = Split(sLine & " (", " ")
      For iInd = 0 To aStr.Max
        sStr = aStr[iInd]
        iPos = InStr(sStr, "(") 
        If iPos > 0 Then
          sProc = Trim(Left$(sStr, iPos - 1))
          If Not sProc And If iInd > 0 Then sProc = aStr[iInd - 1]
          Break
        Endif
      Next
      
  End Select 

  Return Trim(sProc)

End

Private Sub GetCurrentProc(Optional iLine As Integer = Editor.Line) As String
  
  Dim sProc As String
  
  While iLine >= 0
    
    If Editor.Lines[iLine].Limit Then 
      sProc = GetProc(Editor.Lines[iLine].Text)  
      Break
    Endif
    Dec iLine
    
  Wend
  
  If Not sProc Then sProc = ("(Declarations)")
  Return sProc
  
End

Public Sub GetProcAt(iLine As Integer) As String

  Return GetCurrentProc(iLine)

End

Private Sub UpdateCurrentProc()

  btnProc.Text = GetCurrentProc()

End

Private Sub FillProc()

  Dim iLine As Integer
  Dim sText As String
  Dim sProc, sProcNum As String
  Dim iNum As String
  Dim bDecl As Boolean

  If $cProc Then Return

  Inc Application.Busy

  'fTime = Timer
  'FOR iInd = 1 TO 20
  'aFunc.Clear

  sText = btnProc.Text
  
  'cmbProc.Clear

  $cProc = New Collection(gb.IgnoreCase)
  $aProc = New String[]
  iLine = -1
  bDecl = True
  Do
    iLine = Editor.FindNextLimit(iLine)
    If iLine < 0 Then Break
    sProc = GetProc(Editor.Lines[iLine].Text)
    If Not sProc Then Continue
    If $cProc.Exist(sProc) Then
      iNum = 2
      Do
        sProcNum = sProc & " (" & iNum & ")"
        If Not $cProc.Exist(sProcNum) Then
          sProc = sProcNum
          Break
        Endif
        Inc iNum
      Loop
    Endif
    $aProc.Add(sProc)
    $cProc[sProc] = iLine
    If iLine = 0 Then bDecl = False
  Loop

  $aProc.Sort(gb.IgnoreCase)

  If bDecl Then $aProc.Add(("(Declarations)"), 0)
  '$cProc[0] = 0

  Dec Application.Busy

End

Public Sub btnProc_MouseDown()

  If Not Mouse.Left Then Return
  ToggleProcList
  Stop Event

End

Private Sub ToggleProcList()

  Dim iCurrent As Integer
  Dim iLine As Integer

  FillProc
  iCurrent = $aProc.Find(btnProc.Text)

  iCurrent = FProcedureList.Popup(Null, "", $aProc, iCurrent, btnProc.ScreenX, btnProc.ScreenY + btnProc.H, Desktop.Scale * 48, Me.ClientH - panToolbar.H - Desktop.Scale)
  If iCurrent >= 0 Then
    Try iLine = $cProc[$aProc[iCurrent]]
    GotoProc(iLine)
  Endif

End

Private Sub GotoProc(iLine As Integer)
  
  Editor.Goto(iLine, 0, True)
  
End

Public Sub panToolBar_Configure()

  UpdateMenu

  If $bModule Then
    btnShowCode.Show
    mnuShowCode.Show
  Else
    btnShowCode.Hide
    mnuShowCode.Hide
  Endif

End

Public Sub mnuClose_Click()

  Me.Close

End

Private Sub UpdateMenu()

  Dim bVisible As Boolean

  bVisible = Not edtEditor.ReadOnly

  Action[".save,.undo,.redo,.cut,.paste,.color,.indent,.unindent,.lcase,.ucase,.sort-ascent,.sort-descent,.eol", Me].Visible = bVisible
  mnuAdvanced.Visible = bVisible
  mnuEndOfLine.Visible = bVisible

  Action[".compress,.uncompress", Me].Visible = $bShowCompress And bVisible
  Action[".proc", Me].Visible = Not $bNoHighlight

End

Public Sub Form_Open()

  ReadConfig
  SetReadOnly

End

Public Sub btnIndent_Click()

  Editor.Indent

End

Public Sub btnUnindent_Click()

  Editor.Unindent

End

Public Sub Form_Hide()

  Try $hCompletion.Hide

End

Public Sub Editors_Scroll()

  $hCompletion.Hide

End

Private Sub GetRightString(sLine As String) As String

  Dim I, iPos As Integer
  Dim sCar As String
  Dim bInside As Boolean
  
  For I = 1 To Len(sLine)
    sCar = Mid$(sLine, I, 1)
    If bInside Then
      If sCar = "\\" Then
        Inc I
      Else If sCar = Chr$(34) Then
        bInside = False
      Endif
    Else If sCar = Chr$(34) Then
      bInside = True
      iPos = I
    Endif
  Next
  
  If bInside Then Return Mid$(sLine, iPos + 1)
  
End

Public Sub IsWordChar(sCar As String) As Boolean
  
  Return InStr("&~\"#'{([|`\\^@)]°=+}€$£%*!§:/;.,?<>¢«»¥·©®¬¿×·÷¡øø \t", sCar) = 0
  
End

Public Sub CheckCompletion(sMode As String)

  Dim sLine As String
  Dim sWord As String

  sLine = String.Left$(Editor.Lines[Editor.Line].Text, Editor.Column)
  '"If Right$(RTrim(sLine)) = "'" Then Return

  ' If sMode = " " Then
  '   
  '   If GetRightString(sLine) Then Return
  '   
  '   If UCase(Right$(sLine, 3)) = " AS" Or If UCase(Right$(sLine, 4)) = " NEW" Or If UCase(Right$(sLine, 3)) = " IS" Or If UCase(sLine) = "INHERITS" Then
  '     $hCompletion.Hide
  '     FCompletion.Open(Me, sMode)
  '   Endif
  '   
  ' Else If sMode = "." Then
  '   
  '   If GetRightString(sLine) Then Return
  '   
  '   Highlight.Analyze(sLine & ".")
  '   aSymbols = Highlight.Symbols
  '   aTypes = Highlight.Types
  '   aSymbols.Remove(aSymbols.Count - 1)
  '   aTypes.Remove(aTypes.Count - 1)
  '   sType = GetExpressionType(aSymbols, aTypes, True)
  '   If sType Then
  '     'PRINT "Type: "; sType
  '     FCompletion.Open(Me, sMode, sType, $bLastStatic, False) 'LCase(sType) = LCase(ME.Name))
  '   Endif
  '   
  If sMode = "A" Then
    
    If GetRightString(sLine) Then Return
    
    If Not FCompletion.VisibleFrom(Editor) Then
      sWord = $hCompletion.GetWord(sLine & Key.Text, Editor.Column + 1)
      If String.Len(sWord) >= 3 Then FCompletion.Open(Me, sMode, sWord)
      'IF Len(sWord) >= 3 THEN DEBUG FindCompletion(sWord).Join(" ")
    Endif
    
  ' Else If sMode = "_" Then
  '   
  '   If Not FCompletion.VisibleFrom(Editor) Then
  '     sWord = GetIdentifier(sLine, Editor.Column)
  '     If Len(sWord) >= 3 Then
  '       FCompletion.Open(Me, "A", sWord & "_")
  '     Endif
  '     'IF Len(sWord) >= 3 THEN DEBUG FindCompletion(sWord).Join(" ")
  '   Endif
  '   
  Else If sMode = "<" Then
    
    If Not Editor.Selected And If Editor.Column >= 1 And If Not FCompletion.VisibleFrom(Editor) Then
      
      sLine = String.Left(sLine, -1)
      sWord = GetRightString(sLine)
      
      If sWord Then
        
        If FCompletion.IsPath(sWord) Then
          FCompletion.Open(Me, "/", sWord)
          Return
        Endif
        
      Else
        
        '$bCheckSignature = True
        
        sWord = $hCompletion.GetWord(sLine, Editor.Column - 1)
        ' If Right(sLine) <> "." And If Len(sLine) > Len(sWord) And If Mid$(sLine, Len(sLine) - Len(sWord), 1) = "." Then
        '   iPos = Editor.Column
        '   Editor.Goto(Editor.Line, Editor.Column - String.Len(sWord) - 2)
        '   CheckCompletion(".")
        '   FCompletion.SetText(sWord)
        '   Editor.Goto(Editor.Line, iPos)
        '   Return
        ' Endif
        
        If Len(sWord) >= 3 Then 
          FCompletion.Open(Me, sMode, sWord)
          Return
        Endif
        
      Endif
      
      $hCompletion.Hide
        
    Endif
    
  Else If sMode = "/" Then
    
    sWord = GetRightString(sLine & "/")
    If sWord Then FCompletion.Open(Me, "/", sWord)
    
  Else
    
    $hCompletion.Hide
    
  Endif

End

Public Sub GetKeywords() As String[]
  
  Return Highlight._GetKeywords(Editor.Highlight)
  
End

Public Sub Delete()

  $hBookmark = Null
  $hCompletion = Null
  $hInsertColor = Null
  Super.Delete

End

Private Sub SortText(bDescent As Boolean)

  Dim aText As String[]
  Dim aPos As Integer[]
  Dim aVoid As String[]
  Dim iMode As Integer
  Dim I As Integer
  
  If Editor.ReadOnly Then Return
  If Not Editor.Selected Then Return
  
  Editor.StoreSelection
  Editor.Begin
  
  aText = Split(Editor.Selection.Text, "\n")
  
  aPos = New Integer[]
  aVoid = New String[]
  For I = aText.Max DownTo 0
    If Not Trim(aText[I]) Then 
      aPos.Add(I)
      aVoid.Add(aText[I])
      aText.Remove(I)
    Endif
  Next
  
  iMode = gb.Natural
  If bDescent Then iMode += gb.Descent
  aText.Sort(iMode)
  
  For I = 0 To aVoid.Max
    aText.Add(aVoid[I], aPos[I])
  Next
  
  Editor.Insert(aText.Join("\n"))
  Editor.End
  Editor.RecallSelection
  
End

Public Sub mnuSortAscent_Click()
  
  SortText(False)
  
End

Public Sub mnuSortDescent_Click()
  
  SortText(True)
  
End

Public Sub Action_Activate((Key) As String) As Boolean
  
  Select Case Key
    Case ".locked"
      Project.SetReadOnly(Path, Action[Key, Me].Value)
    Case Else
      Return True
  End Select
  
End

Public Sub Form_Close()

  Project.AddRecentFile(Me)

End

Public Sub mnuEolUnix_Click()
  
  edtEditor.EndOfLine = gb.Unix
  UpdateEndOfLine
  Modify
  
End

Public Sub mnuEolWindows_Click()
  
  edtEditor.EndOfLine = gb.Windows
  UpdateEndOfLine
  Modify
  
End

Public Sub mnuEolMac_Click()
  
  edtEditor.EndOfLine = gb.Mac
  UpdateEndOfLine
  Modify
  
End
