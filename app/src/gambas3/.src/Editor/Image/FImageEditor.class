' Gambas class file

Public Path As String
Public RichText As String

Public Enum EFFECT_BALANCE, EFFECT_COLORIZE, EFFECT_DESATURATE, EFFECT_TRANSPARENT
Private Enum TRANS_FLIP_H, TRANS_FLIP_V, TRANS_ROTATE_L, TRANS_ROTATE_R

Property Read ReadOnly As Boolean

Private $bReadOnly As Boolean
Private $hImage As Image
Private $bModify As Boolean

Private $iMouse As Integer
Private $hCursor As Cursor

Private $bFirstTime As Boolean

Private $aUndo As New Variant[]
Private $aRedo As New Variant[]
Private Enum BEGIN_UNDO, END_UNDO

Private $sTool As String
Private $sToolBefore As String
Private $hFirstPoint As PointF
Private $hLastPoint As PointF
Private $hCurrentPoint As PointF

Private $bDblClick As Boolean
Private $bPress As Boolean
Private $bShift As Boolean
Private $bCtrl As Boolean
Private $bAlt As Boolean
Private $bNormal As Boolean = True

Private $bFrame As Boolean
Private $fDashOffset As Float

Private $SX As Integer
Private $SY As Integer

Private $hStrokeImage As Image
'Private $aStroke As New PointF[]
Private $hStrokeExtents As Rect
'Private $hStrokeOrigin As Point

Private $hSelect As CImageSelection
Static Private $hNullSelection As CImageSelection
Private $fLastSelectW As Float
Private $fLastSelectH As Float

Private $hLastMagnet As PointF
Private $hMagnet As PointF
Private $sMagnet As String

Private $iClipboard As Integer

Private $hPaste As Image
Private $hPasteCurrent As CImageSelection
Private $hPasteSelect As CImageSelection

'Private $iAngle As Integer

Private $hChangeRect As RectF
Private $iChangeAction As Integer
Private $vChangeIndex As Variant
Private Enum CHANGE_NOTHING, CHANGE_MOVE, CHANGE_RESIZE, CHANGE_ROTATE, CHANGE_POINT, CHANGE_INSERT, CHANGE_SELECT

Private $bShowGrid As Boolean
Private $hTextSelect As CImageSelection

Private $sLastColor As Integer
Private $cInfo As New Collection
Private $bInfoTop As Boolean

Public Sub _new(sPath As String)
  
  Me.Name = File.Name(sPath)
  Path = sPath
  
  dwgBackground.Lower
  
  Project.InitTooltip(dwgInfo)
  
  'Reload
  
  SetTool("move")
  
End


Private Function ReadOnly_Read() As Boolean

  Return $bReadOnly

End

Private Sub ClearSelection()

  If Not $hSelect Then Return
  
  AddUndo($hSelect.Copy())
  $hSelect = Null
  $hChangeRect = Null
  $hMagnet = Null
  $hLastMagnet = Null
  $sMagnet = ""
  $iChangeAction = CHANGE_NOTHING
  RefreshSelection

End

Private Sub CreateSelection()
  
  If $hSelect Then Return
  $hSelect = New CImageSelection
  RefreshSelection
  
End


Public Sub Reload()
  
  $hImage = Image.Load(Path)
  imvImage.Image = $hImage
  ClearSelection
  $aUndo.Clear
  $aRedo.Clear
  btnZoomFit_Click
  SetReadOnly
  panBackground_Arrange  
  Modify(True)
  
End

Public Sub LoadFile() As Boolean
  
  Reload
  
End

Public Sub btnZoomIn_Click()

  If cmbZoom.Index = 0 Then Return
  Try Dec cmbZoom.Index

End

Public Sub btnZoomOut_Click()

  Try Inc cmbZoom.Index

End

Public Sub cmbZoom_Click()

  imvImage.Zoom = CFloat(Trim(String.Left(cmbZoom.Text, -1)))
  imvImage.Grid = imvImage.Zoom > 8
  panBackground_Arrange
  $hCurrentPoint = FindBestMagnet(GetImagePos())
  UpdateInfo
  
End

Public Sub IsModified() As Boolean
  
  Return $bModify
  
End

Public Sub dwgBackground_Draw()

  Dim hTopLeft As Point
  Dim hBottomRight As Point

  Project.DrawBackground()
  
  hTopLeft = imvImage.ImageToView(Point(0, 0))
  If Not hTopLeft Then Return
  hBottomRight = imvImage.ImageToView(Point(imvImage.Image.W, imvImage.Image.H))

  Paint.Background = Color.SetAlpha(Color.Black, 192)
  Paint.Rectangle(hTopLeft.X - 2, hTopLeft.Y - 2, hBottomRight.X - hTopLeft.X + 4, 2)
  Paint.Rectangle(hTopLeft.X - 2, hBottomRight.Y, hBottomRight.X - hTopLeft.X + 4, 2)
  Paint.Rectangle(hTopLeft.X - 2, hTopLeft.Y, 2, hBottomRight.Y - hTopLeft.Y)
  Paint.Rectangle(hBottomRight.X, hTopLeft.Y, 2, hBottomRight.Y - hTopLeft.Y)
  Paint.Fill

End

Public Sub Form_Open()

  ReadConfig
  SetReadOnly

End

Public Sub SetReadOnly()

  Dim bReadOnly As Boolean

  If Project.ReadOnly Or If Project.Running Or If Project.IsReadOnly(Path) Then
    bReadOnly = True
  Endif

  $bReadOnly = bReadOnly
  
  Project.UpdateLockedAction(Me)
  
  UpdateMenu
  DrawTitle
  
  FImageProperty.OnProjectActivate

End

Private Sub DrawTitle()

  Project.DrawTitle(Me)

End

Public Sub btnZoomNormal_Click()

  cmbZoom.Index = cmbZoom.Find("1Ã—")

End

Public Sub Modify(Optional bReset As Boolean)

  If Project.ReadOnly Or $bReadOnly Then Return
  If $bModify <> bReset Then Return

  $bModify = Not bReset
  DrawTitle
  Inc Project.TimeStamp

End

Private Sub SetImage(hImage As Image)
  
  AddUndo($hImage)
  $hImage = hImage
  
  imvImage.Update($hImage)
  Modify
  imvImage.SetFocus
  UpdateInfo
  
End

Private Sub AddUndo(hObject As Object)
  
  If Not hObject Then Return
  If $aUndo.Count = 256 Then $aUndo.Remove(0)
  
  $aUndo.Add(hObject)
  $aRedo.Clear
  
End

Private Sub ApplyTransformation(iTrans As Integer)
  
  Dim hImage As Image
  
  If $hChangeRect Then
  
    If $hSelect Then

      AddUndo($hSelect.Copy())
      
      Select Case iTrans
        Case TRANS_FLIP_H
          $hSelect.HFlip()
        Case TRANS_FLIP_V
          $hSelect.VFlip()
        Case TRANS_ROTATE_L
          $hSelect.Rotate(Rad(90))
        Case TRANS_ROTATE_R
          $hSelect.Rotate(Rad(-90))
      End Select
      
      RefreshSelection
    
    Endif
      
    If $hPaste Then
      
      Select Case iTrans
        Case TRANS_FLIP_H
          $hPaste.Mirror(True, False)
          '$hPasteCurrent.HFlip
          '$hPasteSelect.HFlip
        Case TRANS_FLIP_V
          $hPaste.Mirror(False, True)
          '$hPasteCurrent.VFlip
          '$hPasteSelect.VFlip
        Case TRANS_ROTATE_L
          '$hPaste.RotateLeft()
          'Swap $hChangeRect.W, $hChangeRect.H
          $hPasteCurrent.Rotate(Rad(90))
          '$hPasteSelect.Rotate(Rad(90))
        Case TRANS_ROTATE_R
          '$hPaste.RotateRight()
          'Swap $hChangeRect.W, $hChangeRect.H
          $hPasteCurrent.Rotate(Rad(-90))
          '$hPasteSelect.Rotate(Rad(-90))
      End Select
      
      UpdatePasteCurrent
     
    Endif
    
    imvImage.Refresh
      
    Return
    
  Endif

  BeginUndo
  ClearSelection
  
  hImage = $hImage.Copy()
  
  Select Case iTrans
    Case TRANS_FLIP_H
      hImage.Mirror(True, False)
    Case TRANS_FLIP_V
      hImage.Mirror(False, True)
    Case TRANS_ROTATE_L
      hImage.RotateLeft()
    Case TRANS_ROTATE_R
      hImage.RotateRight()
  End Select
  
  SetImage(hImage)
  EndUndo
  
End


Public Sub btnRotateL_Click()

  ApplyTransformation(TRANS_ROTATE_L)

End

Public Sub btnRotateR_Click()

  ApplyTransformation(TRANS_ROTATE_R)

End

Public Sub btnFlipH_Click()

  ApplyTransformation(TRANS_FLIP_H)

End

Public Sub btnFlipV_Click()

  ApplyTransformation(TRANS_FLIP_V)

End


Public Function Save(Optional bForce As Boolean) As Boolean

  If Project.ReadOnly Then Return
  If $bReadOnly Then Return
  If Not $bModify And If Not bForce Then Return

  'PRINT "Picture not saved"

  'HideSelection

  Save.Begin(Path)

  $hImage.Save(Path)
  MCompressFile.Compress(Path)

  'Project.RefreshKey(Path)

  $bModify = False
  DrawTitle
  Save.End()

Catch

  Return Save.Error()

End

Public Sub btnSave_Click()

  Me.Save

End

Public Sub btnReload_Click()

  Project.ReloadFile(Me)

End

Public Sub btnResize_Click()

  Dim X, Y, W, H As Integer
  Dim hImage As Image

  FImageResize.ImageWidth = $hImage.Width
  FImageResize.ImageHeight = $hImage.Height
  
  If FImageResize.Run() Then Return
  
  W = FImageResize.ImageWidth
  H = FImageResize.ImageHeight
  
  If W = $hImage.W And If H = $hImage.H Then Return
  
  If FImageResize.Stretch Then
    SetImage($hImage.Stretch(W, H))
  Else
    hImage = New Image(W, H, Color.Transparent)
    If FImageResize.CenterH Then X = (W - $hImage.W) \ 2
    If FImageResize.CenterV Then Y = (H - $hImage.H) \ 2
    hImage.DrawImage($hImage, X, Y)
    SetImage(hImage)
  Endif

End

Public Sub Rename(sNewName As String, sNewPath As String)

  Me.Name = sNewName
  Path = sNewPath 
  DrawTitle

End

Private Sub SetTool(sAction As String)

  Dim hCtrl As ToolButton
  Dim hImage As Image
  
  If Not sAction Then Return
  
  'If $sTool = sAction Then Return

  For Each hCtrl In [btnMove, btnDraw, btnErase, btnRectangle, btnEllipse, btnLine, btnMagic, btnPaste, btnEditSelection, btnText]
    Object.Lock(hCtrl)
    hCtrl.Value = hCtrl.Tag = sAction
    Object.Unlock(hCtrl)
  Next
  
  If $sTool = "paste" Then
    If sAction = "paste" Then DoPaste
    ClearPaste
  Endif
  
  If $hSelect Then $hSelect.SelectAll()
  $hChangeRect = Null
  $iChangeAction = CHANGE_NOTHING

  $iMouse = Mouse.Arrow
  $hCursor = Null

  Select Case sAction
    
    Case "move"
      $iMouse = Mouse.SizeAll
    
    Case "draw", "erase", "rectangle", "ellipse"
      '$iMouse = Mouse.Cross
      $iMouse = Mouse.Custom
      $hCursor = New Cursor(Picture["img/32/cross.png"], 15, 15)
    
    Case "line"
      $hLastPoint = Null
    
    Case "magic"
      $iMouse = Mouse.Custom
      $hCursor = New Cursor(Picture["img/32/magic.png"], 11, 11)
      
    Case "paste"
      If $sTool <> "paste" Then $sToolBefore = $sTool
      hImage = FImageProperty.GetClipboard()
      If hImage Then 
  
        $hPaste = hImage
        
        $hPasteCurrent = New CImageSelection
        $hPasteCurrent.Rectangle(0, 0, $hPaste.W, $hPaste.H)
        $hPasteCurrent.Translate(($hImage.W - $hPaste.W) \ 2, ($hImage.H - $hPaste.H) \ 2)
        
        UpdatePasteCurrent
        
      Endif
      
    Case "change"
      If $sTool <> "paste" Then $sToolBefore = $sTool
      If HasSelection() Then
        $hChangeRect = $hSelect.GetExtents()
      Endif
      
    Case "text"
      '$iMouse = Mouse.Cross
      $iMouse = Mouse.Custom
      $hCursor = New Cursor(Picture["img/32/cross.png"], 15, 15)
      CreateSelection
      $hTextSelect = $hSelect.Copy()
      $hLastPoint = imvImage.ViewToImage(Point(imvImage.ScrollX + imvImage.ClientW / 2, imvImage.ScrollY + imvImage.ClientH / 2))
      FImageProperty.ShowTextOption(True, True)

  End Select
  
  $sTool = sAction
  
  FImageProperty.OnToolChange($sTool)
  
  imvImage.Refresh
  
End

Public Sub btnTool_Click()

  SetTool(Last.Tag)

End

Public Sub imvImage_Scroll()
  
  If Not $bPress Then imvImage_MouseMove
  
End

Private Sub Undo()

  Dim vUndo As Variant
  Dim iLevel As Integer

  If $aUndo.Count = 0 Then Return
  
  Repeat
  
    vUndo = $aUndo.Pop()
    
    If TypeOf(vUndo) = gb.Integer Then
      $aRedo.Add(vUndo)
      If vUndo = END_UNDO Then
        Inc iLevel
      Else If vUndo = BEGIN_UNDO Then
        Dec iLevel
      Endif
    Else If vUndo Is Image Then
      $aRedo.Add($hImage)
      $hImage = vUndo
      imvImage.Update($hImage)
      Modify
    Else If vUndo Is CImageSelection Then
      If Not $hSelect Then
        If Not $hNullSelection Then $hNullSelection = New CImageSelection
        $aRedo.Add($hNullSelection)
      Else
        $aRedo.Add($hSelect)
      Endif
      $hSelect = vUndo
      imvImage.Refresh
    Else If vUndo Is PointF Then
      $aRedo.Add($hLastPoint)
      $hLastPoint = vUndo
    Endif
    
  Until iLevel = 0

  RefreshSelection
  UpdateInfo

End

Public Sub btnUndo_Click()

  Undo

End

Public Sub btnRedo_Click()

  Dim vUndo As Variant
  Dim iLevel As Integer

  If $aRedo.Count = 0 Then Return
  
  Repeat
    
    vUndo = $aRedo.Pop()
  
    If TypeOf(vUndo) = gb.Integer Then
      $aUndo.Add(vUndo)
      If vUndo = BEGIN_UNDO Then
        Inc iLevel
      Else If vUndo = END_UNDO Then
        Dec iLevel
      Endif
    Else If vUndo Is Image Then
      $aUndo.Add($hImage)
      $hImage = vUndo
      imvImage.Update($hImage)
      Modify
    Else If vUndo Is CImageSelection Then
      $aUndo.Add($hSelect)
      $hSelect = vUndo
      If $hSelect = $hNullSelection Then $hSelect = Null
      imvImage.Refresh
    Else If vUndo Is PointF Then
      $aUndo.Add($hLastPoint)
      $hLastPoint = vUndo
    Endif
    
  Until iLevel = 0

  RefreshSelection
  UpdateInfo
  
End

Private Sub GetPos() As Point
  
  Return Point(Mouse.ScreenX - imvImage.ScreenX, Mouse.ScreenY - imvImage.ScreenY)
  
End

Private Sub GetImagePos() As PointF
  
  Dim hPos As Point = GetPos()
  Dim hPoint As Point = imvImage.ViewToImage(hPos)
  Dim hOrg As Point = imvImage.ImageToView(Point(0, 0))
  Dim X As Float
  Dim Y As Float
  Dim iSnap As Integer

  X = (hPos.X - hOrg.X) / imvImage.Zoom
  Y = (hPos.Y - hOrg.Y) / imvImage.Zoom
  
  X = hPoint.X + X - Floor(X)
  Y = hPoint.Y + Y - Floor(Y)
  
  If $hMagnet Then
    If Abs($hMagnet - PointF(X, Y)) <= 8 / imvImage.Zoom Then Return $hMagnet
  Endif
    
  iSnap = FImageProperty.GetGridSnap()
  
  If $bShowGrid And If iSnap Then
  
    X = (CInt(Floor(X + iSnap \ 2)) \ iSnap) * iSnap
    Y = (CInt(Floor(Y + iSnap \ 2)) \ iSnap) * iSnap
    
  Else If $sTool = "paste" Then
    
    X = Floor(X)
    Y = Floor(Y)
  
  Else If $sTool = "draw" Or If $sTool = "erase" Then
    
    If FImageProperty.GetSize() Then
      X = Floor(X * 2) / 2
      Y = Floor(Y * 2) / 2
    Else
      X = Floor(X)
      Y = Floor(Y)
    Endif
    
  Else
    
    If $sTool = "line" And If $bShift Then
    Else
      X = Floor(X * 2) / 2
      Y = Floor(Y * 2) / 2
    Endif
  
  Endif
  
  Return PointF(X, Y)
  
End


Private Sub StartStroke()

  Dim iSize As Integer = FImageProperty.GetSize()

  $hStrokeImage = New Image($hImage.W, $hImage.H, Color.Transparent)

  Paint.Begin($hStrokeImage)

  FImageProperty.PaintForStroke(Null, True)
  
  If iSize = 0 Then
    $hLastPoint.X = CInt($hLastPoint.X)
    $hLastPoint.Y = CInt($hLastPoint.Y)
    Paint.Rectangle($hLastPoint.X, $hLastPoint.Y, 1, 1)
    $hStrokeExtents = Rect($hLastPoint.X, $hLastPoint.Y, 1, 1)
  Else
    Paint.Arc($hLastPoint.X, $hLastPoint.Y, iSize / 2)
    $hStrokeExtents = Rect($hLastPoint.X - iSize \ 2 - 2, $hLastPoint.Y - iSize \ 2 - 2, iSize * 2 + 2, iSize * 2 + 2)
  Endif
  
  Paint.Fill
  
  Paint.End
  
  imvImage.Refresh

End

Private Sub AddStroke(hPoint As PointF)

  Dim iSize As Integer = FImageProperty.GetSize()

  If iSize = 0 Then
    hPoint.X = CInt(hPoint.X)
    hPoint.Y = CInt(hPoint.Y)
    $hStrokeExtents = $hStrokeExtents.Union(Rect($hLastPoint.X - 1, $hLastPoint.Y - 1, 3, 3))
  Else
    $hStrokeExtents = $hStrokeExtents.Union(Rect($hLastPoint.X - iSize \ 2 - 2, $hLastPoint.Y - iSize \ 2 - 2, iSize * 2 + 2, iSize * 2 + 2))
  Endif
  
  $hStrokeExtents = $hStrokeExtents.Intersection(Rect(0, 0, $hImage.W, $hImage.H))
  If Not $hStrokeExtents Then $hStrokeExtents = New Rect

  If hPoint = $hLastPoint Then Return
  
  Paint.Begin($hStrokeImage)
 
  FImageProperty.PaintForStroke(Null, True)
  
  If Not Paint.AntiAlias Then Paint.Translate(0.499, 0.499)
  Paint.MoveTo($hLastPoint.X, $hLastPoint.Y)
  Paint.LineTo(hPoint.X, hPoint.Y)
  
  Paint.Stroke
  
  Paint.End
  
  $hLastPoint = hPoint
  
  imvImage.Refresh
  
End

' Public Sub timStroke_Timer()
' 
'   Dim iSize As Integer
'   
'   If $aStroke.Count = 0 Then Return
'   
'   iSize = Max(1, FImageProperty.GetSize())
' 
'   With $hStrokeExtents.Copy()
'     .Adjust(- iSize)
'     .Left = Max(0, .Left)
'     .Top = Max(0, .Top)
'     $hStrokeOrigin = Point(.X, .Y)
'     $hStrokeImage = $hImage.Copy(.X, .Y, .W, .H)
'     Paint.Begin($hStrokeImage)
'     Paint.Translate(- .X, - .Y)
'     DrawTool
'     Paint.End
'   End With
'   
'   imvImage.Refresh
'     
' End

Public Sub imvImage_MouseDown()

  Me.SetFocus
  $bPress = Mouse.Left
  
  If Not $bPress Then Return
  
  BeginUndo
  
  Select Case $sTool
    
    Case "move"
      
      $SX = imvImage.ScrollX
      $SY = imvImage.ScrollY
    
    Case "draw", "erase"
      
      If Not $bShift Then
        If Not $bCtrl Then 
          $hLastPoint = GetImagePos()
          If $hMagnet Then $hLastPoint = $hMagnet
        Endif
        
        StartStroke()
      Endif
      'AddStroke($hLastPoint)
      
    Case "line"
      
      CreateSelection
      
      BeginUndo
      AddUndo($hSelect.Copy())
      If $hLastPoint Then AddUndo($hLastPoint.Copy())
      EndUndo
      
      ' If Not $hCurrentPoint Then
      '   $hCurrentPoint = GetImagePos()
      '   If $hMagnet Then $hCurrentPoint = $hMagnet
      ' Endif
      
      FindCurrentPoint()
      
      If Not $bFrame Or If Not $hLastPoint Or If $hSelect.Count = 0 Then 
        $hSelect.MoveTo($hCurrentPoint.X, $hCurrentPoint.Y)
      Else
        $hSelect.LineTo($hCurrentPoint.X, $hCurrentPoint.Y)
        '$hSelect.AddMagnet(PointF(($hCurrentPoint.X + $hLastPoint.X) / 2, ($hCurrentPoint.Y + $hLastPoint.Y) / 2))
      Endif
      
      $hFirstPoint = $hCurrentPoint
      $hLastPoint = $hCurrentPoint
      imvImage.Refresh
      
    Case "rectangle", "ellipse"

      CreateSelection
      AddUndo($hSelect.Copy())
      
      $hLastPoint = GetImagePos()
      If $hMagnet Then $hLastPoint = $hMagnet
      
    Case "magic"
      
      CreateSelection
      AddUndo($hSelect.Copy())
      $hLastPoint = GetImagePos()
      MagicWand
      
    Case "paste"
      
      If $hPaste Then
        $hLastPoint = GetImagePos()
        'If $hMagnet Then $hLastPoint = $hMagnet
        '$hLastPoint = GetImagePos()
      Endif
      
    Case "change"
      
      If $iChangeAction = CHANGE_NOTHING Then
        
        $SX = imvImage.ScrollX
        $SY = imvImage.ScrollY
        
      Else
      
        AddUndo($hSelect.Copy())
        $hLastPoint = GetImagePos()
        If $hMagnet Then $hLastPoint = $hMagnet
        
        If $iChangeAction = CHANGE_INSERT Then
          $vChangeIndex = $hSelect.InsertPoint($hLastPoint, $vChangeIndex)
          AddUndo($hSelect.Copy()) ' Avoid automatic undo at MouseUp
          $iChangeAction = CHANGE_POINT
          RefreshSelection
        Else If $iChangeAction = CHANGE_SELECT Then
          If $vChangeIndex And If $vChangeIndex[0] = $hSelect.Current Then
            $hSelect.SelectNext(8 / imvImage.Zoom)
          Else
            $hSelect.Select($vChangeIndex[0])
          Endif
          RefreshSelection
        Endif
        
      Endif
    
  End Select
  
  imvImage_MouseMove()
  
End

Private Sub UpdateInfo()
  
  $cInfo.Clear

  If $hCurrentPoint Then
    If $hCurrentPoint.InRect(RectF(0, 0, $hImage.W, $hImage.H)) Or If $bPress Then
      If $sTool = "draw" Or $sTool = "erase" And If FImageProperty.GetSize() = 0 Then
        $cInfo!X = CStr(CInt($hCurrentPoint.X))
        $cInfo!Y = CStr(CInt($hCurrentPoint.Y))
      Else
        $cInfo!X = Format($hCurrentPoint.X, "0.0")
        $cInfo!Y = Format($hCurrentPoint.Y, "0.0")
      Endif
      If $bPress Then
        If $sTool = "rectangle" Or If $sTool = "ellipse" Then
          $cInfo!Width = Format($fLastSelectW, "0.0")
          $cInfo!Height = Format($fLastSelectH, "0.0")
        Endif
      Endif
      
      $cInfo!Color = $hImage[$hCurrentPoint.X, $hCurrentPoint.Y]
    Endif
  Endif
  
  If $cInfo.Count = 0 Then
    $cInfo!Width = $hImage.Width
    $cInfo!Height = $hImage.Height
    $cInfo!Size = Util.GetFileSize($hImage.Width * $hImage.Height * 4)
  Endif
  
  dwgInfo.Resize(dwgInfo.Font.TextWidth("99999") * 4 + Desktop.Scale * 4, dwgInfo.Font.Height * 2 + Desktop.Scale * 2)
  MoveInfo
  dwgInfo.Refresh
  
End


Private Sub GetRectLimits(hRect As RectF) As PointF[]
  
  With hRect
    Return [PointF(.X, .Y), PointF(.X + .W, .Y), PointF(.X, .Y + .H), PointF(.X + .W, .Y + .H)] ',PointF(.X + .W / 2, .Y + .H / 2)
  End With
  
End


Private Sub FindBestMagnetFor(hPoint As PointF, Optional iIgnoreFrom As Integer) As PointF

  Dim hMagnet As PointF

  If $hSelect Then 
    If $sTool = "change" Then
      If $iChangeAction = CHANGE_MOVE And If $hSelect.Current < 0 Then Goto NO_SELECT
      If $iChangeAction = CHANGE_RESIZE Or If $iChangeAction = CHANGE_ROTATE Then Goto NO_SELECT
    Endif
    hMagnet = $hSelect.FindMagnet(hPoint, 8 / imvImage.Zoom, iIgnoreFrom)
    If hMagnet Then Return hMagnet
  Endif

NO_SELECT:

  If $sTool <> "move" Then
    hMagnet = CImageSelection.FindMagnetFrom(GetRectLimits(RectF(0, 0, $hImage.W, $hImage.H)), hPoint, 8 / imvImage.Zoom)
    If hMagnet Then Return hMagnet
  Endif

  If $hChangeRect Then
    If $bPress And If $iChangeAction = CHANGE_POINT Then
      hMagnet = $hSelect.FindPoint(hPoint, 8 / imvImage.Zoom,, $vChangeIndex)
      If hMagnet Then Return hMagnet
    Endif
    hMagnet = CImageSelection.FindMagnetFrom(GetRectLimits($hChangeRect), hPoint, 8 / imvImage.Zoom, True)
    If hMagnet Then Return hMagnet
  Endif
  
  If $sTool = "line" And If $hSelect And If $hSelect.Shapes.Count Then
    hMagnet = CImageSelection.FindMagnetFrom($hSelect.Shapes[$hSelect.Shapes.Max].Magnets, hPoint, 8 / imvImage.Zoom)
    If hMagnet Then Return hMagnet
  Endif
    
End

Private Sub SetMagnet(hMagnet As PointF)

  If hMagnet <> $hMagnet Then
    ' A quoi sert $hLastMagnet?
    '$hLastMagnet = $hMagnet
    $hMagnet = hMagnet
    '$sMagnet = sName
    imvImage.Refresh
  Endif

End

Private Sub FindBestMagnet(hCurrent As PointF) As PointF

  Dim hMagnet As PointF
  Dim bCurrent As Boolean
  Dim hPoint As PointF
  Dim iIgnoreFrom As Integer
  
  If $sTool = "move" Then Return hCurrent
  If $sTool = "change" Or $sTool = "paste" And If Not $bPress Then Return hCurrent
  
  iIgnoreFrom = -1
  If $bPress Then
    If $sTool = "rectangle" Or If $sTool = "ellipse" Or If $sTool = "line" Then
      If $hSelect Then iIgnoreFrom = $hSelect.Count - 1
    Else If $sTool = "text" Then
      iIgnoreFrom = $hTextSelect.Count
    Endif
  Endif
  
  If $hMagnet And If hCurrent = $hMagnet Then Return hCurrent
  
  hMagnet = FindBestMagnetFor(hCurrent, iIgnoreFrom)
  If hMagnet Then
    bCurrent = True
    Goto FIND_MAGNET
  Endif
  
  If $bPress Then
    
    If $hChangeRect And If $iChangeAction <> CHANGE_NOTHING And If $iChangeAction <> CHANGE_POINT Then

      If $iChangeAction <> CHANGE_RESIZE And If $iChangeAction <> CHANGE_ROTATE Then

        'Print "~ "; hCurrent - $hCurrentPoint
        
        If $hSelect Then
          If $hSelect.Current >= 0 Then
            For Each hPoint In $hSelect.Shapes[$hSelect.Current].GetMagnets()
              hPoint += hCurrent - $hCurrentPoint
              hMagnet = FindBestMagnetFor(hPoint, iIgnoreFrom)
              If hMagnet Then Goto FIND_MAGNET
            Next
          Endif
          For Each hPoint In GetRectLimits($hSelect.GetExtents())
            hPoint += hCurrent - $hCurrentPoint
            hMagnet = FindBestMagnetFor(hPoint, iIgnoreFrom)
            If hMagnet Then Goto FIND_MAGNET
          Next
        Else If $hPasteSelect Then
          For Each hPoint In GetRectLimits($hPasteSelect.GetExtents())
            hPoint += hCurrent - $hCurrentPoint
            hMagnet = FindBestMagnetFor(hPoint, iIgnoreFrom)
            If hMagnet Then Goto FIND_MAGNET
          Next
        Endif
        
      Endif
    Endif
  
  Endif

FIND_MAGNET:

  SetMagnet(hMagnet)

  If hMagnet Then
   
    If bCurrent Then
      hCurrent = hMagnet
      $hLastMagnet = Null
      'Print "Current";; hCurrent
    Else
      'Print "Other";; hCurrent;; hMagnet - hPoint
      hCurrent = hCurrent + hMagnet - hPoint
    Endif
    
  Else If $hLastMagnet Then
      
    If hCurrent.X > ($hLastMagnet.X - 8 / imvImage.Zoom) And If hCurrent.X < ($hLastMagnet.X + 8 / imvImage.Zoom) Then
      hCurrent.X = $hLastMagnet.X
    Endif
    If hCurrent.Y > ($hLastMagnet.Y - 8 / imvImage.Zoom) And If hCurrent.Y < ($hLastMagnet.Y + 8 / imvImage.Zoom) Then
      hCurrent.Y = $hLastMagnet.Y
    Endif
      
  Endif
    
  Return hCurrent

End

Private Sub SetMouse(iMouse As Integer)

  If iMouse = Mouse.Custom Then
    imvImage.Cursor = $hCursor
  Endif
  imvImage.Mouse = iMouse

End

Private Sub FindCurrentPoint()

  Dim A As Float
  Dim D As Float
  
  $hCurrentPoint = FindBestMagnet(GetImagePos())
  
  If $bFrame Then
    If $bAlt Then
      If $hLastPoint Then
      
        A = Ang($hCurrentPoint.X - $hLastPoint.X, $hCurrentPoint.Y - $hLastPoint.Y)
        D = Mag($hCurrentPoint.X - $hLastPoint.X, $hCurrentPoint.Y - $hLastPoint.Y)
        If A < 0 Then A += Pi(2)
        A = Rad(Int(Deg(A) / 15 + 0.5) * 15)
        
        $hCurrentPoint = PointF(CInt(($hLastPoint.X + Cos(A) * D) * 2 + 0.5) / 2, CInt(($hLastPoint.Y + Sin(A) * D) * 2 + 0.5) / 2)
      
      Endif
    Endif
  Endif

  UpdateInfo
  
End

Public Sub imvImage_MouseMove()

  Dim hPos As Point = GetPos()
  Dim WW, HH As Float
  Dim iMouse As Integer
  Dim XC, YC As Float
  Dim A As Float
  Dim hSelect As CImageSelection
  Dim I As Integer
  Dim X1, X2, Y1, Y2 As Float
  
  If $bDblClick Then Return
  
  FindCurrentPoint
  
  If $bPress Then
    
    If $sTool <> "move" Then imvImage.EnsureVisible(imvImage.ScrollX + hPos.X - 32, imvImage.ScrollY + hPos.Y - 32, 64, 64)
    
    Select Case $sTool
      
      Case "move"
        
        imvImage.Scroll($SX - (Mouse.X - Mouse.StartX), $SY - (Mouse.Y - Mouse.StartY))
      
      Case "draw", "erase"
        
        If $bShift Then
          If $sTool = "draw" Then
            With GetImagePos()
              FImageProperty.SetColor($hImage[.X, .Y])
            End With
          Endif
        Else
          If $hLastPoint.X <> $hCurrentPoint.X Or If $hLastPoint.Y <> $hCurrentPoint.Y Then
            AddStroke($hCurrentPoint)
          Endif
        Endif
      
      Case "line"
        
        If $bFrame And If $bAlt Then
        Else
          $fLastSelectW = $hCurrentPoint.X - $hLastPoint.X
          $fLastSelectH = $hCurrentPoint.Y - $hLastPoint.Y
  
          If $hLastPoint.X <> $hCurrentPoint.X Or If $hLastPoint.Y <> $hCurrentPoint.Y Then
            $hSelect.LineTo($hCurrentPoint.X, $hCurrentPoint.Y)
            imvImage.Refresh
            $hLastPoint = $hCurrentPoint
          Endif
          
          If $hFirstPoint And If Hyp($hCurrentPoint.X - $hFirstPoint.X, $hCurrentPoint.Y - $hFirstPoint.Y) > 8 / imvImage.Zoom Then 
            $hSelect.AddMagnet($hFirstPoint)
            'Debug "add magnet ";; $hFirstPoint.X;; $hFirstPoint.Y
            $hFirstPoint = Null
          Endif
        Endif
        
      Case "rectangle", "ellipse"
        
        If $bCtrl Then $hCurrentPoint.Y = $hLastPoint.Y + Abs($hCurrentPoint.X - $hLastPoint.X) * Sgn($hCurrentPoint.Y - $hLastPoint.Y)
        If $hLastPoint.X <> $hCurrentPoint.X Or If $hLastPoint.Y <> $hCurrentPoint.Y Then
          $hSelect = $aUndo[$aUndo.Max].Copy()
          
          X1 = $hCurrentPoint.X
          Y1 = $hCurrentPoint.Y
          X2 = $hLastPoint.X
          Y2 = $hLastPoint.Y
          If X1 > X2 Then Swap X1, X2
          If Y1 > Y2 Then Swap Y1, Y2
          
          If X2 - X1 >= 0.25 And If Y2 - Y1 >= 0.25 Then 
            'X1 = Floor(X1)
            'X2 = Ceil(X2)
            'Y1 = Floor(Y1)
            'Y2 = Ceil(Y2)
            WW = X2 - X1
            HH = Y2 - Y1
          Else
            WW = 0
            HH = 0
          Endif
          
          If $sTool = "ellipse" Then
          
            If $bShift Then
              $hSelect.Ellipse($hLastPoint.X - WW, $hLastPoint.Y - HH, WW * 2, HH * 2)
              WW *= 2
              HH *= 2
            Else
              $hSelect.Ellipse(Min($hLastPoint.X, $hCurrentPoint.X), Min($hLastPoint.Y, $hCurrentPoint.Y), WW, HH)
            Endif
          
          Else
            
            If $bShift Then
              $hSelect.Rectangle(X1 - WW, Y1 - HH, WW * 2, HH * 2, FImageProperty.GetRoundness())
              WW *= 2
              HH *= 2
            Else
              $hSelect.Rectangle(X1, Y1, WW, HH, FImageProperty.GetRoundness())
            Endif
            
          Endif
            
          imvImage.Refresh
          $fLastSelectW = WW
          $fLastSelectH = HH
          UpdateInfo
          
        Endif
      
      Case "text"
        
        $hLastPoint = GetImagePos() '$hCurrentPoint
        FImageProperty.RefreshTextOption
      
      ' Case "ellipse"
      '   
      '   If $bCtrl Then $hCurrentPoint.Y = $hLastPoint.Y + Abs($hCurrentPoint.X - $hLastPoint.X) * Sgn($hCurrentPoint.Y - $hLastPoint.Y)
      '   If $hLastPoint.X <> $hCurrentPoint.X Or If $hLastPoint.Y <> $hCurrentPoint.Y Then
      '     $hSelect = $aUndo[$aUndo.Max].Copy()
      '     WW = Abs(CInt($hCurrentPoint.X) - CInt($hLastPoint.X)) '- ($hCurrentPoint.X > $hLastPoint.X)
      '     HH = Abs(CInt($hCurrentPoint.Y) - CInt($hLastPoint.Y)) '- ($hCurrentPoint.Y > $hLastPoint.Y)
      '     If $bShift Then
      '       WW *= Sqr(2)
      '       HH *= Sqr(2)
      '       $hSelect.Ellipse(CInt($hLastPoint.X) - WW, CInt($hLastPoint.Y) - HH, WW * 2, HH * 2)
      '     Else
      '       $hSelect.Ellipse(CInt(Min($hLastPoint.X, $hCurrentPoint.X)), CInt(Min($hLastPoint.Y, $hCurrentPoint.Y)), WW, HH)
      '     Endif
      '     imvImage.Refresh
      '     $fLastSelectW = WW
      '     $fLastSelectH = HH
      '   Endif
        
      Case "change", "paste"
        
        If $iChangeAction = CHANGE_NOTHING And If $sTool = "change" Then
            
          ' No mouse event data possible
          Try imvImage.Scroll($SX - (Mouse.X - Mouse.StartX), $SY - (Mouse.Y - Mouse.StartY))
          
        Else If $iChangeAction = CHANGE_POINT Then
          
          $hSelect.SetPoint($vChangeIndex, $hCurrentPoint)
          
        Else If $iChangeAction = CHANGE_SELECT Then
          
          If Hyp(Mouse.X - Mouse.StartX, Mouse.Y - Mouse.StartY) > 4 Then 
            $iChangeAction = CHANGE_MOVE
            AddUndo($hSelect.Copy())
            $hSelect.Translate($hCurrentPoint.X - $hLastPoint.X, $hCurrentPoint.Y - $hLastPoint.Y)
            '$hSelect = $aUndo[$aUndo.Max].Copy()
            '$hSelect.Translate($hCurrentPoint.X - $hLastPoint.X, $hCurrentPoint.Y - $hLastPoint.Y)
          Endif
          
        Else If $iChangeAction Then
        
          If $sTool = "change" Then
            $hSelect = $aUndo[$aUndo.Max].Copy()
            hSelect = $hSelect
          Else
            $hPasteSelect = $hPasteCurrent.Copy()
            hSelect = $hPasteSelect
          Endif
          
          Select Case $iChangeAction
            
            Case CHANGE_RESIZE
              
              If $bShift Then
                XC = $hChangeRect.X + $hChangeRect.W / 2
                YC = $hChangeRect.Y + $hChangeRect.H / 2
              Else
                XC = $hChangeRect.X
                YC = $hChangeRect.Y
              Endif
              
              If $bCtrl Then
                hSelect.Scale(($hCurrentPoint.X - XC) / ($hLastPoint.X - XC), ($hCurrentPoint.X - XC) / ($hLastPoint.X - XC), Not $bShift)
              Else
                hSelect.Scale(($hCurrentPoint.X - XC) / ($hLastPoint.X - XC), ($hCurrentPoint.Y - YC) / ($hLastPoint.Y - YC), Not $bShift)
              Endif
              
            Case CHANGE_ROTATE
              
              XC = $hChangeRect.X + $hChangeRect.W / 2
              YC = $hChangeRect.Y + $hChangeRect.H / 2
              
              A = ($hLastPoint.X - XC) * ($hCurrentPoint.X - XC) + ($hLastPoint.Y - YC) * ($hCurrentPoint.Y - YC)
              Try A /= Hyp($hLastPoint.X - XC, $hLastPoint.Y - YC) * Hyp($hCurrentPoint.X - XC, $hCurrentPoint.Y - YC)
              If Not Error Then
                
                A = Max(-1, Min(1, A))
                A = ACos(A)
                If ($hCurrentPoint.X - XC) / ($hLastPoint.X - XC) > ($hCurrentPoint.Y - YC) / ($hLastPoint.Y - YC) Then A = -A
              
                If $bAlt Then A = Rad(Int(Deg(A) / 15) * 15)
              
                hSelect.Rotate(-A)
                
              Endif
              
            Case CHANGE_MOVE
              hSelect.Translate($hCurrentPoint.X - $hLastPoint.X, $hCurrentPoint.Y - $hLastPoint.Y)
              
          End Select
          
          ' If $sTool = "paste" Then
          '   If $hPaste Then
          '     $hPasteCurrent = $hPasteSelect.Copy()
          '     $hChangeRect = $hPasteCurrent.GetExtents()
          '   Endif
          ' Endif
          
        Endif
        
        imvImage.Refresh
      
    End Select
    
  Else If $bFrame Then
    
    imvImage.Refresh
  
  Endif
  
  If $hChangeRect And If Not $bPress Then
    
    iMouse = Mouse.Arrow
    $iChangeAction = CHANGE_NOTHING
    $vChangeIndex = Null
    
    If $hSelect Then
    
      I = $hSelect.FindShape($hCurrentPoint, 8 / imvImage.Zoom)
      If I >= 0 Then
        iMouse = Mouse.SizeAll
        If $vChangeIndex And If $vChangeIndex[0] = $hSelect.Current Then
          $iChangeAction = CHANGE_MOVE
        Else
          $iChangeAction = CHANGE_SELECT
        Endif
        $vChangeIndex = [I, -1]
      Else If $hChangeRect.Contains($hCurrentPoint.X, $hCurrentPoint.Y) Then 
        If $hSelect.FindPoint($hCurrentPoint, 8 / imvImage.Zoom) Then
          iMouse = Mouse.Arrow
          $iChangeAction = CHANGE_POINT
          $vChangeIndex = CImageSelection.FindIndex
        Else
          If $hSelect.FindPoint($hCurrentPoint, 8 / imvImage.Zoom, True) Then
            iMouse = Mouse.Cross
            $iChangeAction = CHANGE_INSERT
            $vChangeIndex = CImageSelection.FindIndex
          Endif
        Endif
      Endif
      
    Endif
    
    If $iChangeAction = CHANGE_NOTHING Then
      If Hyp(Abs($hChangeRect.X - $hCurrentPoint.X), Abs($hChangeRect.Y - $hCurrentPoint.Y)) < (16 / imvImage.Zoom) Then
        iMouse = Mouse.Cross
        $iChangeAction = CHANGE_ROTATE
        SetMagnet(Null)
      Else If Hyp(Abs($hChangeRect.X + $hChangeRect.W - $hCurrentPoint.X), Abs($hChangeRect.Y + $hChangeRect.H - $hCurrentPoint.Y)) < (16 / imvImage.Zoom) Then
        iMouse = Mouse.Cross
        $iChangeAction = CHANGE_RESIZE
        SetMagnet(Null)
      Else If $hChangeRect.Contains($hCurrentPoint.X, $hCurrentPoint.Y) Then
        iMouse = Mouse.SizeAll
        $iChangeAction = CHANGE_MOVE
        SetMagnet(Null)
      Endif
    Endif
    
    SetMouse(iMouse)
    
  Else
    
    If $hCurrentPoint.InRect(RectF(0, 0, $hImage.W, $hImage.H)) Or If $bPress Then
      SetMouse($iMouse)
    Else
      SetMouse(Mouse.Default)
    Endif
  
  Endif
  
End

Private Sub UpdateTool()

  Select Case $sTool
    
    Case "draw", "erase"
      If $bCtrl <> $bFrame Then
        $bFrame = $bCtrl
        imvImage.Refresh
      Endif
      
    Case "line"
      If $bCtrl <> $bFrame Then
        $bFrame = $bCtrl
        imvImage.Refresh
      Endif
      
  End Select

End

Private Sub UpdatePasteCurrent()

  $hChangeRect = $hPasteCurrent.GetExtents()
  $hPasteSelect = $hPasteCurrent.Copy()
  imvImage.Refresh

End

Public Sub Form_KeyPress()

  Dim DY As Integer
  Dim DX As Integer
  
  $bShift = Key.Shift
  $bCtrl = Key.Control
  $bAlt = Key.Alt
  $bNormal = Key.Normal
  
  UpdateTool
  
  If $hSelect And If $hChangeRect Then
    If Key.Code = Key.Delete Or If Key.Code = Key.Backspace Then
      If $vChangeIndex Then
        If $vChangeIndex[1] = -1 Then
          $hSelect.RemoveShape($vChangeIndex[0])
        Else
          $hSelect.RemovePoint($vChangeIndex)
        Endif
        If $hSelect.IsVoid() Then ClearSelection
      Endif
      RefreshSelection
    Endif
  Endif
  
  If $sTool = "draw" Then
    If LCase(Key.Text) = "x" Then
      FImageProperty.SetColor($sLastColor)
    Endif
  Endif
  
  If $sTool = "change" Or If $sTool = "paste" Then
    
    Select Case Key.Code
      Case Key.Up
        DY = -1
      Case Key.Down
        DY = 1
      Case Key.Left
        DX = -1
      Case Key.Right
        DX = 1
    End Select
    
    If DX Or If DY Then
      
      If $sTool = "paste" Then
        $hPasteCurrent.Translate(DX, DY)
        UpdatePasteCurrent
      Else
        AddUndo($hSelect.Copy())
        $hSelect.Translate(DX, DY)
        RefreshSelection
      Endif
      
    Endif
    
  Endif
  
  If Key.Code = Key.F6 Then
    Action[".tooltip", Me].Value = Not Action[".tooltip", Me].Value
  Endif
  
  imvImage_MouseMove
  
End

Public Sub Form_KeyRelease()
  
  $bShift = Key.Shift
  $bCtrl = Key.Control
  $bAlt = Key.Alt
  $bNormal = Key.Normal
  UpdateTool
  imvImage_MouseMove
  
End

Public Sub imvImage_MouseUp()

  Dim hImage As Image

  If Not $bPress Then Return

  $bPress = False
  
  If $bDblClick Then 
    $bDblClick = False
    EndUndo
    Return
  Endif
  
  imvImage_MouseMove()
     
  Select Case $sTool
    
    Case "draw", "erase"
      
      If Not $bShift Then
        
        If $sTool = "draw" Then
          If $hLastPoint And If $hImage[$hLastPoint.X, $hLastPoint.Y] <> FImageProperty.GetColor() Then
            $sLastColor = $hImage[$hLastPoint.X, $hLastPoint.Y]
          Endif
        Endif
        
        hImage = $hImage.Copy()
        Paint.Begin(hImage)
        If $sTool = "erase" Then Paint.Operator = Paint.OperatorDestOut
        Paint.DrawImage($hStrokeImage, 0, 0,,, FImageProperty.GetOpacity() / 255)
        Paint.End
        SetImage(hImage)
        $hStrokeImage = Null
        
      Endif
      
    Case "line"
      ' If $hLastPoint.X <> $hCurrentPoint.X Or If $hLastPoint.Y <> $hCurrentPoint.Y Then
      '   $hSelect.LineTo($hLastPoint.X, $hLastPoint.Y)
      '   $hSelect.AddMagnet($hLastPoint)
      '   If $hFirstPoint Then $hSelect.AddMagnet($hFirstPoint)
      ' Endif
      
      $hSelect.CleanLastShape
      
    Case "rectangle", "ellipse"

      If $hLastPoint.X <> $hCurrentPoint.X Or If $hLastPoint.Y <> $hCurrentPoint.Y Then
        imvImage.Refresh
      Else
        'ClearSelection
      Endif
    
    Case "change"

      If $iChangeAction = CHANGE_NOTHING And If $hSelect Then $hSelect.SelectAll
      If $hLastPoint <> $hCurrentPoint Then
        RefreshSelection
      Else If $iChangeAction <> CHANGE_SELECT Then
        btnUndo_Click
      Endif
      SetMagnet(Null)
      
    Case "paste"

      If $hPaste Then
        $hPasteCurrent = $hPasteSelect.Copy()
        $hChangeRect = $hPasteCurrent.GetExtents()
        imvImage.Refresh
      Endif
      
  End Select
  
  'imvImage_MouseMove()
  
  UpdateInfo
  EndUndo

End

' Private Sub DrawTool()
'   
'   Dim I As Integer
'   Dim bDraw As Boolean
'   
'   FImageProperty.PaintForStroke
'   
'   If $sTool = "erase" Then Paint.Operator = Paint.OperatorDestOut
'   
'   If Not Paint.AntiAlias Then
'     Paint.MoveTo(CInt($aStroke[0].X), CInt($aStroke[0].Y))
'     For I = 1 To $aStroke.Max
'       'If CInt($aStroke[I].X) = Paint.X And If CInt($aStroke[I].Y) = Paint.Y Then Continue
'       Paint.LineTo(CInt($aStroke[I].X), CInt($aStroke[I].Y))
'       bDraw = True
'     Next
'     Paint.Stroke
'     If Not bDraw Then 
'       Paint.Rectangle($aStroke[0].X, $aStroke[0].Y, 1, 1)
'       Paint.Fill
'     Endif
'   Else
'     Paint.MoveTo($aStroke[0].X, $aStroke[0].Y)
'     For I = 1 To $aStroke.Max
'       'If CInt($aStroke[I].X) = CInt(Paint.X) And If CInt($aStroke[I].Y) = CInt(Paint.Y) Then Continue
'       Paint.LineTo($aStroke[I].X, $aStroke[I].Y)
'       bDraw = True
'     Next
'     Paint.Stroke
'     If Not bDraw Then
'       Paint.Arc($aStroke[0].X, $aStroke[0].Y, Paint.LineWidth / 2)
'       Paint.Fill
'     Endif
'   Endif
'   
' End

' Private Sub PaintImage(hImage As Image, X As Float, Y As Float, Optional fOpacity As Float = 1.0, Optional hRect As Rect)
' 
'   Dim fZoom As Float = imvImage.Zoom
' 
'   If Not hImage Then Return
'   
'   If hRect Then
'     X += hRect.X * fZoom
'     Y += hRect.Y * fZoom
'   Else
'     hRect = Rect(0, 0, hImage.W, hImage.H)
'   Endif
'   
'   Paint.ZoomImage(hImage, fZoom, X, Y, Color.SetAlpha(Color.Black, 128), hRect, fOpacity)
'   
'   ' Paint.DrawImage(hImage, X, Y, hRect.W * fZoom, hRect.H * fZoom, fOpacity, hRect) 'hRect.W, hRect.H)
'   
'   ' If iZoom > 8 Then
'   '   
'   '   P = X
'   '   S = hRect.H * iZoom
'   '   For I = 0 To hRect.W - 1
'   '     Paint.FillRect(P, Y, 1, S, Color.LightForeground)
'   '     P += iZoom
'   '   Next
'   '   
'   '   P = Y
'   '   S = hRect.W * iZoom
'   '   For I = 0 To hRect.H - 1
'   '     Paint.FillRect(X, P, S, 1, Color.LightForeground)
'   '     P += iZoom
'   '   Next
'   '   
'   ' Endif
'   
' End

Public Sub imvImage_Draw(hZoom As Image)
  
  Dim hOffset As Point
  Dim bAnts As Boolean
  Dim bBalance As Boolean 
  Dim hImage As Image
  Dim hRect As Rect
  Dim X As Integer
  Dim Y As Integer
  Dim iGrid As Integer
  Dim W As Float
  Dim hZoomOrg As Image
  Dim bDiag As Boolean
    
  If Project.ActiveForm = Me And If FImageProperty.HasBalance() Then bBalance = True
  
  hOffset = imvImage.ImageToView(Point(0, 0))
  hZoomOrg = hZoom
  
  If $hStrokeImage Then
    GoSub COPY_IMAGE
    Paint.Begin(hZoom)
    If $sTool = "erase" Then
      Paint.Operator = Paint.OperatorDestOut
    Endif
    Paint.DrawImage($hStrokeImage, $hStrokeExtents.X, $hStrokeExtents.Y, $hStrokeExtents.W, $hStrokeExtents.H, FImageProperty.GetOpacity() / 255, $hStrokeExtents)
    Paint.End
  Endif
  
  If bBalance Then
    
    GoSub COPY_IMAGE
    
    If Not HasSelection() Then
    
      FImageProperty.ApplyBalance(hZoom)
      
    Else
      
      hRect = $hSelect.GetExtentsInt(True)
      If hRect.X < 0 Then
        hRect.W += hRect.X
        hRect.X = 0
      Endif
      If hRect.Y < 0 Then
        hRect.H += hRect.Y
        hRect.Y = 0
      Endif
      
      hImage = hZoom.Copy(hRect.X, hRect.Y, hRect.Width, hRect.Height)
      FImageProperty.ApplyBalance(hImage)
      
      Paint.Begin(hZoom)
      $hSelect.Paint(hZoom, CImageSelection.ACTION_CLIP)
      Paint.Operator = Paint.OperatorSource
      Paint.DrawImage(hImage, hRect.X, hRect.Y)
      Paint.End

    Endif
  Endif
  
  imvImage._Paint(hZoom, hOffset.X, hOffset.Y)
  ' If $hMagic Then 
  ' 
  '   Paint.Save
  '   
  '   Paint.Translate(hOffset.X, hOffset.Y)
  '   Paint.Scale(imvImage.Zoom, imvImage.Zoom)
  '   
  '   Paint.DrawImage($hMagic, 0, 0)
  '   
  '   Paint.Restore
  '   
  ' Endif
  
  If $bShowGrid Then
    
    Paint.Save
    Paint.AntiAlias = False
  
    Paint.LineWidth = 1 / imvImage.Zoom

    Paint.Translate(hOffset.X, hOffset.Y)
    Paint.Scale(imvImage.Zoom, imvImage.Zoom)
      
    Paint.Rectangle(0, 0, $hImage.W, $hImage.H)
    Paint.Clip()
    
    iGrid = FImageProperty.GetGridResolution()
    bDiag = FImageProperty.GetGridDiagonal()
      
    For X = iGrid To $hImage.W Step iGrid
      Paint.MoveTo(X, 0)
      Paint.LineTo(X, $hImage.H)
    Next
    
    For Y = iGrid To $hImage.H Step iGrid
      Paint.MoveTo(0, Y)
      Paint.LineTo($hImage.W, Y)
    Next
    
    If bDiag 
      For X = 0 To $hImage.W - 1 Step iGrid
        For Y = 0 To $hImage.H - 1 Step iGrid
          Paint.MoveTo(X, Y)
          Paint.RelLineTo(iGrid, iGrid)
          Paint.MoveTo(X + iGrid, Y)
          Paint.RelLineTo(-iGrid, iGrid)
        Next
      Next
    Endif
    
    Paint.Background = &H808080&
    Paint.Stroke
    
    Paint.Restore
    
  Endif
    
  If HasSelection() Then
    
    Paint.Save
  
    Paint.Translate(hOffset.X, hOffset.Y)
    Paint.Scale(imvImage.Zoom, imvImage.Zoom)
    
    ' If bBalance Then
    '   
    '   ' If $hSelect.IsInverted() Then
    '   '   hImage = hZoom.Copy()
    '   ' Else
    '     hRect = $hSelect.GetExtentsInt(True)
    '     If hRect.X < 0 Then
    '       hRect.W += hRect.X
    '       hRect.X = 0
    '     Endif
    '     If hRect.Y < 0 Then
    '       hRect.H += hRect.Y
    '       hRect.Y = 0
    '     Endif
    '     hImage = hZoom.Copy(hRect.X, hRect.Y, hRect.Width, hRect.Height)
    '   'Endif
    '   
    '   FImageProperty.ApplyBalance(hImage)
    '   
    '   ' If $hSelect.IsInverted() Then
    '   '   Paint.Save
    '   '   Paint.Reset
    '   '   imvImage._Paint(hImage, hOffset.X, hOffset.Y)
    '   '   Paint.Restore
    '   ' Endif
    '   
    '   Paint.Save
    '   Paint.FillRule = FImageProperty.GetFillRule()
    '   $hSelect.Paint($hImage, CImageSelection.ACTION_CLIP)
    '   Paint.Reset
    '   'Paint.Operator = Paint.OperatorSource
    '   ' If $hSelect.IsInverted() Then
    '   '   imvImage._Paint(hZoom, hOffset.X, hOffset.Y)
    '   ' Else
    '     imvImage._Paint(hImage, hOffset.X + hRect.X * imvImage.Zoom, hOffset.Y + hRect.Y * imvImage.Zoom)
    '   ' Endif
    '   Paint.Restore
    '   
    ' Endif
    
    Paint.LineWidth = 1 / imvImage.Zoom
    Paint.DashOffset = -$fDashOffset
    
    $hSelect.Paint($hImage, CImageSelection.ACTION_SELECT, True)

    ' CImageSelection.PaintingSelection = True
    ' 
    ' Paint.LineWidth = 2 / imvImage.Zoom
    ' Paint.AntiAlias = False
    ' 'Paint.LineJoin = Paint.LineJoinRound
    ' 
    ' Paint.Background = Color.White 'Color.SetAlpha(Color.White, 128)
    ' Paint.Dash = Null
    ' $hSelect.Paint($hImage, CImageSelection.ACTION_STROKE, True)
    ' 
    ' Paint.Background = Color.Black 'Color.SetAlpha(Color.Black, 128)
    ' Paint.Dash = [2.0, 2.0]
    ' Paint.DashOffset = - $fDashOffset
    ' $hSelect.Paint($hImage, CImageSelection.ACTION_STROKE, True)
    ' 
    ' CImageSelection.PaintingSelection = False

    Paint.Restore
    
    bAnts = True
    
  Endif
  
  If $hMagnet Then
    
    Paint.Save
    
    Paint.AntiAlias = False
    Paint.LineWidth = 1
    
    Paint.Translate($hMagnet.X * imvImage.Zoom + hOffset.X, $hMagnet.Y * imvImage.Zoom + hOffset.Y)
    
    Paint.Background = Color.White

    Paint.Rectangle(-5, -4, 9, 9)

    Paint.MoveTo(0, -imvImage.H)
    Paint.LineTo(0, imvImage.H)
    Paint.MoveTo(-imvImage.W, 0)
    Paint.LineTo(imvImage.W, 0)

    Paint.Stroke

    Paint.Background = Color.Black

    Paint.Rectangle(-4, -3, 7, 7)

    Paint.MoveTo(0, -imvImage.H)
    Paint.LineTo(0, imvImage.H)
    Paint.MoveTo(-imvImage.W, 0)
    Paint.LineTo(imvImage.W, 0)

    Paint.Dash = [2.0, 2.0]
    Paint.Stroke
    
    Paint.Restore
  
  Endif
    
  If $bFrame And If Not $bPress Then 
  
    Select Case $sTool
      
      Case "draw", "erase", "line"
        
        If Not $hLastPoint Then Return
        If Not $hCurrentPoint Then Return
        
        Paint.Save
        
        Paint.Dash = Null
        
        If $sTool = "line" Then
          Paint.LineWidth = 1
          'FImageProperty.PaintForStroke
          Paint.AntiAlias = True
          'Paint.LineWidth *= imvImage.Zoom
          Paint.LineJoin = Paint.LineJoinRound
        Else
          FImageProperty.PaintForStroke
          If $sTool = "erase" Then Paint.Background = Color.SetAlpha(Color.Gray, 128)
          Paint.LineWidth *= imvImage.Zoom
        Endif
        
        'Paint.Background = Color.SetAlpha(Color.White, 128)
        If Not Paint.Antialias Then Paint.Translate(imvImage.Zoom / 2, imvImage.Zoom / 2)
        Paint.MoveTo($hLastPoint.X * imvImage.Zoom + hOffset.X, $hLastPoint.Y * imvImage.Zoom + hOffset.Y)
        Paint.LineTo($hCurrentPoint.X * imvImage.Zoom + hOffset.X, $hCurrentPoint.Y * imvImage.Zoom + hOffset.Y)
        
        If $sTool = "line" Then
          Paint.Background = Color.White
          Paint.Stroke(True)
          Paint.Background = Color.Black
          Paint.Dash = [4, 4]
        Endif
        
        Paint.Stroke
        
        Paint.Restore
        
        ' Paint.Background = Color.SetAlpha(Color.Black, 128)
        ' Paint.Dash = [2.0, 2.0]
        ' Paint.DashOffset = - $fDashOffset
        ' If Not Paint.Antialias Then Paint.Translate(imvImage.Zoom / 2, imvImage.Zoom / 2)
        ' Paint.MoveTo(hStart.X, hStart.Y)
        ' Paint.LineTo(hEnd.X, hEnd.Y)
        ' Paint.Stroke
        ' Paint.Reset
        
        'bAnts = True
      
    End Select
    
  Endif
  
  If $hLastPoint Then
  
    Select Case $sTool
      
      Case "draw", "erase", "line"
      
        Paint.Save
        Paint.Antialias = False
        
        If $sTool = "line" Then
          Paint.Ellipse($hLastPoint.X * imvImage.Zoom + hOffset.X - 4, $hLastPoint.Y * imvImage.Zoom + hOffset.Y - 4, 8, 8)
        Else
          If FImageProperty.GetSize() Then
            Paint.Rectangle(($hLastPoint.X - 0.5) * imvImage.Zoom + hOffset.X, ($hLastPoint.Y - 0.5) * imvImage.Zoom + hOffset.Y, imvImage.Zoom, imvImage.Zoom)
          Else
            Paint.Rectangle($hLastPoint.X * imvImage.Zoom + hOffset.X, $hLastPoint.Y * imvImage.Zoom + hOffset.Y, imvImage.Zoom, imvImage.Zoom)
          Endif
        Endif
        
        Paint.LineWidth = 1
        Paint.Background = Color.White
        Paint.Stroke(True)
        Paint.Background = Color.Black
        Paint.Dash = [4, 4]
        Paint.Stroke
        Paint.Restore
      
    End Select
    
  Endif
  
  If $hPaste Then
    
    Paint.Save
    
    'Paint.AntiAlias = False
    
    If $hSelect Then 
      Paint.Translate(hOffset.X, hOffset.Y)
      Paint.Scale(imvImage.Zoom, imvImage.Zoom)
      $hSelect.Paint($hImage, CImageSelection.ACTION_CLIP)
      Paint.Reset
      'imvImage._Paint($hPaste, hOffset.X + $iPasteX * imvImage.Zoom, hOffset.Y + $iPasteY * imvImage.Zoom)
    Endif
    
    With $hPasteSelect.GetExtents()
      If .Width > 0 And If .Height > 0 Then
        hImage = New Image(Ceil(.Width), Ceil(.Height), Color.Transparent)
        
        Paint.Begin(hImage)
        Paint.Brush = Paint.Image($hPaste)
        $hPasteSelect.Translate(-Floor(.X), -Floor(.Y))
        Paint.Brush.Matrix = $hPasteSelect._BrushMatrix.Copy()
        $hPasteSelect.Paint(hImage, CImageSelection.ACTION_FILL)
        $hPasteSelect.Translate(Floor(.X), Floor(.Y))
        Paint.End
      
        Paint.ClipRect = Rect(hOffset.X, hOffset.Y, Ceil($hImage.W * imvImage.Zoom), Ceil($hImage.H * imvImage.Zoom))
        imvImage._Paint(hImage, hOffset.X + Floor(.X) * imvImage.Zoom, hOffset.Y + Floor(.Y) * imvImage.Zoom)
        
        If $bPress Then
          Paint.LineWidth = 1 / imvImage.Zoom
          Paint.AntiAlias = False
          Paint.LineJoin = Paint.LineJoinMiter
          Paint.Translate(hOffset.X + 0.5, hOffset.Y + 0.5)
          Paint.Scale(imvImage.Zoom, imvImage.Zoom)
          Paint.Rectangle(.X, .Y, .W, .H)
          Paint.Background = Color.White
          Paint.Stroke(True)
          Paint.Background = Color.Black
          Paint.Dash = [4.0, 4.0]
          Paint.DashOffset = 0
          Paint.Stroke
        Endif
      Endif
    
    End With
    
    Paint.Restore
    
  Endif
  
  If $hChangeRect Then
    
    Paint.Save
    
    Paint.Translate(hOffset.X + 0.5, hOffset.Y + 0.5)
    Paint.Scale(imvImage.Zoom, imvImage.Zoom)
    
    Paint.LineWidth = 2 / imvImage.Zoom
    Paint.AntiAlias = False
    Paint.LineJoin = Paint.LineJoinRound
      
    If $sTool = "change" Then
      Paint.Background = Color.SetAlpha(Color.Red, 128)
      $hSelect.Paint($hImage, CImageSelection.ACTION_HANDLE)
      Paint.Background = Color.SetAlpha(Color.Blue, 128)
      $hSelect.Paint($hImage, CImageSelection.ACTION_MAGNET)
    Endif
    
    Paint.Background = Color.SetAlpha(Color.Red, 128)
    Paint.Dash = Null
    
    With $hChangeRect
      
      Paint.Rectangle(.X, .Y, .W, .H)
      Paint.Stroke(True)
      
      Paint.Background = Color.SetAlpha(Color.White, 128)
      Paint.Dash = [2.0, 2.0]
      Paint.DashOffset = 0
      Paint.Stroke
      
    End With
    
    
    Paint.Background = Color.SetAlpha(Color.Red, 128)
    Paint.Arc($hChangeRect.X + 0.5 / imvImage.Zoom, $hChangeRect.Y + 0.5 / imvImage.Zoom, 7 / imvImage.Zoom)
    Paint.Rectangle($hChangeRect.X + $hChangeRect.W + (0.5 - 6) / imvImage.Zoom, $hChangeRect.Y + $hChangeRect.H + (0.5 - 6) / imvImage.Zoom, 12 / imvImage.Zoom, 12 / imvImage.Zoom)
    Paint.Fill
    
    If $iChangeAction = CHANGE_POINT Or If $iChangeAction = CHANGE_INSERT Then
      
      Paint.Background = Color.SetAlpha(Color.White, 128)
      W = 3 / imvImage.Zoom
      If $iChangeAction = CHANGE_INSERT Then
        With ($hSelect.Shapes[$vChangeIndex[0]].Points[$vChangeIndex[1]] + $hSelect.Shapes[$vChangeIndex[0]].Points[$vChangeIndex[1] + 1]) / 2
          Paint.Rectangle(.X - W, .Y - W, W * 2, W * 2)
          Paint.Fill
        End With
      Else
        With $hSelect.Shapes[$vChangeIndex[0]].Points[$vChangeIndex[1]]
          Paint.Rectangle(.X - W, .Y - W, W * 2, W * 2)
          Paint.Fill
        End With
      Endif
      
    Endif
    
    Paint.Restore
      
  Endif
  
  ' If $iAngle Then
  '   
  '   hImage = hZoom.Rotate(Rad($iAngle))
  '   imvImage._Paint(hImage, hOffset.X + (hZoom.W - hImage.W) / 2 * imvImage.Zoom, hOffset.Y + (hZoom.H - hImage.H) / 2 * imvImage.Zoom)
  '   'imvImage._Paint(hImage, hOffset.X, hOffset.Y)
  '   
  ' Endif
  
  timSelect.Enabled = bAnts
  Return
  
COPY_IMAGE:

  If hZoom = hZoomOrg Then hZoom = hZoom.Copy()
  Return
  
  
End

Public Sub timSelect_Timer()

  Inc $fDashOffset
  If $fDashOffset >= 8 Then $fDashOffset = 0
  imvImage.Refresh

End

Public Sub btnInvert_Click()

  CreateSelection
  AddUndo($hSelect.Copy())
  $hSelect.Invert($hImage)
  If $hSelect.IsVoid() Then ClearSelection
  RefreshSelection

End

Public Sub timCheckZoom_Timer()

  btnZoomFit_Click

End

Public Sub imvImage_Menu()

  Dim iGrid As Integer
  Dim hMenu As Menu

  Me.SetFocus
  
  If $hSelect And If $hSelect.Current >= 0 Then
    mnuShapeGrid.Visible = True
    iGrid = $hSelect.Shapes[$hSelect.Current].Grid
    For Each hMenu In mnuShapeGrid.Children
      hMenu.Checked = CInt(hMenu.Tag) = iGrid
    Next
  Else
    mnuShapeGrid.Visible = False
  Endif
  
  mnuEditor.Popup

End

Public Sub mnuSelectAll_Click()
  
  $hSelect = New CImageSelection
  btnInvert_Click

End

Public Sub btnCrop_Click()

  Dim hImage As Image
  Dim hRect As Rect
  Dim X As Integer
  Dim Y As Integer
  
  If $hSelect Then
    
    $hSelect.Invert($hImage)
    
    hImage = $hImage.Copy()
    
    Paint.Begin(hImage)
    Paint.Brush = Paint.Color(Color.Black)
    $hSelect.Paint(hImage, CImageSelection.ACTION_CLEAR)
    Paint.End

    $hSelect.Invert($hImage)

    ' If Not $hSelect.IsInverted() Then
    '   hRect = $hSelect.GetExtentsInt(True)
    '   If hRect Then hImage = hImage.Copy(hRect.X, hRect.Y, hRect.Width, hRect.Height)
    ' Endif
    
    BeginUndo
    AddUndo($hSelect.Copy())
    ClearSelection
    SetImage(hImage)
    EndUndo
    
  Else
    
    hRect = New Rect(0, 0, $hImage.W, $hImage.H)
    
    For X = 0 To $hImage.W - 1
      For Y = 0 To $hImage.H - 1
        If Color.GetAlpha($hImage[X, Y]) < 255 Then Break
      Next
      If Y < $hImage.H Then
        hRect.Left = X
        Break
      Endif
    Next
    
    For X = $hImage.W - 1 DownTo hRect.Left
      For Y = 0 To $hImage.H - 1
        If Color.GetAlpha($hImage[X, Y]) < 255 Then Break
      Next
      If Y < $hImage.H Then
        hRect.Right = X + 1
        Break
      Endif
    Next
    
    For Y = 0 To $hImage.H - 1
      For X = hRect.Left To hRect.Right
        If Color.GetAlpha($hImage[X, Y]) < 255 Then Break
      Next
      If X <= hRect.Right Then
        hRect.Top = Y
        Break
      Endif
    Next
    
    For Y = $hImage.H - 1 DownTo hRect.Top
      For X = hRect.Left To hRect.Right
        If Color.GetAlpha($hImage[X, Y]) < 255 Then Break
      Next
      If X <= hRect.Right Then
        hRect.Bottom = Y + 1
        Break
      Endif
    Next
    
    If Not hRect.IsVoid() Then
      If hRect.W < $hImage.W Or If hRect.H < $hImage.H Then
        BeginUndo
        AddUndo($hImage.Copy())
        SetImage($hImage.Copy(hRect.X, hRect.Y, hRect.W, hRect.H))
        EndUndo
      Endif
    Endif
    
  Endif

End

Private Sub BeginUndo()

  $aUndo.Add(BEGIN_UNDO)
  $aRedo.Clear

End

Private Sub EndUndo()
  
  Dim vUndo As Variant = $aUndo[$aUndo.Max]
  
  If TypeOf(vUndo) = gb.Integer And If vUndo = BEGIN_UNDO Then
    $aUndo.Pop()
  Else
    $aUndo.Add(END_UNDO)
  Endif
  
  $aRedo.Clear
  
End

Private Sub RemoveLastEndBeginUndo()
  
  Dim vUndo As Variant
  Dim I As Integer
  
  For I = $aUndo.Max DownTo 1
    vUndo = $aUndo[I]
    If TypeOf(vUndo) = gb.Integer And If vUndo = BEGIN_UNDO Then
      vUndo = $aUndo[I - 1]
      If TypeOf(vUndo) = gb.Integer And If vUndo = END_UNDO Then
        $aUndo.Remove(I - 1, 2)
        Return
      Endif
    Endif
  Next
  
End

' Fast Private Sub CheckPoint(iCol As Integer, X2 As Integer, Y2 As Integer, A0 As Integer) As Boolean
' 
'   Dim R, G, B, A As Float
'   Dim R2, G2, B2, A2 As Float
'   Dim N As Integer
'   Dim F As Float
'   Dim D As Integer
'   
'   'R = $R / $N
'   'G = $G / $N
'   'B = $B / $N
'   'A = $A / $N
'   
'   With Color[iCol]
'     R = .Red
'     G = .Green
'     B = .Blue
'     A = .Alpha
'   End With
'   
'   With Color[$hImage[X2, Y2]]
'     F = (255 - .Alpha) / 255
'     R2 = .Red * F
'     G2 = .Green * F
'     B2 = .Blue * F
'     A2 = .Alpha
'     N = 1
'   End With
'   
'   ' If X2 > 0 Then
'   '   With Color[$hImage[X2 - 1, Y2]]
'   '     F = (255 - .Alpha) / 255
'   '     R2 += .Red * F
'   '     G2 += .Green * F
'   '     B2 += .Blue * F
'   '     A2 += .Alpha
'   '     Inc N
'   '   End With
'   ' Endif
'   ' 
'   ' If X2 < ($hImage.W - 1) Then
'   '   With Color[$hImage[X2 + 1, Y2]]
'   '     F = (255 - .Alpha) / 255
'   '     R2 += .Red * F
'   '     G2 += .Green * F
'   '     B2 += .Blue * F
'   '     A2 += .Alpha
'   '     Inc N
'   '   End With
'   ' Endif
'   ' 
'   ' If Y2 > 0 Then
'   '   With Color[$hImage[X2, Y2 - 1]]
'   '     F = (255 - .Alpha) / 255
'   '     R2 += .Red * F
'   '     G2 += .Green * F
'   '     B2 += .Blue * F
'   '     A2 += .Alpha
'   '     Inc N
'   '   End With
'   ' Endif
'   ' 
'   ' If Y2 < ($hImage.W - 1) Then
'   '   With Color[$hImage[X2, Y2 + 1]]
'   '     F = (255 - .Alpha) / 255
'   '     R2 += .Red * F
'   '     G2 += .Green * F
'   '     B2 += .Blue * F
'   '     A2 += .Alpha
'   '     Inc N
'   '   End With
'   ' Endif
'   ' 
'   ' R2 /= N
'   ' G2 /= N
'   ' B2 /= N
'   ' A2 /= N
'   
'   A0 = A0 * 1.1
'   D = Max(Max(Abs(R2 - R), Abs(G2 - G)), Max(Abs(B2 - B), Abs(A2 - A))) + A0
'   'Print X2;; Y2;; D
'   If D >= 255 Then Return
'   
'   '$R += R2
'   '$G += G2
'   '$B += B2
'   '$A += A2
'   Inc $N
' 
'   $hMagic[X2, Y2] = Color.SetAlpha(Color.Black, D)
'   '$hImage[X2, Y2] = Color.Blend($hImage[X2, Y2], $hMagic[X2, Y2])
'   If ($N And 1023) = 0 Then 
'     imvImage.Refresh
'     Wait
'   Endif
' 
'   Return True
' 
' End
' 
' Fast Private Sub MagicWand()
' 
'   Dim aPoint As New Integer[]
'   Dim X, Y, X2, Y2, A As Integer
'   Dim hImage As Image
'   
'   $iTol = 1 'FImageProperty.GetTolerance()
'   
'   $hMagic = New Image($hImage.W, $hImage.H, Color.White)
'   
'   aPoint.Add($hLastPoint.X)
'   aPoint.Add($hLastPoint.Y)
'   
'   With Color[$hImage[$hLastPoint.X, $hLastPoint.Y]]
'     $R = .Red * (255 - .Alpha) / 255
'     $G = .Green * (255 - .Alpha) / 255
'     $B = .Blue * (255 - .Alpha) / 255
'     $A = .Alpha
'     $N = 1
'   End With
'   
'   $hMagic[$hLastPoint.X, $hLastPoint.Y] = Color.Black
'   
'   While aPoint.Count
'     
'     X = aPoint[0]
'     Y = aPoint[1]
'     aPoint.Remove(0, 2)
'     
'     A = Color.GetAlpha($hMagic[X, Y])
'     
'     X2 = X + 1
'     Y2 = Y
'     GoSub LOOK_POINT
'     X2 = X + 1
'     Y2 = Y + 1
'     GoSub LOOK_POINT
'     X2 = X
'     Y2 = Y + 1
'     GoSub LOOK_POINT
'     X2 = X - 1
'     Y2 = Y + 1
'     GoSub LOOK_POINT
'     X2 = X - 1
'     Y2 = Y
'     GoSub LOOK_POINT
'     X2 = X - 1
'     Y2 = Y - 1
'     GoSub LOOK_POINT
'     X2 = X
'     Y2 = Y - 1
'     GoSub LOOK_POINT
'     X2 = X + 1
'     Y2 = Y - 1
'     GoSub LOOK_POINT
'     
'   Wend
'   
'   hImage = $hImage.Copy()
'   $hMagic.Replace(Color.White, Color.Transparent)
'   '$hMagic = $hMagic.Fuzzy(1)
'   hImage.PaintImage($hMagic, 0, 0)
'   SetImage(hImage)
'   $hMagic = Null
'   Return
'   
' LOOK_POINT:
' 
'   If X2 < 0 Or If Y2 < 0 Or If X2 >= $hImage.W Or If Y2 >= $hImage.H Then Return
'   If $hMagic[X2, Y2] <> Color.White Then Return
'   
'   If CheckPoint($hImage[X, Y], X2, Y2, A) Then
'     aPoint.Add(X2)
'     aPoint.Add(Y2)
'   Endif
'   
'   Return
'   
' End

Public Sub btnZoomFit_Click()

  Dim iIndex As Integer
  Dim fZoom As Float
  
  For iIndex = cmbZoom.Count - 1 DownTo 0
    
    fZoom = CFloat(String.Left(cmbZoom[iIndex].Text, -1))
    If ($hImage.W * fZoom) > imvImage.W Or If ($hImage.H * fZoom) > imvImage.H Then Break
    
  Next
  
  cmbZoom.Index = Min(cmbZoom.Count - 1, iIndex + 1)

End

Public Sub btnCopy_Click()

  Dim hImage As Image
  Dim hExt As Rect
  
  If $hSelect Then
    
    $hSelect.Invert($hImage)
    
    hImage = $hImage.Copy()
    
    Paint.Begin(hImage)
    Paint.Brush = Paint.Color(Color.Black)
    $hSelect.Paint(hImage, CImageSelection.ACTION_CLEAR)
    Paint.End

    $hSelect.Invert($hImage)

    ' If Not $hSelect.IsInverted() Then
      hExt = $hSelect.GetExtentsInt(True)
      If hExt Then hImage = hImage.Copy(hExt.X, hExt.Y, hExt.Width, hExt.Height)
    ' Endif
    
    Inc $iClipboard
    FImageProperty.AddClipboard(hImage, Me.Name & " [" & CStr($iClipboard) & "]")
    Clipboard.Copy(hImage)
    
  Else
    
    FImageProperty.AddClipboard($hImage.Copy(), Me.Name)
    Clipboard.Copy($hImage)
    
  Endif
  
End

Public Sub btnCut_Click()

  Dim hImage As Image

  BeginUndo

  btnCopy_Click

  If $hSelect Then
    
    hImage = $hImage.Copy()
    Paint.Begin(hImage)
    $hSelect.Paint($hImage, CImageSelection.ACTION_CLEAR)
    Paint.End
    SetImage(hImage)
    
  Else
    
    hImage = New Image($hImage.W, $hImage.H, Color.Transparent)
    SetImage(hImage)
    
  Endif

  ClearSelection

  EndUndo
  
  btnPaste.Value = True

End

Private Sub DoPaste()

  Dim hImage As Image
  
  If Not $hPaste Then Return
  
  hImage = $hImage.Copy()
  Paint.Begin(hImage)

  If $hSelect Then $hSelect.Paint($hImage, CImageSelection.ACTION_CLIP)
  
  Paint.Brush = Paint.Image($hPaste) ', ($hImage.W - $hPaste.W) \ 2, ($hImage.H - $hPaste.H) \ 2)
  Paint.Brush.Matrix = $hPasteSelect._BrushMatrix.Copy()
  $hPasteSelect.Paint(hImage, CImageSelection.ACTION_FILL)
  
  Paint.End
  
  SetImage(hImage)
  'ClearPaste
  'SetTool("paste")
  
End

Public Sub Form_Activate()

  If Not $bFirstTime Then 
    btnZoomFit_Click
    $bFirstTime = True
  Endif

End

Public Sub RefreshSelection()
  
  imvImage.Refresh
  If $sTool = "change" Then 
    If Not HasSelection() Then 
      $hChangeRect = Null
    Else
      $hChangeRect = $hSelect.GetExtents()
    Endif
  Endif
  
End

Public Sub imvImage_Leave()

  $iChangeAction = CHANGE_NOTHING
  UpdateInfo

End

Public Sub ApplyEffect(iEffect As Integer)
  
  Dim hImage As Image
  Dim hEffect As Image
  
  Select Case iEffect
    
    Case EFFECT_BALANCE
      
      hEffect = $hImage.Copy()
      FImageProperty.ApplyBalance(hEffect)
    
    Case EFFECT_COLORIZE
    
      hEffect = $hImage.Copy().Colorize(FImageProperty.GetColor(True))
      
    Case EFFECT_DESATURATE
    
      hEffect = $hImage.Copy().Desaturate()
      
    Case EFFECT_TRANSPARENT
    
      hEffect = $hImage.Copy().Erase()
      
  End Select
  
  If $hSelect Then

    ' If $hSelect.IsInverted() Then
    '   
    '   Paint.Begin(hEffect)
    '   $hSelect.Paint(hEffect, CImageSelection.ACTION_CLIP)
    '   Paint.DrawImage($hImage, 0, 0)
    '   Paint.End
    '   
    '   hImage = hEffect
    '   
    ' Else
    
      hImage = $hImage.Copy()
      
      Paint.Begin(hImage)
      $hSelect.Paint(hImage, CImageSelection.ACTION_CLIP)
      Paint.Operator = Paint.OperatorSource
      Paint.DrawImage(hEffect, 0, 0)
      Paint.End

    ' Endif

  Else
    
    hImage = hEffect
    
  Endif
  
  SetImage(hImage)
    
End

Public Sub ApplyBalance()
  
  ApplyEffect(EFFECT_BALANCE)
  
End


Public Sub OnProjectDebug()

  SetReadOnly

End

Private Sub UpdateMenu()

  Dim bVisible As Boolean

  bVisible = Not $bReadOnly

  If $bReadOnly Then SetTool("move")

  mnuAction.Visible = bVisible
  mnuSelection.Visible = bVisible
  
  Action[".save,.undo,.redo,.tool-*,.hide,.invert,.stroke,.fill,.clear,.cut,.paste,.crop,.flip-h,.flip-v,.rotate-*,.rotate,.resize,.select-all,.duplicate,.offset", Me].Visible = bVisible
  
End

Public Sub mnuHideSelection_Click()
  
  If $sTool = "paste" Then
    ClearPaste
    SetTool($sToolBefore)
  Else If $sTool = "change" Then
    SetTool($sToolBefore)
  Else If $hSelect Then
    ClearSelection
  Else
    FMain.HidePanels
  Endif

End

Public Sub mnuPaste_Click()
  
  SetTool("paste")
  
End


Public Sub tlbMain_Configure()

  UpdateMenu

End

Public Sub btnRotate_Click()

  If FImageRotate.Run(Me) Then 
    imvImage.Update($hImage)
    Return
  Endif
  SetImage($hImage.Rotate(Rad(FImageRotate.Angle)))

End

Public Sub UpdateRotation(iAngle As Integer)
  
  '$iAngle = iAngle
  imvImage.Update($hImage.Rotate(Rad(iAngle)))
  
End

Public Sub Form_GotFocus()

  imvImage.SetFocus

End

Public Sub imvImage_GotFocus()

  Project.SetCurrentPopup(mnuEditor)

End

Public Sub mnuClose_Click()
  
  Me.Close
  
End

Public Sub PasteShape(hShape As CImageSelection)
  
  Dim S As Float
  
  If btnEditSelection.Value Then
    SetTool("change")
  Else
    btnEditSelection.Value = True
  Endif
  
  BeginUndo
  
  CreateSelection
  
  hShape = hShape.Copy()
  With hShape.GetExtents()
    S = Min(imvImage.ScrollW / imvImage.Zoom * 0.25 / .W, imvImage.ScrollH / imvImage.Zoom * 0.25 / .H)
    hShape.Translate($hImage.W / 2, $hImage.H / 2)
    hShape.Scale(S, S)
  End With
  
  $hSelect.Select($hSelect.AddSelection(hShape))
  
  RefreshSelection
  
  EndUndo
  
End

Public Sub UpdateBalance()
  
  If $hPaste Then $hPaste = FImageProperty.GetClipboard()
  imvImage.Refresh
  
End

Public Sub UpdateClipboard()
  
  If $sTool = "paste" Then 
    ClearPaste
    SetTool("paste")
  Endif
  
End


Public Sub btnGrid_Click()

  $bShowGrid = Not $bShowGrid
  imvImage.Refresh
  FImageProperty.ShowGridOption($bShowGrid)

End

Public Sub UpdateGrid()
  
  imvImage.Refresh
  
End


Public Sub btnDuplicate_Click()

  If $hSelect Then
    
    AddUndo($hSelect.Copy())
    $hSelect.Duplicate
    RefreshSelection
    
  Endif

End

Public Sub btnOffset_Click()

  If Not $hSelect Then Return
  
  If FImageOffsetSelection.Run() Then Return
  
  AddUndo($hSelect.Copy())
  $hSelect.Offset(FImageOffsetSelection.Size, FImageOffsetSelection.Duplicate)
  RefreshSelection

End

Fast Private Sub CreateSelectionFromMask(hImage As Image) As Polygon[]
  
  Dim X, Y As Integer
  Dim CW, CB As Integer
  Dim I As Integer
  Dim W As Integer
  Dim hPoly As Polygon
  Dim aPoly As New Polygon[]
  
  CW = Color.White
  CB = Color.Black
  
  For Y = 0 To hImage.H - 1
    For X = 0 To hImage.W - 1
      
      If hImage[X, Y] <> CB Then Continue
      
      W = 1
      For I = X + 1 To hImage.W - 1
        If hImage[I, Y] <> CB Then Break
        Inc W
      Next
      
      hPoly = New Polygon
      hPoly.Add(X, Y)
      hPoly.Add(X + W, Y)
      hPoly.Add(X + W, Y + 1)
      hPoly.Add(X, Y + 1)
      aPoly.Add(hPoly)
      
      X = I
      
    Next
  Next
  
  aPoly = Clipper.Simplify(aPoly, Clipper.FillWinding)
  aPoly = Clipper.Clean(aPoly)
  Return aPoly
  
End

Fast Private Sub CreateMask() As Image
  
  Dim hMask As Image
  Dim aPoint As New Integer[]
  Dim X, X1, X2, Y, XL, XR As Integer
  Dim WW, HH As Integer
  Dim C As Integer
  Dim fTolerance As Float
  
  WW = $hImage.W
  HH = $hImage.H
  
  X = $hLastPoint.X
  Y = $hLastPoint.Y
  
  If X < 0 Or If Y < 0 Or If X >= WW Or If Y >= HH Then Return
  
  fTolerance = FImageProperty.GetTolerance() / 255
  
  hMask = New Image(WW, HH, Color.White)
  
  Dec WW
  Dec HH
  
  aPoint.Add(X)
  aPoint.Add(X)
  aPoint.Add(Y)
  C = $hImage[X, Y]
  
  While aPoint.Count
    
    Y = aPoint.Pop()
    X2 = aPoint.Pop()
    X1 = aPoint.Pop()
    
    For X = X1 To X2
    
      ' I = hMask[X, Y]
      ' hMask[X, Y] = Color.Green
      ' imvImage.Update(hMask)
      ' Wait
      ' hMask[X, Y] = I
  
      If hMask[X, Y] = Color.Black Then Continue
      If Color.Distance($hImage[X, Y], C) > fTolerance Then Continue
      'hMask[X, Y] = Color.Black
      
      For XL = X - 1 DownTo 0
        If Color.Distance($hImage[XL, Y], C) > fTolerance Then Break
      Next
      Inc XL
      
      For XR = X + 1 To WW
        If Color.Distance($hImage[XR, Y], C) > fTolerance Then Break
      Next
      Dec XR
      
      hMask.FillRect(XL, Y, XR - XL + 1, 1, Color.Black)
      ' imvImage.Update(hMask)
      ' Wait 0.1
      
      If Y Then
        aPoint.Add(XL)
        aPoint.Add(XR)
        aPoint.Add(Y - 1)
      Endif
      
      If Y < HH Then
        aPoint.Add(XL)
        aPoint.Add(XR)
        aPoint.Add(Y + 1)
      Endif
      
    Next
    
  Wend
  
  Return hMask
  
End


Private Sub MagicWand()

  Dim hMask As Image
  Dim aPoly As Polygon[]
  Dim hPoly As Polygon
  Dim hShape As CImageShape
  
  Inc Application.Busy
  
  hMask = CreateMask()
  
  If hMask Then
    aPoly = CreateSelectionFromMask(hMask)
    aPoly = Clipper.Simplify(aPoly, Clipper.FillWinding)
    
    For Each hPoly In aPoly
      hShape = New CImageShape
      hShape.Points = hPoly
      $hSelect.AddShape(hShape)
    Next
  Endif
  
  Dec Application.Busy

End

Private Sub ClearPaste()

  If $hPaste Then
    $hPaste = Null
    $hPasteSelect = Null
    $hPasteCurrent = Null
    $hChangeRect = Null
    imvImage.Refresh
    $iChangeAction = CHANGE_NOTHING
    FImageProperty.ClearPaste
  Endif

End

Public Sub mnuDivide_Click()
  
  If Not $hSelect Then Return
  If $hSelect.Current < 0 Then Return
  
  $hSelect.Shapes[$hSelect.Current].Grid = CInt(Last.Tag)
  imvImage.Refresh
  
End

Private Sub GetCurrentFormat() As String

  Dim sFormat As String = Lower(File.Ext(Path))
  
  Select Case sFormat
    Case "jpg"
      Return "jpeg"
    Default
      Return sFormat
  End Select

End

Public Sub mnuFormat_Show()
  
  Dim sFormat As String = GetCurrentFormat()
  Dim hMenu As Menu
  
  For Each hMenu In mnuFormat.Children
    hMenu.Checked = hMenu.Tag = sFormat
  Next
  
  ' If sFormat = "jpeg" Or If sFormat = "png" Then
  '   mnuQuality.Enabled = True
  ' Else
  '   mnuQuality.Enabled = False
  ' Endif
  
End


Public Sub mnuSaveAs_Click()
  
  Dim sFormat As String = Last.Tag
  
  If sFormat <> GetCurrentFormat() Then
    
    Project.RenameFile(Path, File.SetExt(File.Name(Path), sFormat))
    Me.Save(True)
    
  Endif
  
End

Public Sub ReadConfig()
  
  Project.SetSmallFont(tlbMain)
  
End

Public Sub btnHide_Click()

  ClearSelection

End

Public Sub UpdateText(sText As String, sFont As String, iAlign As Integer, bAlignBase As Boolean)
  
  $hSelect = $hTextSelect.Copy()
  $hSelect.Text($hLastPoint.X, $hLastPoint.Y, sText, sFont, iAlign, bAlignBase)
  imvImage.Refresh
  
End

Public Sub imvImage_MouseWheel()

  If Mouse.Forward Then
    btnZoomIn_Click
  Else
    btnZoomOut_Click
  Endif
  Stop Event

End

Public Sub HasGrid() As Boolean
  
  Return $bShowGrid
  
End

Public Sub GetTool() As String
  
  Return $sTool
  
End

Public Sub Action_Activate((Key) As String) As Boolean
  
  Select Case Key
    Case ".locked"
      Project.SetReadOnly(Path, Action[Key, Me].Value)
    Case ".tooltip"
      dwgInfo.Visible = Action[".tooltip", Me].Value
    Case Else
      Return True
  End Select
  
End

Public Sub Form_Close()

  Project.AddRecentFile(Me)

End

Public Sub ExecAction(sAction As String)
  
  Dim hImage As Image

  Select Case sAction
    
    Case "stroke"
    
      If $hSelect Then
        
        hImage = $hImage.Copy()
        Paint.Begin(hImage)
        FImageProperty.PaintForStroke($hSelect.GetExtents(True))
        $hSelect.Paint($hImage, CImageSelection.ACTION_STROKE)
        Paint.End
        SetImage(hImage)
        
      Endif
    
    Case "fill"
    
      hImage = $hImage.Copy()
      Paint.Begin(hImage)
      If $hSelect Then
        FImageProperty.PaintForFill($hSelect.GetExtents(True))
        $hSelect.Paint($hImage, CImageSelection.ACTION_FILL)
      Else
        FImageProperty.PaintForFill()
        Paint.Rectangle(0, 0, hImage.W, hImage.H)
        Paint.Fill
      Endif
      Paint.End
      SetImage(hImage)
      
    Case "clear"
      
      If $hSelect Then
        
        hImage = $hImage.Copy()
        Paint.Begin(hImage)
        FImageProperty.PaintForFill
        $hSelect.Paint($hImage, CImageSelection.ACTION_CLEAR)
        Paint.End
        SetImage(hImage)
        
      Else
        
        hImage = New Image($hImage.W, $hImage.H, Color.Transparent) '$hImage.Copy()
        'hImage.Transparent(FImageProperty.GetColor(True))
        SetImage(hImage)
        
      Endif
    
    Case "colorize"
      ApplyEffect(EFFECT_COLORIZE)
    
    Case "desaturate"
      ApplyEffect(EFFECT_DESATURATE)
    
    Case "transparent"
      ApplyEffect(EFFECT_TRANSPARENT)
    
  End Select
  
End

Private Sub MoveInfo()

  Dim X, Y As Integer
  Dim DX As Integer
  Dim DY As Integer

  If imvImage.ScrollH > imvImage.ClientH Then DX = Style.ScrollbarSize
  If imvImage.ScrollW > imvImage.ClientW Then DY = Style.ScrollbarSize
  
  If System.RightToLeft Then
    X = Desktop.Scale
  Else
    X = panBackground.W - dwgInfo.W - Desktop.Scale - DX
  Endif
  Y = Desktop.Scale
  If Not $bInfoTop Then Y = Max(Y, panBackground.H - dwgInfo.H - Desktop.Scale - DY)

  dwgInfo.Move(X, Y)

End

Public Sub panBackground_Arrange()

  MoveInfo

End

Public Sub dwgInfo_Draw()

  Dim DS As Integer = Desktop.Scale
  Dim X As Integer
  Dim Y As Integer
  Dim W As Float
  Dim H As Integer
  Dim iCol As Integer
  
  'dwgInfo.Background = 

  If Not $cInfo Then Return

  iCol = Color.SetAlpha(Color.TextForeground, 128)
  
  H = Paint.Font.Height + DS
  Paint.FillRect(0, 0, Paint.W, H, iCol)
  Paint.FillRect(0, H + 1, Paint.W, Paint.H - H - 1, iCol)
  
  X = DS
  Y = DS \ 2
  W = (Paint.W - DS * 2) / 4
  H = Paint.Font.Height
  
  If $cInfo.Exist("Color") Then
    
    Paint.DrawText($cInfo!X, X, Y, W - DS, H, Align.Right)
    Paint.DrawText("â€¢", X, Y, W * 2, H, Align.Center)
    X += W
    Paint.DrawText($cInfo!Y, X + DS, Y, W, H, Align.Left)
    X += W
    
    If $cInfo.Exist("Width") Then
      Paint.DrawText($cInfo!Width, X, Y, W - DS, H, Align.Right)
      Paint.DrawText("Ã—", X, Y, W * 2, H, Align.Center)
      X += W
      Paint.DrawText($cInfo!Height, X + DS, Y, W, H, Align.Left)
      X += W
    Endif
    
    X = DS
    Y += H + DS
    
    With Color[$cInfo!Color]
      
      X += (DS * 3) \ 2
      Paint.DrawText(CStr(.Red), X, Y, W, H, Align.Left)
      X += W
      Paint.DrawText(CStr(.Green), X, Y, W, H, Align.Left)
      X += W
      Paint.DrawText(CStr(.Blue), X, Y, W, H, Align.Left)
      X += W
      Paint.DrawText(CStr(.Alpha), X, Y, W, H, Align.Left)
      
      X = DS
      Y += (H - DS) / 2
      For Each iCol In [Color.Red, Color.Green, Color.Blue, Color.White]
        Paint.Ellipse(X, Y, DS, DS)
        Paint.Background = Color.SetAlpha(iCol, 64)
        Paint.Fill
        X += W
      Next
      
    End With
    
  Else
    
    Paint.DrawText($cInfo!Width & " Ã— " & $cInfo!Height, X, Y, Paint.W - X, H, Align.Center)
    Y += H + DS
    Paint.DrawText($cInfo!Size, X, Y, Paint.W - X, H, Align.Center)
    
  Endif

End

Public Sub btnUnion_Click()

  DoOperation(CImageSelection.OP_UNION)
  
End

Public Sub btnIntersection_Click()

  DoOperation(CImageSelection.OP_INTERSECTION)
  
End

Public Sub btnDifference_Click()

  DoOperation(CImageSelection.OP_DIFFERENCE)
  
End

Public Sub btnExclusive_Click()

  DoOperation(CImageSelection.OP_XOR)
  
End

Private Sub DoOperation(iOp As Integer)

  If Not $hSelect Then Return
  If $hSelect.Count < 2 Then Return
  
  AddUndo($hSelect.Copy())
  $hSelect.Operation(iOp)
  RefreshSelection

End

Public Sub GetPopupMenu() As Menu
  
  Return mnuEditor
  
End

Public Sub imvImage_DblClick()

  RemoveLastEndBeginUndo
  ClearSelection
  $bDblClick = True

End

Public Sub dwgInfo_Enter()

  $bInfoTop = Not $bInfoTop
  MoveInfo

End

Private Sub HasSelection() As Boolean

  If $hSelect And If Not $hSelect.IsVoid() Then Return True
  
End
