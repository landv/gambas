' Gambas class file

Public Path As String
Public RichText As String

Public Enum EFFECT_BALANCE, EFFECT_COLORIZE, EFFECT_DESATURATE, EFFECT_TRANSPARENT
Private Enum TRANS_FLIP_H, TRANS_FLIP_V, TRANS_ROTATE_L, TRANS_ROTATE_R

Property Read ReadOnly As Boolean

Private $bReadOnly As Boolean
Private $hImage As Image
Private $bModify As Boolean

Private $iMouse As Integer
Private $hCursor As Cursor

Private $bFirstTime As Boolean

Private $aUndo As New Variant[]
Private $aRedo As New Variant[]
Private Enum BEGIN_UNDO, END_UNDO

Private $sTool As String
Private $hFirstPoint As PointF
Private $hLastPoint As PointF
Private $hCurrentPoint As PointF
Private $bPress As Boolean
Private $bShift As Boolean
Private $bCtrl As Boolean
Private $bAlt As Boolean

Private $bFrame As Boolean
Private $fDashOffset As Float

Private $SX As Integer
Private $SY As Integer

Private $hStrokeImage As Image
'Private $aStroke As New PointF[]
Private $hStrokeExtents As Rect
'Private $hStrokeOrigin As Point

Private $hSelect As CImageSelection

Private $hLastMagnet As PointF
Private $hMagnet As PointF
Private $sMagnet As String

Private $iClipboard As Integer

Private $hPaste As Image
Private $hPasteCurrent As CImageSelection
Private $hPasteSelect As CImageSelection

Private $iAngle As Integer

Private $hChangeRect As RectF
Private $iChangeAction As Integer
Private $vChangeIndex As Variant
Private Enum CHANGE_NOTHING, CHANGE_MOVE, CHANGE_RESIZE, CHANGE_ROTATE, CHANGE_POINT, CHANGE_INSERT, CHANGE_SELECT

Private $bShowGrid As Boolean
Private $hTextSelect As CImageSelection

Private $sLastColor As Integer

Public Sub _new(sPath As String)
  
  Me.Name = File.Name(sPath)
  Path = sPath
  
  dwgBackground.Lower
  
  Reload
  
  SetTool("move")
  
End


Private Function ReadOnly_Read() As Boolean

  Return $bReadOnly

End

Private Sub ClearSelection()

  If Not $hSelect Then Return
  
  AddUndo($hSelect.Copy())
  $hSelect = Null
  $hChangeRect = Null
  $hMagnet = Null
  $hLastMagnet = Null
  $sMagnet = ""
  $iChangeAction = CHANGE_NOTHING
  RefreshSelection

End

Private Sub CreateSelection()
  
  If $hSelect Then Return
  $hSelect = New CImageSelection
  RefreshSelection
  
End


Public Sub Reload()
  
  $hImage = Image.Load(Path)
  imvImage.Image = $hImage  
  $bModify = False
  ClearSelection
  $aUndo.Clear
  $aRedo.Clear
  btnZoomFit_Click
  SetReadOnly
  
End

Public Sub LoadFile() As Boolean
  
  Reload
  
End

Public Sub btnZoomIn_Click()

  Try Inc cmbZoom.Index

End

Public Sub btnZoomOut_Click()

  If cmbZoom.Index = 0 Then Return
  Dec cmbZoom.Index

End

Public Sub cmbZoom_Click()

  imvImage.Zoom = CFloat(Trim(String.Left(cmbZoom.Text, -1)))
  imvImage.Grid = imvImage.Zoom > 8

End

Public Sub IsModified() As Boolean
  
  Return $bModify
  
End

Public Sub dwgBackground_Draw()

  Dim hTopLeft As Point
  Dim hBottomRight As Point

  Project.DrawBackground()
  
  hTopLeft = imvImage.ImageToView(Point(0, 0))
  If Not hTopLeft Then Return
  hBottomRight = imvImage.ImageToView(Point(imvImage.Image.W, imvImage.Image.H))

  Paint.Background = Color.SetAlpha(Color.Black, 192)
  Paint.Rectangle(hTopLeft.X - 2, hTopLeft.Y - 2, hBottomRight.X - hTopLeft.X + 4, 2)
  Paint.Rectangle(hTopLeft.X - 2, hBottomRight.Y, hBottomRight.X - hTopLeft.X + 4, 2)
  Paint.Rectangle(hTopLeft.X - 2, hTopLeft.Y, 2, hBottomRight.Y - hTopLeft.Y)
  Paint.Rectangle(hBottomRight.X, hTopLeft.Y, 2, hBottomRight.Y - hTopLeft.Y)
  Paint.Fill

End

Public Sub Form_Open()

  ReadConfig
  SetReadOnly

End

Public Sub SetReadOnly()

  Dim bReadOnly As Boolean

  If Project.ReadOnly Or If Project.Running Or If Project.IsReadOnly(Path) Then
    bReadOnly = True
  Endif

  $bReadOnly = bReadOnly
  
  Project.UpdateLockedAction(Me)
  
  UpdateMenu
  DrawTitle

End

Private Sub DrawTitle()

  Project.DrawTitle(Me)

End

Public Sub btnZoomNormal_Click()

  cmbZoom.Index = 3

End

Public Sub Modify(Optional bReset As Boolean)

  If Project.ReadOnly Or $bReadOnly Then Return
  If $bModify <> bReset Then Return

  $bModify = Not bReset
  DrawTitle
  If $bModify Then Inc Project.TimeStamp

End

Private Sub SetImage(hImage As Image)
  
  AddUndo($hImage)
  $hImage = hImage
  
  imvImage.Update($hImage)
  Modify
  imvImage.SetFocus
  UpdateInfo
  
End

Private Sub AddUndo(hObject As Object)
  
  If Not hObject Then Return
  If $aUndo.Count = 64 Then $aUndo.Remove(0)
  $aUndo.Add(hObject)
  $aRedo.Clear
  
End

Private Sub ApplyTransformation(iTrans As Integer)
  
  Dim hImage As Image
  
  If $hChangeRect Then
  
    If $hSelect Then

      AddUndo($hSelect.Copy())
      
      Select Case iTrans
        Case TRANS_FLIP_H
          $hSelect.HFlip()
        Case TRANS_FLIP_V
          $hSelect.VFlip()
        Case TRANS_ROTATE_L
          $hSelect.Rotate(Rad(90))
        Case TRANS_ROTATE_R
          $hSelect.Rotate(Rad(-90))
      End Select
      
      RefreshSelection
    
    Endif
      
    If $hPaste Then
      
      Select Case iTrans
        Case TRANS_FLIP_H
          $hPaste.Mirror(True, False)
          '$hPasteCurrent.HFlip
          '$hPasteSelect.HFlip
        Case TRANS_FLIP_V
          $hPaste.Mirror(False, True)
          '$hPasteCurrent.VFlip
          '$hPasteSelect.VFlip
        Case TRANS_ROTATE_L
          '$hPaste.RotateLeft()
          'Swap $hChangeRect.W, $hChangeRect.H
          $hPasteCurrent.Rotate(Rad(90))
          '$hPasteSelect.Rotate(Rad(90))
        Case TRANS_ROTATE_R
          '$hPaste.RotateRight()
          'Swap $hChangeRect.W, $hChangeRect.H
          $hPasteCurrent.Rotate(Rad(-90))
          '$hPasteSelect.Rotate(Rad(-90))
      End Select
      
    Endif
    
    $hChangeRect = $hPasteCurrent.GetExtents()
    $hPasteSelect = $hPasteCurrent.Copy()
     
    imvImage.Refresh
      
    Return
    
  Endif

  BeginUndo
  ClearSelection
  
  hImage = $hImage.Copy()
  
  Select Case iTrans
    Case TRANS_FLIP_H
      hImage.Mirror(True, False)
    Case TRANS_FLIP_V
      hImage.Mirror(False, True)
    Case TRANS_ROTATE_L
      hImage.RotateLeft()
    Case TRANS_ROTATE_R
      hImage.RotateRight()
  End Select
  
  SetImage(hImage)
  EndUndo
  
End


Public Sub btnRotateL_Click()

  ApplyTransformation(TRANS_ROTATE_L)

End

Public Sub btnRotateR_Click()

  ApplyTransformation(TRANS_ROTATE_R)

End

Public Sub btnFlipH_Click()

  ApplyTransformation(TRANS_FLIP_H)

End

Public Sub btnFlipV_Click()

  ApplyTransformation(TRANS_FLIP_V)

End


Public Function Save(Optional bForce As Boolean) As Boolean

  If Project.ReadOnly Then Return
  If $bReadOnly Then Return
  If Not $bModify And If Not bForce Then Return

  'PRINT "Picture not saved"

  'HideSelection

  Save.Begin(Path)

  $hImage.Save(Path)

  'Project.RefreshKey(Path)

  $bModify = False
  DrawTitle
  Save.End()

Catch

  Return Save.Error()

End

Public Sub btnSave_Click()

  Me.Save

End

Public Sub btnReload_Click()

  If IsModified() Then
    If Message.Warning(("The file has been modified.\n\nAll your changes will be lost."), ("Reload"), ("Cancel")) <> 1 Then Return
  Endif

  Reload

End

Public Sub btnResize_Click()

  Dim X, Y, W, H As Integer
  Dim hImage As Image

  FImageResize.ImageWidth = $hImage.Width
  FImageResize.ImageHeight = $hImage.Height
  
  If FImageResize.Run() Then Return
  
  W = FImageResize.ImageWidth
  H = FImageResize.ImageHeight
  
  If W = $hImage.W And If H = $hImage.H Then Return
  
  If FImageResize.Stretch Then
    SetImage($hImage.Stretch(W, H))
  Else
    hImage = New Image(W, H, Color.Transparent)
    If FImageResize.CenterH Then X = (W - $hImage.W) \ 2
    If FImageResize.CenterV Then Y = (H - $hImage.H) \ 2
    hImage.DrawImage($hImage, X, Y)
    SetImage(hImage)
  Endif

End

Public Sub Rename(sNewName As String, sNewPath As String)

  Me.Name = sNewName
  Path = sNewPath 
  DrawTitle

End

Private Sub SetTool(sAction As String)

  Dim hCtrl As ToolButton
  Dim hImage As Image
  
  'If $sTool = sAction Then Return

  For Each hCtrl In [btnMove, btnDraw, btnErase, btnRectangle, btnEllipse, btnLine, btnMagic, btnPaste, btnEditSelection, btnText]
    Object.Lock(hCtrl)
    hCtrl.Value = hCtrl.Tag = sAction
    Object.Unlock(hCtrl)
  Next
  
  If $sTool = "paste" Then
    If sAction = "paste" Then DoPaste
    ClearPaste
  Endif
  
  If $hSelect Then $hSelect.SelectAll()
  $hChangeRect = Null
  $iChangeAction = CHANGE_NOTHING

  $iMouse = Mouse.Arrow
  $hCursor = Null

  Select Case sAction
    
    Case "move"
      $iMouse = Mouse.SizeAll
    
    Case "draw", "erase"
      $iMouse = Mouse.Cross
    
    Case "magic"
      $iMouse = Mouse.Custom
      $hCursor = New Cursor(Picture["img/draw/magic.png"], 0, 0)
      
    Case "paste"
      hImage = FImageProperty.GetClipboard()
      If hImage Then 
  
        $hPaste = hImage
        
        $hPasteCurrent = New CImageSelection
        $hPasteCurrent.Rectangle(0, 0, $hPaste.W, $hPaste.H)
        $hPasteCurrent.Translate(($hImage.W - $hPaste.W) \ 2, ($hImage.H - $hPaste.H) \ 2)
        
        $hPasteSelect = $hPasteCurrent.Copy()
        
        $hChangeRect = $hPasteCurrent.GetExtents()

        imvImage.Refresh
        
      Endif
      
    Case "change"
      If $hSelect And If Not $hSelect.IsVoid() Then
        $hChangeRect = $hSelect.GetExtents()
      Endif
      
    Case "text"
      $iMouse = Mouse.Cross
      CreateSelection
      $hTextSelect = $hSelect.Copy()
      $hLastPoint = imvImage.ViewToImage(Point(imvImage.ScrollX + imvImage.ClientW / 2, imvImage.ScrollY + imvImage.ClientH / 2))
      FImageProperty.ShowTextOption(True, True)

  End Select
  
  $sTool = sAction
  
  If $sTool <> "text" Then FImageProperty.ShowTextOption(False)

End

Public Sub btnTool_Click()

  SetTool(Last.Tag)

End

Public Sub imvImage_Scroll()
  
  If Not $bPress Then imvImage_MouseMove
  
End


Public Sub btnUndo_Click()

  Dim vUndo As Variant
  Dim iLevel As Integer

  If $aUndo.Count = 0 Then Return
  
  Repeat
  
    vUndo = $aUndo.Pop()
    
    If TypeOf(vUndo) = gb.Integer Then
      $aRedo.Add(vUndo)
      If vUndo = END_UNDO Then
        Inc iLevel
      Else If vUndo = BEGIN_UNDO Then
        Dec iLevel
      Endif
    Else If vUndo Is Image Then
      $aRedo.Add($hImage)
      $hImage = vUndo
      imvImage.Update($hImage)
      Modify
    Else If vUndo Is CImageSelection Then
      $aRedo.Add($hSelect)
      $hSelect = vUndo
      imvImage.Refresh
    Endif
    
  Until iLevel = 0

  RefreshSelection
  UpdateInfo
  
End

Public Sub btnRedo_Click()

  Dim vUndo As Variant
  Dim iLevel As Integer

  If $aRedo.Count = 0 Then Return
  
  Repeat
    
    vUndo = $aRedo.Pop()
  
    If TypeOf(vUndo) = gb.Integer Then
      $aUndo.Add(vUndo)
      If vUndo = BEGIN_UNDO Then
        Inc iLevel
      Else If vUndo = END_UNDO Then
        Dec iLevel
      Endif
    Else If vUndo Is Image Then
      $aUndo.Add($hImage)
      $hImage = vUndo
      imvImage.Update($hImage)
      Modify
    Else If vUndo Is CImageSelection Then
      $aUndo.Add($hSelect)
      $hSelect = vUndo
      imvImage.Refresh
    Endif
    
  Until iLevel = 0

  RefreshSelection
  UpdateInfo
  
End

Private Sub GetPos() As Point
  
  Return Point(Mouse.ScreenX - imvImage.ScreenX, Mouse.ScreenY - imvImage.ScreenY)
  
End

Private Sub GetImagePos() As PointF
  
  Dim hPos As Point = GetPos()
  Dim hPoint As Point = imvImage.ViewToImage(hPos)
  Dim hOrg As Point = imvImage.ImageToView(Point(0, 0))
  Dim X As Float
  Dim Y As Float
  Dim iSnap As Integer
  
  X = hPoint.X + Frac((hPos.X - hOrg.X) / imvImage.Zoom)
  Y = hPoint.Y + Frac((hPos.Y - hOrg.Y) / imvImage.Zoom)
  
  If $hMagnet Then
    
    If Abs($hMagnet - PointF(X, Y)) <= 8 / imvImage.Zoom Then Return $hMagnet
    
  Else If $bShowGrid Then
  
    iSnap = FImageProperty.GetGridResolution() \ FImageProperty.GetGridSubdivision()
  
    X = (CInt(X + iSnap \ 2) \ iSnap) * iSnap
    Y = (CInt(Y + iSnap \ 2) \ iSnap) * iSnap
    
  Else If $sTool = "paste" Then
    
    X = CInt(X)
    Y = CInt(Y)
    
  Endif
  
  Return PointF(X, Y)
  
End


Private Sub StartStroke()

  Dim iSize As Integer = FImageProperty.GetSize()

  $hStrokeImage = New Image($hImage.W, $hImage.H, Color.Transparent)

  Paint.Begin($hStrokeImage)

  FImageProperty.PaintForStroke(Null, True)
  
  If iSize = 0 Then
    $hLastPoint.X = CInt($hLastPoint.X)
    $hLastPoint.Y = CInt($hLastPoint.Y)
    Paint.Rectangle($hLastPoint.X, $hLastPoint.Y, 1, 1)
    $hStrokeExtents = Rect($hLastPoint.X, $hLastPoint.Y, 1, 1)
  Else
    Paint.Arc($hLastPoint.X, $hLastPoint.Y, iSize / 2)
    $hStrokeExtents = Rect($hLastPoint.X - iSize \ 2 - 1, $hLastPoint.Y - iSize \ 2 - 1, iSize * 2, iSize * 2)
  Endif
  
  Paint.Fill
  
  Paint.End
  
  imvImage.Refresh

End

Private Sub AddStroke(hPoint As PointF)

  Dim iSize As Integer = FImageProperty.GetSize()

  If iSize = 0 Then
    hPoint.X = CInt(hPoint.X)
    hPoint.Y = CInt(hPoint.Y)
    $hStrokeExtents = $hStrokeExtents.Union(Rect($hLastPoint.X - 1, $hLastPoint.Y - 1, 3, 3))
  Else
    $hStrokeExtents = $hStrokeExtents.Union(Rect($hLastPoint.X - iSize \ 2 - 1, $hLastPoint.Y - iSize \ 2 - 1, iSize * 2, iSize * 2))
  Endif
  
  $hStrokeExtents = $hStrokeExtents.Intersection(Rect(0, 0, $hImage.W, $hImage.H))
  If Not $hStrokeExtents Then $hStrokeExtents = New Rect

  If hPoint = $hLastPoint Then Return
  
  Paint.Begin($hStrokeImage)
 
  FImageProperty.PaintForStroke(Null, True)
  
  Paint.MoveTo($hLastPoint.X, $hLastPoint.Y)
  Paint.LineTo(hPoint.X, hPoint.Y)
  
  Paint.Stroke
  
  Paint.End
  
  $hLastPoint = hPoint
  
  imvImage.Refresh
  
End

' Public Sub timStroke_Timer()
' 
'   Dim iSize As Integer
'   
'   If $aStroke.Count = 0 Then Return
'   
'   iSize = Max(1, FImageProperty.GetSize())
' 
'   With $hStrokeExtents.Copy()
'     .Adjust(- iSize)
'     .Left = Max(0, .Left)
'     .Top = Max(0, .Top)
'     $hStrokeOrigin = Point(.X, .Y)
'     $hStrokeImage = $hImage.Copy(.X, .Y, .W, .H)
'     Paint.Begin($hStrokeImage)
'     Paint.Translate(- .X, - .Y)
'     DrawTool
'     Paint.End
'   End With
'   
'   imvImage.Refresh
'     
' End

Public Sub imvImage_MouseDown()

  Me.SetFocus
  $bPress = Mouse.Left
  If Not $bPress Then Return
  
  Select Case $sTool
    
    Case "move"
      
      $SX = imvImage.ScrollX
      $SY = imvImage.ScrollY
    
    Case "draw", "erase"
      
      If Not Mouse.Shift Then 
        $hLastPoint = GetImagePos()
        If $hMagnet Then $hLastPoint = $hMagnet
      Endif
      
      StartStroke()
      'AddStroke($hLastPoint)
      
    Case "line"
      
      CreateSelection
      AddUndo($hSelect.Copy())
      
      $hCurrentPoint = GetImagePos()
      If $hMagnet Then $hCurrentPoint = $hMagnet
      
      If Not Mouse.Shift Or If Not $hLastPoint Then 
        $hSelect.MoveTo($hCurrentPoint.X, $hCurrentPoint.Y)
      Else
        $hSelect.LineTo($hCurrentPoint.X, $hCurrentPoint.Y)
        $hSelect.AddMagnet(PointF(($hCurrentPoint.X + $hLastPoint.X) / 2, ($hCurrentPoint.Y + $hLastPoint.Y) / 2))
      Endif
      
      $hFirstPoint = $hCurrentPoint
      $hLastPoint = $hCurrentPoint
      imvImage.Refresh
      
    Case "rectangle", "ellipse"

      CreateSelection
      AddUndo($hSelect.Copy())
      
      $hLastPoint = GetImagePos()
      If $hMagnet Then $hLastPoint = $hMagnet
      
    Case "magic"
      
      CreateSelection
      AddUndo($hSelect.Copy())
      $hLastPoint = GetImagePos()
      MagicWand
      
    Case "paste"
      
      If $hPaste Then
        $hLastPoint = GetImagePos()
        If $hMagnet Then $hLastPoint = $hMagnet
        $hLastPoint = GetImagePos()
      Endif
      
    Case "change"
      
      If $iChangeAction = CHANGE_NOTHING Then
        
        $SX = imvImage.ScrollX
        $SY = imvImage.ScrollY
        
      Else
      
        AddUndo($hSelect.Copy())
        $hLastPoint = GetImagePos()
        If $hMagnet Then $hLastPoint = $hMagnet
        
        If $iChangeAction = CHANGE_INSERT Then
          $vChangeIndex = $hSelect.InsertPoint($hLastPoint, $vChangeIndex)
          AddUndo($hSelect.Copy()) ' Avoid automatic undo at MouseUp
          $iChangeAction = CHANGE_POINT
          RefreshSelection
        Else If $iChangeAction = CHANGE_SELECT Then
          If $vChangeIndex And If $vChangeIndex[0] = $hSelect.Current Then
            $hSelect.SelectNext(8 / imvImage.Zoom)
          Else
            $hSelect.Select($vChangeIndex[0])
          Endif
          RefreshSelection
        Endif
        
      Endif
    
  End Select
  
  imvImage_MouseMove()
  
End

Private Sub UpdateInfo()
  
  Dim sInfo As String

  If $hCurrentPoint.InRect(RectF(0, 0, $hImage.W, $hImage.H)) Or If $bPress Then
    sInfo = CStr(CInt($hCurrentPoint.X)) & " , " & CStr(CInt($hCurrentPoint.Y))
    If $bPress Then
      If $sTool = "rectangle" Or If $sTool = "ellipse" Or If $sTool = "text" Then
        If $bShift Then
          sInfo &= " ( " & (Abs(CInt($hCurrentPoint.X) - CInt($hLastPoint.X)) * 2) & " x " & (Abs(CInt($hCurrentPoint.Y) - CInt($hLastPoint.Y)) * 2) & " )"
        Else
          sInfo &= " ( " & Abs(CInt($hCurrentPoint.X) - CInt($hLastPoint.X)) & " x " & Abs(CInt($hCurrentPoint.Y) - CInt($hLastPoint.Y)) & " )"
        Endif
      Endif
    Endif
    
    sInfo &= " [#" & Hex$($hImage[$hCurrentPoint.X, $hCurrentPoint.Y], 8) & "]"
    
  Endif
  
  FImageProperty.UpdateInfo(sInfo)
  
End

Private Sub GetRectLimits(hRect As RectF) As PointF[]
  
  With hRect
    Return [PointF(.X, .Y), PointF(.X + .W, .Y), PointF(.X, .Y + .H), PointF(.X + .W, .Y + .H)] ',PointF(.X + .W / 2, .Y + .H / 2)
  End With
  
End


Private Sub FindBestMagnetFor(hPoint As PointF, Optional bIgnoreLast As Boolean) As PointF

  Dim hMagnet As PointF

  If $hSelect Then 
    If $sTool = "change" Then
      If $iChangeAction = CHANGE_MOVE And If $hSelect.Current < 0 Then Goto NO_SELECT
      If $iChangeAction = CHANGE_RESIZE Or If $iChangeAction = CHANGE_ROTATE Then Goto NO_SELECT
    Endif
    hMagnet = $hSelect.FindMagnet(hPoint, 8 / imvImage.Zoom, bIgnoreLast)
    If hMagnet Then Return hMagnet
  Endif

NO_SELECT:

  If $sTool <> "move" Then
    hMagnet = CImageSelection.FindMagnetFrom(GetRectLimits(RectF(0, 0, $hImage.W, $hImage.H)), hPoint, 8 / imvImage.Zoom)
    If hMagnet Then Return hMagnet
  Endif

  If $hChangeRect Then
    If $bPress And If $iChangeAction = CHANGE_POINT Then
      hMagnet = $hSelect.FindPoint(hPoint, 8 / imvImage.Zoom,, $vChangeIndex)
      If hMagnet Then Return hMagnet
    Endif
    hMagnet = CImageSelection.FindMagnetFrom(GetRectLimits($hChangeRect), hPoint, 8 / imvImage.Zoom, True)
    If hMagnet Then Return hMagnet
  Endif
  
  If $sTool = "line" And If $hSelect And If $hSelect.Shapes.Count Then
    hMagnet = CImageSelection.FindMagnetFrom($hSelect.Shapes[$hSelect.Shapes.Max].Magnets, hPoint, 8 / imvImage.Zoom, True)
    If hMagnet Then Return hMagnet
  Endif
    
End

Private Sub SetMagnet(hMagnet As PointF)

  If hMagnet <> $hMagnet Then
    $hLastMagnet = $hMagnet
    $hMagnet = hMagnet
    '$sMagnet = sName
    imvImage.Refresh
  Endif

End

Private Sub FindBestMagnet(hCurrent As PointF) As PointF

  Dim hMagnet As PointF
  Dim bCurrent As Boolean
  Dim hPoint As PointF
  Dim bIgnoreLast As Boolean
  
  If $sTool = "move" Then Return hCurrent
  If $sTool = "change" Or $sTool = "paste" And If Not $bPress Then Return hCurrent
  
  If $bPress Then
    bIgnoreLast = $sTool = "rectangle" Or $sTool = "ellipse" Or $sTool = "line" Or $sTool = "text"
  Endif
  
  If $hMagnet And If hCurrent = $hMagnet Then Return hCurrent
  
  hMagnet = FindBestMagnetFor(hCurrent, bIgnoreLast)
  If hMagnet Then
    bCurrent = True
    Goto FIND_MAGNET
  Endif
  
  If $bPress Then
    
    If $hChangeRect And If $iChangeAction <> CHANGE_NOTHING And If $iChangeAction <> CHANGE_POINT Then

      If $iChangeAction <> CHANGE_RESIZE And If $iChangeAction <> CHANGE_ROTATE Then

        'Print "~ "; hCurrent - $hCurrentPoint
        
        If $hSelect Then
          If $hSelect.Current >= 0 Then
            For Each hPoint In $hSelect.Shapes[$hSelect.Current].GetMagnets()
              hPoint += hCurrent - $hCurrentPoint
              hMagnet = FindBestMagnetFor(hPoint, bIgnoreLast)
              If hMagnet Then Goto FIND_MAGNET
            Next
          Endif
          For Each hPoint In GetRectLimits($hSelect.GetExtents())
            hPoint += hCurrent - $hCurrentPoint
            hMagnet = FindBestMagnetFor(hPoint, bIgnoreLast)
            If hMagnet Then Goto FIND_MAGNET
          Next
        Else If $hPasteSelect Then
          For Each hPoint In GetRectLimits($hPasteSelect.GetExtents())
            hPoint += hCurrent - $hCurrentPoint
            hMagnet = FindBestMagnetFor(hPoint, bIgnoreLast)
            If hMagnet Then Goto FIND_MAGNET
          Next
        Endif
        
      Endif
    Endif
  
  Endif

FIND_MAGNET:

  SetMagnet(hMagnet)

  If hMagnet Then
   
    'Print "Magnet";; hMagnet; " <- "; hPoint
   
    If bCurrent Then
      hCurrent = hMagnet
      $hLastMagnet = Null
      'Print "Current";; hCurrent
    Else
      'Print "Other";; hCurrent;; hMagnet - hPoint
      hCurrent = hCurrent + hMagnet - hPoint
    Endif
    
  Else If $hLastMagnet Then
      
    If hCurrent.X > ($hLastMagnet.X - 8 / imvImage.Zoom) And If hCurrent.X < ($hLastMagnet.X + 8 / imvImage.Zoom) Then
      hCurrent.X = $hLastMagnet.X
    Endif
    If hCurrent.Y > ($hLastMagnet.Y - 8 / imvImage.Zoom) And If hCurrent.Y < ($hLastMagnet.Y + 8 / imvImage.Zoom) Then
      hCurrent.Y = $hLastMagnet.Y
    Endif
      
  Endif
    
  Return hCurrent

End

Private Sub SetMouse(iMouse As Integer)

  If iMouse = Mouse.Custom Then
    imvImage.Cursor = $hCursor
  Endif
  imvImage.Mouse = iMouse

End

Public Sub imvImage_MouseMove()

  Dim hPos As Point = GetPos()
  Dim WW, HH As Float
  Dim iMouse As Integer
  Dim XC, YC As Float
  Dim A As Float
  Dim hSelect As CImageSelection
  Dim I As Integer
  
  $hCurrentPoint = FindBestMagnet(GetImagePos())
  UpdateInfo
  
  If $bPress Then
    
    If $sTool <> "move" Then imvImage.EnsureVisible(imvImage.ScrollX + hPos.X - 32, imvImage.ScrollY + hPos.Y - 32, 64, 64)
    
    Select Case $sTool
      
      Case "move"
        
        imvImage.Scroll($SX - (Mouse.X - Mouse.StartX), $SY - (Mouse.Y - Mouse.StartY))
      
      Case "draw", "erase"
        
        If $hLastPoint.X <> $hCurrentPoint.X Or If $hLastPoint.Y <> $hCurrentPoint.Y Then
          AddStroke($hCurrentPoint)
        Endif
      
      Case "line"
        
        If $hLastPoint.X <> $hCurrentPoint.X Or If $hLastPoint.Y <> $hCurrentPoint.Y Then
          $hSelect.LineTo($hCurrentPoint.X, $hCurrentPoint.Y)
          imvImage.Refresh
          $hLastPoint = $hCurrentPoint
        Endif
        
        If $hFirstPoint And If Hyp($hCurrentPoint.X - $hFirstPoint.X, $hCurrentPoint.Y - $hFirstPoint.Y) > 8 Then 
          $hSelect.AddMagnet($hFirstPoint)
          $hFirstPoint = Null
        Endif
        
      Case "rectangle"
        
        If $bCtrl Then $hCurrentPoint.Y = $hLastPoint.Y + Abs($hCurrentPoint.X - $hLastPoint.X) * Sgn($hCurrentPoint.Y - $hLastPoint.Y)
        If $hLastPoint.X <> $hCurrentPoint.X Or If $hLastPoint.Y <> $hCurrentPoint.Y Then
          $hSelect = $aUndo[$aUndo.Max].Copy()
          WW = $hCurrentPoint.X - $hLastPoint.X + Sgn($hCurrentPoint.X - $hLastPoint.X)
          HH = $hCurrentPoint.Y - $hLastPoint.Y + Sgn($hCurrentPoint.Y - $hLastPoint.Y)
          If $bShift Then
            $hSelect.Rectangle($hLastPoint.X - WW, $hLastPoint.Y - HH, WW * 2, HH * 2)
          Else
            $hSelect.Rectangle($hLastPoint.X, $hLastPoint.Y, WW, HH)
          Endif
          imvImage.Refresh
        Endif
      
      Case "text"
        
        $hLastPoint = GetImagePos() '$hCurrentPoint
        FImageProperty.RefreshTextOption
      
      Case "ellipse"
        
        If $bCtrl Then $hCurrentPoint.Y = $hLastPoint.Y + Abs($hCurrentPoint.X - $hLastPoint.X) * Sgn($hCurrentPoint.Y - $hLastPoint.Y)
        If $hLastPoint.X <> $hCurrentPoint.X Or If $hLastPoint.Y <> $hCurrentPoint.Y Then
          $hSelect = $aUndo[$aUndo.Max].Copy()
          WW = Abs($hCurrentPoint.X - $hLastPoint.X + Sgn($hCurrentPoint.X - $hLastPoint.X))
          HH = Abs($hCurrentPoint.Y - $hLastPoint.Y + Sgn($hCurrentPoint.Y - $hLastPoint.Y))
          If $bShift Then
            WW *= Sqr(2)
            HH *= Sqr(2)
            $hSelect.Ellipse($hLastPoint.X - WW, $hLastPoint.Y - HH, WW * 2, HH * 2)
          Else
            $hSelect.Ellipse(Min($hLastPoint.X, $hCurrentPoint.X), Min($hLastPoint.Y, $hCurrentPoint.Y), WW, HH)
          Endif
          imvImage.Refresh
        Endif
        
      Case "change", "paste"
        
        If $iChangeAction = CHANGE_NOTHING And If $sTool = "change" Then
            
          ' No mouse event data possible
          Try imvImage.Scroll($SX - (Mouse.X - Mouse.StartX), $SY - (Mouse.Y - Mouse.StartY))
          
        Else If $iChangeAction = CHANGE_POINT Then
          
          $hSelect.SetPoint($vChangeIndex, $hCurrentPoint)
          
        Else If $iChangeAction = CHANGE_SELECT Then
          
          If Hyp(Mouse.X - Mouse.StartX, Mouse.Y - Mouse.StartY) > 4 Then 
            $iChangeAction = CHANGE_MOVE
            AddUndo($hSelect.Copy())
            $hSelect.Translate($hCurrentPoint.X - $hLastPoint.X, $hCurrentPoint.Y - $hLastPoint.Y)
            '$hSelect = $aUndo[$aUndo.Max].Copy()
            '$hSelect.Translate($hCurrentPoint.X - $hLastPoint.X, $hCurrentPoint.Y - $hLastPoint.Y)
          Endif
          
        Else If $iChangeAction Then
        
          If $sTool = "change" Then
            $hSelect = $aUndo[$aUndo.Max].Copy()
            hSelect = $hSelect
          Else
            $hPasteSelect = $hPasteCurrent.Copy()
            hSelect = $hPasteSelect
          Endif
          
          Select Case $iChangeAction
            
            Case CHANGE_RESIZE
              
              If $bShift Then
                XC = $hChangeRect.X + $hChangeRect.W / 2
                YC = $hChangeRect.Y + $hChangeRect.H / 2
              Else
                XC = $hChangeRect.X
                YC = $hChangeRect.Y
              Endif
              
              If $bCtrl Then
                hSelect.Scale(($hCurrentPoint.X - XC) / ($hLastPoint.X - XC), ($hCurrentPoint.X - XC) / ($hLastPoint.X - XC), Not $bShift)
              Else
                hSelect.Scale(($hCurrentPoint.X - XC) / ($hLastPoint.X - XC), ($hCurrentPoint.Y - YC) / ($hLastPoint.Y - YC), Not $bShift)
              Endif
              
            Case CHANGE_ROTATE
              
              XC = $hChangeRect.X + $hChangeRect.W / 2
              YC = $hChangeRect.Y + $hChangeRect.H / 2
              
              A = ($hLastPoint.X - XC) * ($hCurrentPoint.X - XC) + ($hLastPoint.Y - YC) * ($hCurrentPoint.Y - YC)
              Try A /= Hyp($hLastPoint.X - XC, $hLastPoint.Y - YC) * Hyp($hCurrentPoint.X - XC, $hCurrentPoint.Y - YC)
              If Not Error Then
                
                A = Max(-1, Min(1, A))
                A = ACos(A)
                If ($hCurrentPoint.X - XC) / ($hLastPoint.X - XC) > ($hCurrentPoint.Y - YC) / ($hLastPoint.Y - YC) Then A = - A
              
                If $bCtrl Then A = Rad(Int(Deg(A) / 15) * 15)
              
                hSelect.Rotate(- A)
                
              Endif
              
            Case CHANGE_MOVE
              hSelect.Translate($hCurrentPoint.X - $hLastPoint.X, $hCurrentPoint.Y - $hLastPoint.Y)
              
          End Select
          
        Endif
        
        imvImage.Refresh
      
    End Select
    
  Else If $bFrame Then
    
    imvImage.Refresh
  
  Endif
  
  If $hChangeRect And If Not $bPress Then
    
    iMouse = Mouse.Arrow
    $iChangeAction = CHANGE_NOTHING
    $vChangeIndex = Null
    
    If $hSelect Then
    
      I = $hSelect.FindShape($hCurrentPoint, 8 / imvImage.Zoom)
      If I >= 0 Then
        iMouse = Mouse.SizeAll
        If $vChangeIndex And If $vChangeIndex[0] = $hSelect.Current Then
          $iChangeAction = CHANGE_MOVE
        Else
          $iChangeAction = CHANGE_SELECT
        Endif
        $vChangeIndex = [I, -1]
      Else If $hChangeRect.Contains($hCurrentPoint.X, $hCurrentPoint.Y) Then 
        If $hSelect.FindPoint($hCurrentPoint, 8 / imvImage.Zoom) Then
          iMouse = Mouse.Arrow
          $iChangeAction = CHANGE_POINT
          $vChangeIndex = CImageSelection.FindIndex
        Else
          If $hSelect.FindPoint($hCurrentPoint, 8 / imvImage.Zoom, True) Then
            iMouse = Mouse.Cross
            $iChangeAction = CHANGE_INSERT
            $vChangeIndex = CImageSelection.FindIndex
          Endif
        Endif
      Endif
      
    Endif
    
    If $iChangeAction = CHANGE_NOTHING Then
      If Hyp(Abs($hChangeRect.X - $hCurrentPoint.X), Abs($hChangeRect.Y - $hCurrentPoint.Y)) < (16 / imvImage.Zoom) Then
        iMouse = Mouse.Cross
        $iChangeAction = CHANGE_ROTATE
        SetMagnet(Null)
      Else If Hyp(Abs($hChangeRect.X + $hChangeRect.W - $hCurrentPoint.X), Abs($hChangeRect.Y + $hChangeRect.H - $hCurrentPoint.Y)) < (16 / imvImage.Zoom) Then
        iMouse = Mouse.Cross
        $iChangeAction = CHANGE_RESIZE
        SetMagnet(Null)
      Else If $hChangeRect.Contains($hCurrentPoint.X, $hCurrentPoint.Y) Then
        iMouse = Mouse.SizeAll
        $iChangeAction = CHANGE_MOVE
        SetMagnet(Null)
      Endif
    Endif
    
    SetMouse(iMouse)
    
  Else
    
    If $hCurrentPoint.InRect(RectF(0, 0, $hImage.W, $hImage.H)) Or If $bPress Then
      SetMouse($iMouse)
    Else
      SetMouse(Mouse.Default)
    Endif
  
  Endif
  
End

Private Sub UpdateTool()

  Select Case $sTool
    
    Case "draw", "erase", "line"
      If $bShift <> $bFrame Then
        $bFrame = $bShift
        imvImage.Refresh
      Endif
    
  End Select

End

Public Sub Form_KeyPress()

  $bShift = Key.Shift
  $bCtrl = Key.Control
  $bAlt = Key.Alt
  UpdateTool
  
  If $hSelect And If $hChangeRect Then
    If Key.Code = Key.Delete Or If Key.Code = Key.Backspace Then
      If $vChangeIndex Then
        If $vChangeIndex[1] = -1 Then
          $hSelect.RemoveShape($vChangeIndex[0])
        Else
          $hSelect.RemovePoint($vChangeIndex)
        Endif
        If $hSelect.IsVoid() Then ClearSelection
      Endif
      RefreshSelection
    Endif
  Endif
  
  If $hPaste Then
    If Key.Code = Key.Escape Then ClearSelection
  Endif
  
  If $sTool = "draw" Then
    If LCase(Key.Text) = "x" Then
      FImageProperty.SetColor($sLastColor)
    Endif
  Endif
  
  imvImage_MouseMove
  
End

Public Sub Form_KeyRelease()
  
  $bShift = Key.Shift
  $bCtrl = Key.Control
  $bAlt = Key.Alt
  UpdateTool
  imvImage_MouseMove
  
End

Public Sub imvImage_MouseUp()

  Dim hImage As Image

  If Not $bPress Then Return

  imvImage_MouseMove()

  Select Case $sTool
    
    Case "draw", "erase"
      
      If $sTool = "draw" Then
        If $hImage[$hLastPoint.X, $hLastPoint.Y] <> FImageProperty.GetColor() Then
          $sLastColor = $hImage[$hLastPoint.X, $hLastPoint.Y]
        Endif
      Endif
      
      hImage = $hImage.Copy()
      Paint.Begin(hImage)
      If $sTool = "erase" Then Paint.Operator = Paint.OperatorDestOut
      Paint.DrawImage($hStrokeImage, 0, 0,,, FImageProperty.GetOpacity() / 255)
      Paint.End
      SetImage(hImage)
      $hStrokeImage = Null
      
    Case "line"
      If $hLastPoint.X <> $hCurrentPoint.X Or If $hLastPoint.Y <> $hCurrentPoint.Y Then
        $hSelect.LineTo($hLastPoint.X, $hLastPoint.Y)
        $hSelect.AddMagnet($hLastPoint)
        If $hFirstPoint Then $hSelect.AddMagnet($hFirstPoint)
      Endif
      $hSelect.CleanLastShape

    Case "rectangle", "ellipse"
      If $hLastPoint.X <> $hCurrentPoint.X Or If $hLastPoint.Y <> $hCurrentPoint.Y Then
        imvImage.Refresh
      Else
        ClearSelection
      Endif
    
    Case "change"
      If $iChangeAction = CHANGE_NOTHING And If $hSelect Then $hSelect.SelectAll
      If $hLastPoint <> $hCurrentPoint Then
        RefreshSelection
      Else If $iChangeAction <> CHANGE_SELECT Then
        btnUndo_Click
      Endif
      SetMagnet(Null)
      
    Case "paste"
      If $hPaste Then
        $hPasteCurrent = $hPasteSelect.Copy()
        $hChangeRect = $hPasteCurrent.GetExtents()
      Endif
      
  End Select
  
  $bPress = False
  
  imvImage_MouseMove()
  
  UpdateInfo

End

' Private Sub DrawTool()
'   
'   Dim I As Integer
'   Dim bDraw As Boolean
'   
'   FImageProperty.PaintForStroke
'   
'   If $sTool = "erase" Then Paint.Operator = Paint.OperatorDestOut
'   
'   If Not Paint.AntiAlias Then
'     Paint.MoveTo(CInt($aStroke[0].X), CInt($aStroke[0].Y))
'     For I = 1 To $aStroke.Max
'       'If CInt($aStroke[I].X) = Paint.X And If CInt($aStroke[I].Y) = Paint.Y Then Continue
'       Paint.LineTo(CInt($aStroke[I].X), CInt($aStroke[I].Y))
'       bDraw = True
'     Next
'     Paint.Stroke
'     If Not bDraw Then 
'       Paint.Rectangle($aStroke[0].X, $aStroke[0].Y, 1, 1)
'       Paint.Fill
'     Endif
'   Else
'     Paint.MoveTo($aStroke[0].X, $aStroke[0].Y)
'     For I = 1 To $aStroke.Max
'       'If CInt($aStroke[I].X) = CInt(Paint.X) And If CInt($aStroke[I].Y) = CInt(Paint.Y) Then Continue
'       Paint.LineTo($aStroke[I].X, $aStroke[I].Y)
'       bDraw = True
'     Next
'     Paint.Stroke
'     If Not bDraw Then
'       Paint.Arc($aStroke[0].X, $aStroke[0].Y, Paint.LineWidth / 2)
'       Paint.Fill
'     Endif
'   Endif
'   
' End

Private Sub PaintImage(hImage As Image, X As Float, Y As Float, Optional fOpacity As Float = 1.0, Optional hRect As Rect)

  Dim fZoom As Float = imvImage.Zoom
  Dim iZoom As Integer = CInt(fZoom)
  Dim I, P, S As Integer

  If Not hImage Then Return
  
  If hRect Then
    X += hRect.X * fZoom
    Y += hRect.Y * fZoom
  Else
    hRect = Rect(0, 0, hImage.W, hImage.H)
  Endif
  
  Paint.DrawImage(hImage, X, Y, hRect.W * fZoom, hRect.H * fZoom, fOpacity, hRect) 'hRect.W, hRect.H)
  
  If iZoom > 8 Then
    
    P = X
    S = hRect.H * iZoom
    For I = 0 To hRect.W - 1
      Paint.FillRect(P, Y, 1, S, Color.LightForeground)
      P += iZoom
    Next
    
    P = Y
    S = hRect.W * iZoom
    For I = 0 To hRect.H - 1
      Paint.FillRect(X, P, S, 1, Color.LightForeground)
      P += iZoom
    Next
    
  Endif
  
End

Public Sub imvImage_Draw(hZoom As Image)
  
  Dim hStart As Point
  Dim hEnd As Point
  Dim hOffset As Point
  Dim bAnts As Boolean
  Dim bBalance As Boolean 
  Dim hImage As Image
  Dim hRect As Rect
  Dim X As Integer
  Dim Y As Integer
  Dim iGrid As Integer
  Dim W As Float
    
  If Project.ActiveForm = Me And If FImageProperty.HasBalance() Then bBalance = True
  
  hOffset = imvImage.ImageToView(Point(0, 0))
  
  If bBalance Then
    If Not $hSelect Or If $hSelect.IsVoid() Then
    
      hImage = hZoom.Copy()
      FImageProperty.ApplyBalance(hImage)
      'imvImage._Paint(hImage, hOffset.X, hOffset.Y)
      hZoom = hImage
      
    Endif
  Endif
  
  If $hStrokeImage Then
    Paint.Save
    If $sTool = "erase" Then
      PaintImage(hZoom, hOffset.X, hOffset.Y,, Rect(0, 0, hZoom.Width, $hStrokeExtents.Y))
      PaintImage(hZoom, hOffset.X, hOffset.Y,, Rect(0, $hStrokeExtents.Y, $hStrokeExtents.X, $hStrokeExtents.H))
      PaintImage(hZoom, hOffset.X, hOffset.Y,, Rect($hStrokeExtents.X + $hStrokeExtents.W, $hStrokeExtents.Y, hZoom.W - $hStrokeExtents.X - $hStrokeExtents.W, $hStrokeExtents.H))
      PaintImage(hZoom, hOffset.X, hOffset.Y,, Rect(0, $hStrokeExtents.Y + $hStrokeExtents.H, hZoom.Width, hZoom.H - $hStrokeExtents.Y - $hStrokeExtents.H))
      
      hImage = hZoom.Copy($hStrokeExtents.X, $hStrokeExtents.Y, $hStrokeExtents.W, $hStrokeExtents.H)
      Paint.Begin(hImage)
      Paint.Operator = Paint.OperatorDestOut
      Paint.DrawImage($hStrokeImage, 0, 0, $hStrokeExtents.W, $hStrokeExtents.H, FImageProperty.GetOpacity() / 255, $hStrokeExtents)
      Paint.End
      imvImage._Paint(hImage, hOffset.X + $hStrokeExtents.X * imvImage.Zoom, hOffset.Y + $hStrokeExtents.Y * imvImage.Zoom)
    Else
      imvImage._Paint(hZoom, hOffset.X, hOffset.Y)
      'imvImage._Paint($hStrokeImage, hOffset.X, hOffset.Y, FImageProperty.GetOpacity() / 255)
      PaintImage($hStrokeImage, hOffset.X, hOffset.Y, FImageProperty.GetOpacity() / 255, $hStrokeExtents)
    Endif
    Paint.Restore
  Else
    imvImage._Paint(hZoom, hOffset.X, hOffset.Y)
  Endif
  
  ' If $hMagic Then 
  ' 
  '   Paint.Save
  '   
  '   Paint.Translate(hOffset.X, hOffset.Y)
  '   Paint.Scale(imvImage.Zoom, imvImage.Zoom)
  '   
  '   Paint.DrawImage($hMagic, 0, 0)
  '   
  '   Paint.Restore
  '   
  ' Endif
  
  If $hSelect And If Not $hSelect.IsVoid() Then
    
    Paint.Save
  
    Paint.Translate(hOffset.X, hOffset.Y)
    Paint.Scale(imvImage.Zoom, imvImage.Zoom)
    
    If bBalance Then
      
      If $hSelect.IsInverted() Then
        hImage = hZoom.Copy()
      Else
        hRect = $hSelect.GetExtentsInt(True)
        If hRect.X < 0 Then
          hRect.W += hRect.X
          hRect.X = 0
        Endif
        If hRect.Y < 0 Then
          hRect.H += hRect.Y
          hRect.Y = 0
        Endif
        hImage = hZoom.Copy(hRect.X, hRect.Y, hRect.Width, hRect.Height)
      Endif
      
      FImageProperty.ApplyBalance(hImage)
      
      If $hSelect.IsInverted() Then
        Paint.Save
        Paint.Reset
        imvImage._Paint(hImage, hOffset.X, hOffset.Y)
        Paint.Restore
      Endif
      
      Paint.Save
      $hSelect.Paint($hImage, CImageSelection.ACTION_CLIP)
      Paint.Reset
      If $hSelect.IsInverted() Then
        imvImage._Paint(hZoom, hOffset.X, hOffset.Y)
      Else
        imvImage._Paint(hImage, hOffset.X + hRect.X * imvImage.Zoom, hOffset.Y + hRect.Y * imvImage.Zoom)
      Endif
      Paint.Restore
      
    Endif
    
    Paint.LineWidth = 1 / imvImage.Zoom
    Paint.DashOffset = - $fDashOffset
    
    $hSelect.Paint($hImage, CImageSelection.ACTION_SELECT, True)

    ' CImageSelection.PaintingSelection = True
    ' 
    ' Paint.LineWidth = 2 / imvImage.Zoom
    ' Paint.AntiAlias = False
    ' 'Paint.LineJoin = Paint.LineJoinRound
    ' 
    ' Paint.Background = Color.White 'Color.SetAlpha(Color.White, 128)
    ' Paint.Dash = Null
    ' $hSelect.Paint($hImage, CImageSelection.ACTION_STROKE, True)
    ' 
    ' Paint.Background = Color.Black 'Color.SetAlpha(Color.Black, 128)
    ' Paint.Dash = [2.0, 2.0]
    ' Paint.DashOffset = - $fDashOffset
    ' $hSelect.Paint($hImage, CImageSelection.ACTION_STROKE, True)
    ' 
    ' CImageSelection.PaintingSelection = False

    Paint.Restore
    
    bAnts = True
    
  Endif
  
  If $bShowGrid Then
    
    Paint.Save
    Paint.AntiAlias = False
  
    Paint.LineWidth = 1 / imvImage.Zoom

    Paint.Translate(hOffset.X, hOffset.Y)
    Paint.Scale(imvImage.Zoom, imvImage.Zoom)
      
    iGrid = FImageProperty.GetGridResolution()
      
    For X = iGrid To $hImage.W Step iGrid
      Paint.MoveTo(X, 0)
      Paint.LineTo(X, $hImage.H)
    Next
    
    For Y = iGrid To $hImage.H Step iGrid
      Paint.MoveTo(0, Y)
      Paint.LineTo($hImage.W, Y)
    Next
    
    Paint.Background = &H808080&
    Paint.Stroke
    
    Paint.Restore
    
  Endif
    
  If $hMagnet Then
    
    Paint.Save
    
    Paint.AntiAlias = False
    Paint.LineWidth = 1
    
    Paint.Translate($hMagnet.X * imvImage.Zoom + hOffset.X, $hMagnet.Y * imvImage.Zoom + hOffset.Y)
    
    Paint.Background = Color.White

    Paint.Rectangle(-5, -4, 9, 9)

    Paint.MoveTo(0, - imvImage.H)
    Paint.LineTo(0, imvImage.H)
    Paint.MoveTo(- imvImage.W, 0)
    Paint.LineTo(imvImage.W, 0)

    Paint.Stroke

    Paint.Background = Color.Black

    Paint.Rectangle(-4, -3, 7, 7)

    Paint.MoveTo(0, - imvImage.H)
    Paint.LineTo(0, imvImage.H)
    Paint.MoveTo(- imvImage.W, 0)
    Paint.LineTo(imvImage.W, 0)

    Paint.Dash = [2.0, 2.0]
    Paint.Stroke
    
    Paint.Restore
  
  Endif
    
  If $bFrame And If Not $bPress Then 
  
    Select Case $sTool
      
      Case "draw", "erase", "line"
        
        If Not $hLastPoint Then Return
        If Not $hCurrentPoint Then Return
        
        hStart = imvImage.ImageToView($hLastPoint)
        hEnd = imvImage.ImageToView($hCurrentPoint)
        
        If $sTool = "line" Then
          Paint.LineWidth = 1
          FImageProperty.PaintForStroke
          'Paint.AntiAlias = False
          Paint.LineJoin = Paint.LineJoinRound
        Else
          FImageProperty.PaintForStroke
          If $sTool = "erase" Then Paint.Background = Color.SetAlpha(Color.Gray, 128)
          Paint.LineWidth *= imvImage.Zoom
        Endif
        
        'Paint.Background = Color.SetAlpha(Color.White, 128)
        Paint.Dash = Null
        If Not Paint.Antialias Then Paint.Translate(imvImage.Zoom / 2, imvImage.Zoom / 2)
        Paint.MoveTo(hStart.X, hStart.Y)
        Paint.LineTo(hEnd.X, hEnd.Y)
        Paint.Stroke
        Paint.Reset
        
        ' Paint.Background = Color.SetAlpha(Color.Black, 128)
        ' Paint.Dash = [2.0, 2.0]
        ' Paint.DashOffset = - $fDashOffset
        ' If Not Paint.Antialias Then Paint.Translate(imvImage.Zoom / 2, imvImage.Zoom / 2)
        ' Paint.MoveTo(hStart.X, hStart.Y)
        ' Paint.LineTo(hEnd.X, hEnd.Y)
        ' Paint.Stroke
        ' Paint.Reset
        
        'bAnts = True
      
    End Select
    
  Endif
  
  If $hPaste Then
    
    Paint.Save
    
    'Paint.AntiAlias = False
    
    If $hSelect Then 
      Paint.Translate(hOffset.X, hOffset.Y)
      Paint.Scale(imvImage.Zoom, imvImage.Zoom)
      $hSelect.Paint($hImage, CImageSelection.ACTION_CLIP)
      Paint.Reset
      'imvImage._Paint($hPaste, hOffset.X + $iPasteX * imvImage.Zoom, hOffset.Y + $iPasteY * imvImage.Zoom)
    Endif
    
    With $hPasteSelect.GetExtents()
      If .Width > 0 And If .Height > 0 Then
        hImage = New Image(Ceil(.Width) + 1, Ceil(.Height) + 1, Color.Transparent)
        
        Paint.Begin(hImage)
        Paint.Brush = Paint.Image($hPaste)
        $hPasteSelect.Translate(- Floor(.X), - Floor(.Y))
        Paint.Brush.Matrix = $hPasteSelect._BrushMatrix.Copy()
        $hPasteSelect.Paint(hImage, CImageSelection.ACTION_FILL)
        $hPasteSelect.Translate(Floor(.X), Floor(.Y))
        Paint.End
      
        imvImage._Paint(hImage, hOffset.X + Floor(.X) * imvImage.Zoom, hOffset.Y + Floor(.Y) * imvImage.Zoom)
      Endif
    
    End With
    
    Paint.Restore
    
  Endif
  
  If $hChangeRect Then
    
    Paint.Save
    
    Paint.Translate(hOffset.X, hOffset.Y)
    Paint.Scale(imvImage.Zoom, imvImage.Zoom)
    
    Paint.LineWidth = 2 / imvImage.Zoom
    Paint.AntiAlias = True
    Paint.LineJoin = Paint.LineJoinRound
      
    If $sTool = "change" Then
      Paint.Background = Color.SetAlpha(Color.Red, 128)
      $hSelect.Paint($hImage, CImageSelection.ACTION_HANDLE)
      Paint.Background = Color.SetAlpha(Color.Blue, 128)
      $hSelect.Paint($hImage, CImageSelection.ACTION_MAGNET)
    Endif
    
    Paint.Background = Color.SetAlpha(Color.Red, 128)
    Paint.Dash = Null
    
    With $hChangeRect
      
      Paint.Rectangle(.X, .Y, .W, .H)
      Paint.Stroke
      
      'Paint.LineWidth = 1 / imvImage.Zoom
      ' Paint.MoveTo(.X + .W / 2, .Y + .H / 2)
      ' Paint.RelMoveTo(0, -4 / imvImage.Zoom)
      ' Paint.RelLineTo(0, 8 / imvImage.Zoom)
      ' Paint.RelMoveTo(-4 / imvImage.Zoom, -4 / imvImage.Zoom)
      ' Paint.RelLineTo(8 / imvImage.Zoom, 0)
      ' Paint.Stroke
      
    End With
    
    Paint.Background = Color.SetAlpha(Color.White, 128)
    Paint.Dash = [2.0, 2.0]
    Paint.DashOffset = 0
    Paint.Rectangle($hChangeRect.X, $hChangeRect.Y, $hChangeRect.W, $hChangeRect.H)
    Paint.Stroke
    
    Paint.Background = Color.SetAlpha(Color.Red, 128)
    Paint.Arc($hChangeRect.X + 0.5 / imvImage.Zoom, $hChangeRect.Y + 0.5 / imvImage.Zoom, 7 / imvImage.Zoom)
    Paint.Rectangle($hChangeRect.X + $hChangeRect.W + (0.5 - 6) / imvImage.Zoom, $hChangeRect.Y + $hChangeRect.H + (0.5 - 6) / imvImage.Zoom, 12 / imvImage.Zoom, 12 / imvImage.Zoom)
    Paint.Fill
    
    If $iChangeAction = CHANGE_POINT Or If $iChangeAction = CHANGE_INSERT Then
      
      Paint.Background = Color.SetAlpha(Color.White, 128)
      W = 3 / imvImage.Zoom
      If $iChangeAction = CHANGE_INSERT Then
        With ($hSelect.Shapes[$vChangeIndex[0]].Points[$vChangeIndex[1]] + $hSelect.Shapes[$vChangeIndex[0]].Points[$vChangeIndex[1] + 1]) / 2
          Paint.Rectangle(.X - W, .Y - W, W * 2, W * 2)
          Paint.Fill
        End With
      Else
        With $hSelect.Shapes[$vChangeIndex[0]].Points[$vChangeIndex[1]]
          Paint.Rectangle(.X - W, .Y - W, W * 2, W * 2)
          Paint.Fill
        End With
      Endif
      
    Endif
    
    Paint.Restore
      
  Endif
  
  If $iAngle Then
    
    hImage = hZoom.Rotate(Rad($iAngle))
    imvImage._Paint(hImage, hOffset.X + (hZoom.W - hImage.W) / 2 * imvImage.Zoom, hOffset.Y + (hZoom.H - hImage.H) / 2 * imvImage.Zoom)
    'imvImage._Paint(hImage, hOffset.X, hOffset.Y)
    
  Endif
  
  timSelect.Enabled = bAnts
  
End

Public Sub timSelect_Timer()

  Inc $fDashOffset
  If $fDashOffset >= 8 Then $fDashOffset = 0
  imvImage.Refresh

End

Public Sub btnInvert_Click()

  CreateSelection
  AddUndo($hSelect.Copy())
  $hSelect.Invert
  If $hSelect.IsVoid() Then ClearSelection
  RefreshSelection

End

Public Sub timCheckZoom_Timer()

  btnZoomFit_Click

End

Public Sub imvImage_Menu()

  Dim iGrid As Integer
  Dim hMenu As Menu

  Me.SetFocus
  
  If $hSelect And If $hSelect.Current >= 0 Then
    mnuShapeGrid.Visible = True
    iGrid = $hSelect.Shapes[$hSelect.Current].Grid
    For Each hMenu In mnuShapeGrid.Children
      hMenu.Checked = CInt(hMenu.Tag) = iGrid
    Next
  Else
    mnuShapeGrid.Visible = False
  Endif
  
  mnuEditor.Popup

End

Public Sub mnuSelectAll_Click()
  
  $hSelect = New CImageSelection
  btnInvert_Click

End

Public Sub btnCrop_Click()

  Dim hImage As Image
  Dim hRect As Rect
  Dim X As Integer
  Dim Y As Integer
  
  If $hSelect Then
    
    $hSelect.Invert
    
    hImage = $hImage.Copy()
    
    Paint.Begin(hImage)
    Paint.Brush = Paint.Color(Color.Black)
    $hSelect.Paint(hImage, CImageSelection.ACTION_CLEAR)
    Paint.End

    $hSelect.Invert

    If Not $hSelect.IsInverted() Then
      hRect = $hSelect.GetExtentsInt(True)
      If hRect Then hImage = hImage.Copy(hRect.X, hRect.Y, hRect.Width, hRect.Height)
    Endif
    
    BeginUndo
    AddUndo($hSelect.Copy())
    ClearSelection
    SetImage(hImage)
    EndUndo
    
  Else
    
    hRect = New Rect(0, 0, $hImage.W, $hImage.H)
    
    For X = 0 To $hImage.W - 1
      For Y = 0 To $hImage.H - 1
        If Color.GetAlpha($hImage[X, Y]) < 255 Then Break
      Next
      If Y < $hImage.H Then
        hRect.Left = X
        Break
      Endif
    Next
    
    For X = $hImage.W - 1 DownTo hRect.Left
      For Y = 0 To $hImage.H - 1
        If Color.GetAlpha($hImage[X, Y]) < 255 Then Break
      Next
      If Y < $hImage.H Then
        hRect.Right = X + 1
        Break
      Endif
    Next
    
    For Y = 0 To $hImage.H - 1
      For X = hRect.Left To hRect.Right
        If Color.GetAlpha($hImage[X, Y]) < 255 Then Break
      Next
      If X <= hRect.Right Then
        hRect.Top = Y
        Break
      Endif
    Next
    
    For Y = $hImage.H - 1 DownTo hRect.Top
      For X = hRect.Left To hRect.Right
        If Color.GetAlpha($hImage[X, Y]) < 255 Then Break
      Next
      If X <= hRect.Right Then
        hRect.Bottom = Y + 1
        Break
      Endif
    Next
    
    If Not hRect.IsVoid() Then
      If hRect.W < $hImage.W Or If hRect.H < $hImage.H Then
        BeginUndo
        AddUndo($hImage.Copy())
        SetImage($hImage.Copy(hRect.X, hRect.Y, hRect.W, hRect.H))
        EndUndo
      Endif
    Endif
    
  Endif

End

Private Sub BeginUndo()

  $aUndo.Add(BEGIN_UNDO)
  $aRedo.Clear

End

Private Sub EndUndo()
  
  Dim vUndo As Variant = $aUndo[$aUndo.Max]
  
  If TypeOf(vUndo) = gb.Integer And If vUndo = BEGIN_UNDO Then
    $aUndo.Pop()
  Else
    $aUndo.Add(END_UNDO)
  Endif
  
  $aRedo.Clear
  
End

' Fast Private Sub CheckPoint(iCol As Integer, X2 As Integer, Y2 As Integer, A0 As Integer) As Boolean
' 
'   Dim R, G, B, A As Float
'   Dim R2, G2, B2, A2 As Float
'   Dim N As Integer
'   Dim F As Float
'   Dim D As Integer
'   
'   'R = $R / $N
'   'G = $G / $N
'   'B = $B / $N
'   'A = $A / $N
'   
'   With Color[iCol]
'     R = .Red
'     G = .Green
'     B = .Blue
'     A = .Alpha
'   End With
'   
'   With Color[$hImage[X2, Y2]]
'     F = (255 - .Alpha) / 255
'     R2 = .Red * F
'     G2 = .Green * F
'     B2 = .Blue * F
'     A2 = .Alpha
'     N = 1
'   End With
'   
'   ' If X2 > 0 Then
'   '   With Color[$hImage[X2 - 1, Y2]]
'   '     F = (255 - .Alpha) / 255
'   '     R2 += .Red * F
'   '     G2 += .Green * F
'   '     B2 += .Blue * F
'   '     A2 += .Alpha
'   '     Inc N
'   '   End With
'   ' Endif
'   ' 
'   ' If X2 < ($hImage.W - 1) Then
'   '   With Color[$hImage[X2 + 1, Y2]]
'   '     F = (255 - .Alpha) / 255
'   '     R2 += .Red * F
'   '     G2 += .Green * F
'   '     B2 += .Blue * F
'   '     A2 += .Alpha
'   '     Inc N
'   '   End With
'   ' Endif
'   ' 
'   ' If Y2 > 0 Then
'   '   With Color[$hImage[X2, Y2 - 1]]
'   '     F = (255 - .Alpha) / 255
'   '     R2 += .Red * F
'   '     G2 += .Green * F
'   '     B2 += .Blue * F
'   '     A2 += .Alpha
'   '     Inc N
'   '   End With
'   ' Endif
'   ' 
'   ' If Y2 < ($hImage.W - 1) Then
'   '   With Color[$hImage[X2, Y2 + 1]]
'   '     F = (255 - .Alpha) / 255
'   '     R2 += .Red * F
'   '     G2 += .Green * F
'   '     B2 += .Blue * F
'   '     A2 += .Alpha
'   '     Inc N
'   '   End With
'   ' Endif
'   ' 
'   ' R2 /= N
'   ' G2 /= N
'   ' B2 /= N
'   ' A2 /= N
'   
'   A0 = A0 * 1.1
'   D = Max(Max(Abs(R2 - R), Abs(G2 - G)), Max(Abs(B2 - B), Abs(A2 - A))) + A0
'   'Print X2;; Y2;; D
'   If D >= 255 Then Return
'   
'   '$R += R2
'   '$G += G2
'   '$B += B2
'   '$A += A2
'   Inc $N
' 
'   $hMagic[X2, Y2] = Color.SetAlpha(Color.Black, D)
'   '$hImage[X2, Y2] = Color.Blend($hImage[X2, Y2], $hMagic[X2, Y2])
'   If ($N And 1023) = 0 Then 
'     imvImage.Refresh
'     Wait
'   Endif
' 
'   Return True
' 
' End
' 
' Fast Private Sub MagicWand()
' 
'   Dim aPoint As New Integer[]
'   Dim X, Y, X2, Y2, A As Integer
'   Dim hImage As Image
'   
'   $iTol = 1 'FImageProperty.GetTolerance()
'   
'   $hMagic = New Image($hImage.W, $hImage.H, Color.White)
'   
'   aPoint.Add($hLastPoint.X)
'   aPoint.Add($hLastPoint.Y)
'   
'   With Color[$hImage[$hLastPoint.X, $hLastPoint.Y]]
'     $R = .Red * (255 - .Alpha) / 255
'     $G = .Green * (255 - .Alpha) / 255
'     $B = .Blue * (255 - .Alpha) / 255
'     $A = .Alpha
'     $N = 1
'   End With
'   
'   $hMagic[$hLastPoint.X, $hLastPoint.Y] = Color.Black
'   
'   While aPoint.Count
'     
'     X = aPoint[0]
'     Y = aPoint[1]
'     aPoint.Remove(0, 2)
'     
'     A = Color.GetAlpha($hMagic[X, Y])
'     
'     X2 = X + 1
'     Y2 = Y
'     GoSub LOOK_POINT
'     X2 = X + 1
'     Y2 = Y + 1
'     GoSub LOOK_POINT
'     X2 = X
'     Y2 = Y + 1
'     GoSub LOOK_POINT
'     X2 = X - 1
'     Y2 = Y + 1
'     GoSub LOOK_POINT
'     X2 = X - 1
'     Y2 = Y
'     GoSub LOOK_POINT
'     X2 = X - 1
'     Y2 = Y - 1
'     GoSub LOOK_POINT
'     X2 = X
'     Y2 = Y - 1
'     GoSub LOOK_POINT
'     X2 = X + 1
'     Y2 = Y - 1
'     GoSub LOOK_POINT
'     
'   Wend
'   
'   hImage = $hImage.Copy()
'   $hMagic.Replace(Color.White, Color.Transparent)
'   '$hMagic = $hMagic.Fuzzy(1)
'   hImage.PaintImage($hMagic, 0, 0)
'   SetImage(hImage)
'   $hMagic = Null
'   Return
'   
' LOOK_POINT:
' 
'   If X2 < 0 Or If Y2 < 0 Or If X2 >= $hImage.W Or If Y2 >= $hImage.H Then Return
'   If $hMagic[X2, Y2] <> Color.White Then Return
'   
'   If CheckPoint($hImage[X, Y], X2, Y2, A) Then
'     aPoint.Add(X2)
'     aPoint.Add(Y2)
'   Endif
'   
'   Return
'   
' End

Public Sub btnZoomFit_Click()

  Dim iIndex As Integer
  Dim fZoom As Float
  
  For iIndex = 0 To cmbZoom.Count - 1
    
    fZoom = CFloat(String.Left(cmbZoom[iIndex].Text, -1))
    If ($hImage.W * fZoom) > imvImage.W Or If ($hImage.H * fZoom) > imvImage.H Then Break
    
  Next
  
  cmbZoom.Index = Max(0, iIndex - 1)

End

Public Sub btnCopy_Click()

  Dim hImage As Image
  Dim hExt As Rect
  
  If $hSelect Then
    
    $hSelect.Invert
    
    hImage = $hImage.Copy()
    
    Paint.Begin(hImage)
    Paint.Brush = Paint.Color(Color.Black)
    $hSelect.Paint(hImage, CImageSelection.ACTION_CLEAR)
    Paint.End

    $hSelect.Invert

    If Not $hSelect.IsInverted() Then
      hExt = $hSelect.GetExtentsInt(True)
      If hExt Then hImage = hImage.Copy(hExt.X, hExt.Y, hExt.Width, hExt.Height)
    Endif
    
    Inc $iClipboard
    FImageProperty.AddClipboard(hImage, Me.Name & " [" & CStr($iClipboard) & "]")
    Clipboard.Copy(hImage)
    
  Else
    
    FImageProperty.AddClipboard($hImage.Copy(), Me.Name)
    Clipboard.Copy($hImage)
    
  Endif

End

Public Sub btnCut_Click()

  Dim hImage As Image

  BeginUndo

  btnCopy_Click

  If $hSelect Then
    
    hImage = $hImage.Copy()
    Paint.Begin(hImage)
    $hSelect.Paint($hImage, CImageSelection.ACTION_CLEAR)
    Paint.End
    SetImage(hImage)
    
  Else
    
    hImage = New Image($hImage.W, $hImage.H, Color.Transparent)
    SetImage(hImage)
    
  Endif

  ClearSelection

  EndUndo
  
  btnPaste.Value = True

End

Private Sub DoPaste()

  Dim hImage As Image
  
  If Not $hPaste Then Return
  
  hImage = $hImage.Copy()
  Paint.Begin(hImage)

  If $hSelect Then $hSelect.Paint($hImage, CImageSelection.ACTION_CLIP)
  
  Paint.Brush = Paint.Image($hPaste) ', ($hImage.W - $hPaste.W) \ 2, ($hImage.H - $hPaste.H) \ 2)
  Paint.Brush.Matrix = $hPasteSelect._BrushMatrix.Copy()
  $hPasteSelect.Paint(hImage, CImageSelection.ACTION_FILL)
  
  Paint.End
  
  SetImage(hImage)
  ClearPaste
  SetTool("paste")
  
End

Public Sub Form_Activate()

  If Not $bFirstTime Then 
    btnZoomFit_Click
    $bFirstTime = True
  Endif

End

Public Sub RefreshSelection()
  
  imvImage.Refresh
  If $sTool = "change" Then 
    If Not $hSelect Or If $hSelect.IsVoid() Then 
      $hChangeRect = Null
    Else
      $hChangeRect = $hSelect.GetExtents()
    Endif
  Endif
  
End

Public Sub imvImage_Leave()

  $iChangeAction = CHANGE_NOTHING
  FImageProperty.UpdateInfo("")

End

Public Sub ApplyEffect(iEffect As Integer)
  
  Dim hImage As Image
  Dim hEffect As Image
  
  Select Case iEffect
    
    Case EFFECT_BALANCE
      
      hEffect = $hImage.Copy()
      FImageProperty.ApplyBalance(hEffect)
    
    Case EFFECT_COLORIZE
    
      hEffect = $hImage.Copy().Colorize(FImageProperty.GetColor(True))
      
    Case EFFECT_DESATURATE
    
      hEffect = $hImage.Copy().Desaturate()
      
    Case EFFECT_TRANSPARENT
    
      hEffect = $hImage.Copy().Erase()
      
  End Select
  
  If $hSelect Then

    If $hSelect.IsInverted() Then
      
      Paint.Begin(hEffect)
      $hSelect.Paint(hEffect, CImageSelection.ACTION_CLIP)
      Paint.DrawImage($hImage, 0, 0)
      Paint.End
      
      hImage = hEffect
      
    Else
    
      hImage = $hImage.Copy()
      
      Paint.Begin(hImage)
      $hSelect.Paint(hImage, CImageSelection.ACTION_CLIP)
      Paint.DrawImage(hEffect, 0, 0)
      Paint.End

    Endif

  Else
    
    hImage = hEffect
    
  Endif
  
  SetImage(hImage)
    
End

Public Sub ApplyBalance()
  
  ApplyEffect(EFFECT_BALANCE)
  
End


Public Sub OnProjectDebug()

  SetReadOnly

End

Private Sub UpdateMenu()

  Dim bVisible As Boolean

  bVisible = Not $bReadOnly

  If $bReadOnly Then SetTool("move")

  mnuAction.Visible = bVisible
  mnuSelection.Visible = bVisible
  
  Action[".save,.undo,.redo,.tool-*,.hide,.invert,.stroke,.fill,.clear,.cut,.paste,.crop,.flip-h,.flip-v,.rotate-*,.rotate,.resize,.select-all,.duplicate,.offset", Me].Visible = bVisible
  
End

Public Sub mnuHideSelection_Click()
  
  If $hSelect Then
    ClearSelection
  Else If $hPaste Then
    ClearPaste
    SetTool("paste")
  Else
    FMain.HidePanels
  Endif

End

Public Sub mnuPaste_Click()
  
  SetTool("paste")
  
End


Public Sub tlbMain_Configure()

  UpdateMenu

End

Public Sub btnRotate_Click()

  If FImageRotate.Run(Me) Then 
    imvImage.Update($hImage)
    Return
  Endif
  SetImage($hImage.Rotate(Rad(FImageRotate.Angle)))

End

Public Sub UpdateRotation(iAngle As Integer)
  
  '$iAngle = iAngle
  imvImage.Update($hImage.Rotate(Rad(iAngle)))
  
End

Public Sub Form_GotFocus()

  imvImage.SetFocus

End

Public Sub imvImage_GotFocus()

  Project.SetCurrentPopup(mnuEditor)

End

Public Sub mnuClose_Click()
  
  Me.Close
  
End

Public Sub PasteShape(hShape As CImageSelection)
  
  Dim S As Float
  
  If btnEditSelection.Value Then
    SetTool("change")
  Else
    btnEditSelection.Value = True
  Endif
  
  BeginUndo
  
  CreateSelection
  
  hShape = hShape.Copy()
  With hShape.GetExtents()
    S = Min(imvImage.ScrollW / imvImage.Zoom * 0.25 / .W, imvImage.ScrollH / imvImage.Zoom * 0.25 / .H)
    hShape.Translate($hImage.W / 2, $hImage.H / 2)
    hShape.Scale(S, S)
  End With
  
  $hSelect.Select($hSelect.AddSelection(hShape))
  
  RefreshSelection
  
  EndUndo
  
End

Public Sub UpdateBalance()
  
  If $hPaste Then $hPaste = FImageProperty.GetClipboard()
  imvImage.Refresh
  
End

Public Sub UpdateClipboard()
  
  If $sTool = "paste" Then 
    ClearPaste
    SetTool("paste")
  Endif
  
End


Public Sub btnGrid_Click()

  $bShowGrid = Not $bShowGrid
  imvImage.Refresh
  FImageProperty.ShowGridOption($bShowGrid)

End

Public Sub UpdateGrid()
  
  imvImage.Refresh
  
End


Public Sub btnDuplicate_Click()

  If $hSelect Then
    
    AddUndo($hSelect.Copy())
    $hSelect.Duplicate
    RefreshSelection
    
  Endif

End

Public Sub btnOffset_Click()

  If Not $hSelect Then Return
  
  If FImageOffsetSelection.Run() Then Return
  
  AddUndo($hSelect.Copy())
  $hSelect.Offset(FImageOffsetSelection.Size, FImageOffsetSelection.Duplicate)
  RefreshSelection

End

Public Sub GetImageInfo() As String
  
  Return CStr($hImage.Width) & " x " & CStr($hImage.Height) & " (" & Util.GetFileSize($hImage.Width * $hImage.Height * 4) & ")"
  
End

Fast Private Sub CreateSelectionFromMask(hImage As Image) As Polygon[]
  
  Dim X, Y As Integer
  Dim CW, CB As Integer
  Dim I As Integer
  Dim W As Integer
  Dim hPoly As Polygon
  Dim aPoly As New Polygon[]
  
  CW = Color.White
  CB = Color.Black
  
  For Y = 0 To hImage.H - 1
    For X = 0 To hImage.W - 1
      
      If hImage[X, Y] <> CB Then Continue
      
      W = 1
      For I = X + 1 To hImage.W - 1
        If hImage[I, Y] <> CB Then Break
        Inc W
      Next
      
      hPoly = New Polygon
      hPoly.Add(X, Y)
      hPoly.Add(X + W, Y)
      hPoly.Add(X + W, Y + 1)
      hPoly.Add(X, Y + 1)
      aPoly.Add(hPoly)
      
      X = I
      
    Next
  Next
  
  aPoly = Clipper.Simplify(aPoly, Clipper.FillWinding)
  aPoly = Clipper.Clean(aPoly)
  Return aPoly
  
End

Fast Private Sub CreateMask() As Image
  
  Dim hMask As Image
  Dim aPoint As New Integer[]
  Dim X, X1, X2, Y, XL, XR As Integer
  Dim WW, HH As Integer
  Dim C As Integer
  Dim fTolerance As Float
  
  WW = $hImage.W
  HH = $hImage.H
  
  X = $hLastPoint.X
  Y = $hLastPoint.Y
  
  If X < 0 Or If Y < 0 Or If X >= WW Or If Y >= HH Then Return
  
  fTolerance = FImageProperty.GetTolerance() / 255
  
  hMask = New Image(WW, HH, Color.White)
  
  Dec WW
  Dec HH
  
  aPoint.Add(X)
  aPoint.Add(X)
  aPoint.Add(Y)
  C = $hImage[X, Y]
  
  While aPoint.Count
    
    Y = aPoint.Pop()
    X2 = aPoint.Pop()
    X1 = aPoint.Pop()
    
    For X = X1 To X2
    
      ' I = hMask[X, Y]
      ' hMask[X, Y] = Color.Green
      ' imvImage.Update(hMask)
      ' Wait
      ' hMask[X, Y] = I
  
      If hMask[X, Y] = Color.Black Then Continue
      If Color.Distance($hImage[X, Y], C) > fTolerance Then Continue
      'hMask[X, Y] = Color.Black
      
      For XL = X - 1 DownTo 0
        If Color.Distance($hImage[XL, Y], C) > fTolerance Then Break
      Next
      Inc XL
      
      For XR = X + 1 To WW
        If Color.Distance($hImage[XR, Y], C) > fTolerance Then Break
      Next
      Dec XR
      
      hMask.FillRect(XL, Y, XR - XL + 1, 1, Color.Black)
      ' imvImage.Update(hMask)
      ' Wait 0.1
      
      If Y Then
        aPoint.Add(XL)
        aPoint.Add(XR)
        aPoint.Add(Y - 1)
      Endif
      
      If Y < HH Then
        aPoint.Add(XL)
        aPoint.Add(XR)
        aPoint.Add(Y + 1)
      Endif
      
    Next
    
  Wend
  
  Return hMask
  
End


Private Sub MagicWand()

  Dim hMask As Image
  Dim aPoly As Polygon[]
  Dim hPoly As Polygon
  Dim hShape As CImageShape
  
  Inc Application.Busy
  
  hMask = CreateMask()
  
  If hMask Then
    aPoly = CreateSelectionFromMask(hMask)
    aPoly = Clipper.Simplify(aPoly, Clipper.FillWinding)
    
    For Each hPoly In aPoly
      hShape = New CImageShape
      hShape.Points = hPoly
      $hSelect.AddShape(hShape)
    Next
  Endif
  
  Dec Application.Busy

End

Private Sub ClearPaste()

  If $hPaste Then
    $hPaste = Null
    $hPasteSelect = Null
    $hPasteCurrent = Null
    $hChangeRect = Null
    imvImage.Refresh
    $iChangeAction = CHANGE_NOTHING
  Endif

End

Public Sub mnuDivide_Click()
  
  If Not $hSelect Then Return
  If $hSelect.Current < 0 Then Return
  
  $hSelect.Shapes[$hSelect.Current].Grid = CInt(Last.Tag)
  imvImage.Refresh
  
End

Private Sub GetCurrentFormat() As String

  Dim sFormat As String = Lower(File.Ext(Path))
  
  Select Case sFormat
    Case "jpg"
      Return "jpeg"
    Default
      Return sFormat
  End Select

End

Public Sub mnuFormat_Show()
  
  Dim sFormat As String = GetCurrentFormat()
  Dim hMenu As Menu
  
  For Each hMenu In mnuFormat.Children
    hMenu.Checked = hMenu.Tag = sFormat
  Next
  
  ' If sFormat = "jpeg" Or If sFormat = "png" Then
  '   mnuQuality.Enabled = True
  ' Else
  '   mnuQuality.Enabled = False
  ' Endif
  
End


Public Sub mnuSaveAs_Click()
  
  Dim sFormat As String = Last.Tag
  
  If sFormat <> GetCurrentFormat() Then
    
    Project.RenameFile(Path, File.SetExt(File.Name(Path), sFormat))
    Me.Save(True)
    
  Endif
  
End

Public Sub ReadConfig()
  
  Project.SetSmallFont(tlbMain)
  
End

Public Sub btnHide_Click()

  ClearSelection

End

Public Sub UpdateText(sText As String, sFont As String, iAlign As Integer, bAlignBase As Boolean)
  
  $hSelect = $hTextSelect.Copy()
  $hSelect.Text($hLastPoint.X, $hLastPoint.Y, sText, sFont, iAlign, bAlignBase)
  imvImage.Refresh
  
End

Public Sub imvImage_MouseWheel()

  If Mouse.Forward Then
    btnZoomIn_Click
  Else
    btnZoomOut_Click
  Endif
  Stop Event

End

Public Sub HasGrid() As Boolean
  
  Return $bShowGrid
  
End

Public Sub GetTool() As String
  
  Return $sTool
  
End

Public Sub Action_Activate((Key) As String) As Boolean
  
  Select Case Key
    Case ".locked"
      Project.SetReadOnly(Path, Action[Key, Me].Value)
    Case Else
      Return True
  End Select
  
End

Public Sub Form_Close()

  Project.AddRecentFile(Me)

End

Public Sub ExecAction(sAction As String)
  
  Dim hImage As Image

  Select Case sAction
    
    Case "stroke"
    
      If $hSelect Then
        
        hImage = $hImage.Copy()
        Paint.Begin(hImage)
        FImageProperty.PaintForStroke($hSelect.GetExtents(True))
        $hSelect.Paint($hImage, CImageSelection.ACTION_STROKE)
        Paint.End
        SetImage(hImage)
        
      Endif
    
    Case "fill"
    
      hImage = $hImage.Copy()
      Paint.Begin(hImage)
      If $hSelect Then
        FImageProperty.PaintForFill($hSelect.GetExtents(True))
        $hSelect.Paint($hImage, CImageSelection.ACTION_FILL)
      Else
        FImageProperty.PaintForFill()
        Paint.Rectangle(0, 0, hImage.W, hImage.H)
        Paint.Fill
      Endif
      Paint.End
      SetImage(hImage)
      
    Case "clear"
      
      If $hSelect Then
        
        hImage = $hImage.Copy()
        Paint.Begin(hImage)
        FImageProperty.PaintForFill
        $hSelect.Paint($hImage, CImageSelection.ACTION_CLEAR)
        Paint.End
        SetImage(hImage)
        
      Else
        
        hImage = New Image($hImage.W, $hImage.H, Color.Transparent) '$hImage.Copy()
        'hImage.Transparent(FImageProperty.GetColor(True))
        SetImage(hImage)
        
      Endif
    
    Case "colorize"
      ApplyEffect(EFFECT_COLORIZE)
    
    Case "desaturate"
      ApplyEffect(EFFECT_DESATURATE)
    
    Case "transparent"
      ApplyEffect(EFFECT_TRANSPARENT)
    
  End Select
  
End
