' Gambas class file

Public Path As String

Property Read ReadOnly As Boolean

Private $hImage As Image
Private $iScale As Integer
Private $iScale1 As Integer

Private $bModify As Boolean
Private $bReadOnly As Boolean

Private $X As Integer
Private $Y As Integer
Private $X2 As Integer
Private $Y2 As Integer
Private $iColor As Integer

Private $bGhost As Boolean

Private Const MAX_UNDO As Integer = 32
Private $hUndo As New Image[32]
Private $iUndo As Integer

Private Const WIDTH_SEL As Integer = 4

Private $bSelect As Boolean
Private $bPrivate As Boolean
Private $XS As Integer
Private $YS As Integer
Private $WS As Integer
Private $HS As Integer

Private $hPaste As Image

Private Const COORD_HIDE As Integer = 1048576
Private $XD As Integer
Private $YD As Integer

Static Private $aZoom As Integer[]
Static Private $iMaxW As Integer
Static Private $iMaxH As Integer
Static Private $hTile As Picture

Static Private $cColor As New Integer[]

'PRIVATE $hCurrent AS FIconEditor

Private $sTool As String

Private $hTool As ToolButton
Private $hLast As ToolButton
Private $hMode As ToolButton
Private $hTrans As ToolButton
Private $bIgnoreClick As Boolean

Private $iForeground As Integer
Private $iBackground As Integer
Private $iMode As Integer
Private $bTrans As Boolean

Private $iMouse As Integer

Private $iBeginUndo As Integer

Private $bNoPreview As Boolean

Static Public Sub _init()

  Dim sColor As String

  $aZoom = [1, 2, 4, 6, 8, 12, 16, 24]
  $hTile = Picture["img/16/tile.png"]

  For Each sColor In Split("000000,FFFFFF,0000FF,00FF00,FF0000,00FFFF,FFFF00,FF00FF,7F7F7F,BFBFBF,00007F,007F00,7F0000,007F7F,7F7F00,7F007F,3F3F3F,FF8000,43C7FF")
    $cColor.Add(Val("&H" & sColor & "&"))
  Next

End


Public Sub _new(sPath As String)

  Dim sText As String
  Dim iScale As Integer
  Dim iColor As Integer
  Dim hColor As DrawingArea
  Dim hCtrl As Control

  Path = sPath
  Me.Name = File.Name(sPath) 'Mid$(sPath, Len(File.Dir(Project.Path)) + 1)

  $iMaxW = Me.Width
  $iMaxH = Me.Height

  For Each iScale In $aZoom
    cmbZoom.Add(iScale & " x")
  Next

  For iColor = 0 To $cColor.Max + 1
    hColor = New DrawingArea(tlbColor) As "dwgColor"
    hColor.Resize(24, 24)
    hColor.Tag = iColor
  Next

  Reload
  
  $iScale = 1  
  For Each iScale In $aZoom
    If ($hImage.Width * iScale) > (Project.Workspace.ClientWidth * 0.75) Or ($hImage.Height * iScale) > (Project.Workspace.ClientHeight * 0.75) Then Break
    $iScale = iScale
  Next

  SetBackground(Color.White)
  SetForeground(Color.Black)

  SetTransparent(True)
  SetMode(0)
  SetTool(btnMove)
  SetReadOnly

End

Private Sub SetReadOnly()

  Dim hCtrl As Control  

  $bReadOnly = False
  If Project.ReadOnly Or If Project.Running Or If Project.IsReadOnly(Path) Then
    $bReadOnly = True
  Endif

  For Each hCtrl In panToolbar.Children
    If hCtrl.Name = "tlbMove" Then Continue
    hCtrl.Visible = Not $bReadOnly
  Next

End

Public Sub LoadFile() As Boolean

  dwgPreview.Resize($hImage.W + 8, $hImage.H + 8)
  panPreview.Dimension = dwgPreview.W + 8
  
  RefreshZoom

End


Public Sub dwgIcon_Draw()

  Dim X As Integer
  Dim Y As Integer
  Dim XR As Integer
  Dim YR As Integer
  Dim SX As Integer
  Dim SY As Integer
  Dim DX As Integer
  Dim DY As Integer
  Dim C As Integer
  Dim W As Integer

  Dim hZoom As Image

  If Not $hImage Then Return

  Draw.LineStyle = Line.None
  'Draw.FillStyle = Fill.CrossDiagonal
  'Draw.FillColor = 0
  'Draw.Rect(Draw.Clip.X, Draw.Clip.Y, Draw.Clip.W, Draw.Clip.H)
  Draw.FillStyle = Fill.Solid
  'Draw.Tile($hTile, Draw.Clip.X, Draw.Clip.Y, Draw.Clip.W, Draw.Clip.H)

  SX = Draw.Clip.X \ $iScale
  SY = Draw.Clip.Y \ $iScale
  DX = (Draw.Clip.X + Draw.Clip.W - 1) \ $iScale
  DY = (Draw.Clip.Y + Draw.Clip.H - 1) \ $iScale

  SX = Max(0, SX)
  DX = Min($hImage.Width - 1, DX)

  SY = Max(0, SY)
  DY = Min($hImage.Height - 1, DY)

  If $iScale > 5 Then
    Draw.LineStyle = Line.Solid
    Draw.Foreground = &H989898
  Else
    Draw.LineStyle = Line.None
  Endif

  Draw.Zoom($hImage, $iScale, SX * $iScale, SY * $iScale, SX, SY, DX - SX + 1, DY - SY + 1)

  If $bGhost Then DrawGhost(True)

End


Public Sub dwgPaste_Draw()

  Dim X As Integer
  Dim Y As Integer
  Dim XR As Integer
  Dim YR As Integer
  Dim SX As Integer
  Dim SY As Integer
  Dim DX As Integer
  Dim DY As Integer
  Dim C As Integer
  Dim CP As Integer
  Dim W As Integer
  Dim hTemp As Image

  If Not $hPaste Then Return

  Draw.FillX = Draw.FillX - $XS * $iScale
  Draw.FillY = Draw.FillY - $YS * $iScale

  Draw.LineStyle = LINE.None
  'Draw.FillStyle = Fill.CrossDiagonal
  'Draw.FillColor = 0
  'Draw.Rect(Draw.Clip.X, Draw.Clip.Y, Draw.Clip.W, Draw.Clip.H)
  Draw.FillStyle = Fill.Solid

  'Draw.Tile($hTile, Draw.Clip.X, Draw.Clip.Y, Draw.Clip.W, Draw.Clip.H)

  If $iScale > 5 Then
    Draw.LineStyle = Line.Solid
    Draw.Foreground = &H989898
    W = $iScale1
  Else
    Draw.LineStyle = LINE.None
    W = $iScale
  Endif

  SX = Draw.Clip.X \ $iScale
  SY = Draw.Clip.Y \ $iScale
  DX = (Draw.Clip.X + Draw.Clip.W - 1) \ $iScale
  DY = (Draw.Clip.Y + Draw.Clip.H - 1) \ $iScale

  SX = Max(0, SX)
  DX = Min($hPaste.Width - 1, DX)

  SY = Max(0, SY)
  DY = Min($hPaste.Height - 1, DY)

  If $bTrans Then

    hTemp = $hImage.Copy($XS, $YS, $hPaste.Width, $hPaste.Height)
    hTemp.Draw($hPaste, 0, 0)
    'Draw.Zoom($hImage, $iScale, SX * $iScale, SY * $iScale, SX + $XS, SY + $YS, DX - SX + 1, DY - SY + 1)
    Draw.Zoom(hTemp, $iScale, SX * $iScale, SY * $iScale, SX, SY, DX - SX + 1, DY - SY + 1)

  Else

    Draw.Zoom($hPaste, $iScale, SX * $iScale, SY * $iScale, SX, SY, DX - SX + 1, DY - SY + 1)

  Endif

  Draw.FillStyle = Fill.None
  Draw.LineStyle = Line.Dot
  Draw.LineWidth = 3
  Draw.Foreground = Color.Black
  Draw.Background = Color.White
  Draw.Transparent = False
  'Draw.Invert = TRUE
  Draw.Rect(1, 1, dwgPaste.Width - 2, dwgPaste.Height - 2)

End


Private Sub DrawTitle()

  Project.DrawTitle(Me)

End


Private Sub RefreshCoord(X As Integer, Y As Integer)

  If X <> $XD Or Y <> $YD Then
    $XD = X
    $YD = Y
    'DrawTitle
    If $XD <> COORD_HIDE And $YD <> COORD_HIDE Then
      lblCoord.Text = $XD & ":" & $YD
    Else 
      lblCoord.Text = ""
    Endif 
  Endif

End

Private Sub HideCoord()
  
  RefreshCoord(COORD_HIDE, COORD_HIDE)
  
End


Public Function IsModified() As Boolean

  Return $bModify

End


Public Sub Rename(sNewName As String, sNewPath As String)

  ' Incoh√©rent avec l'initialisation de Name dans _new
  Me.Name = sNewName
  Path = sNewPath 'File.Dir(Path) &/ sNewName '& "." & File.Ext(Path)
  DrawTitle

End


Public Function Save() As Boolean

  If Project.ReadOnly Then Return
  If $bReadOnly Then Return
  If Not $bModify Then Return

  'PRINT "Picture not saved"

  HideSelection

  Save.Begin(Path)

  $hImage.Save(Path)

  'Project.RefreshKey(Path)

  $bModify = False
  DrawTitle
  Save.End()

Catch

  Return Save.Error()

End

Public Sub dwgIcon_MouseDown()

  Dim X As Integer
  Dim Y As Integer

  X = Mouse.X
  Y = Mouse.Y

  'WITH FIconTool

    Select $sTool

      Case "move"
        $X = Mouse.ScreenX + svwIcon.ScrollX
        $Y = Mouse.ScreenY + svwIcon.ScrollY

      Case "pen"
        SetUndo
        $X = -1
        $Y = -1
        $iColor = GetColor(Mouse.Button)
        dwgIcon_MouseMove()

      Case "line", "rect", "circle", "fill", "fill-alt"
        SetUndo
        $X = X \ $iScale
        $Y = Y \ $iScale
        $X2 = $X
        $Y2 = $Y
        $iColor = GetColor(Mouse.Button)

      Case "select"

        BeginUndo
        $X = X \ $iScale
        $Y = Y \ $iScale
        $X2 = $X
        $Y2 = $Y

        '$bSelect = FALSE
        'RefreshSelect

      Case "pipette"
        X = X \ $iScale
        Y = Y \ $iScale

        If Mouse.Left Then SetForeground($hImage[X, Y])
        If Mouse.Right Then SetBackground($hImage[X, Y])

    End Select

    DrawGhost

    Select $sTool

      Case "line", "rect", "circle"
        dwgIcon_MouseMove()

    End Select

  'END WITH

End

Public Sub dwgIcon_MouseMove()

  Dim C As Integer
  Dim X As Integer
  Dim Y As Integer
  Dim NX As Integer
  Dim NY As Integer

  X = Mouse.X
  Y = Mouse.Y

  'WITH FIconTool

    RefreshCoord(X \ $iScale, Y \ $iScale)

    If Not (Mouse.Left Or Mouse.Right) Then Return

    DrawGhost

    If $sTool <> "move" Then

      UpdateScroll(X, Y)

    Endif

    X = X \ $iScale
    Y = Y \ $iScale

    Select $sTool

      Case "move"
        svwIcon.Scroll($X - Mouse.ScreenX, $Y - Mouse.ScreenY)

      Case "pen"
        If X <> $X Or Y <> $Y Then
          If $X < 0 And $Y < 0 Then
            DrawPoint(X, Y, $iColor)
          Else
            DrawLine($X, $Y, X, Y, $iColor)
          Endif
          $X = X
          $Y = Y
        Endif

      Case "line", "rect", "circle", "select"
        If X <> $X2 Or Y <> $Y2 Then
          $X2 = X
          $Y2 = Y
          If $sTool = "select" Then
            HideSelection
            $bSelect = True
          Endif
        Endif

    End Select

    DrawGhost

  'END WITH

End


Public Sub dwgIcon_MouseUp()

  'WITH FIconTool

    DrawGhost

    Select Case $sTool

      Case "pipette"
        RevertTool

      Case "line"
        DrawLine($X, $Y, $X2, $Y2, $iColor)

      Case "rect"
        DrawRect(Min($X, $X2), Min($Y, $Y2), Abs($X - $X2) + 1, Abs($Y - $Y2) + 1, $iColor)

      Case "circle"
        DrawEllipse(Min($X, $X2), Min($Y, $Y2), Abs($X - $X2) + 1, Abs($Y - $Y2) + 1, $iColor)

      Case "select"
        If $X2 <> $X Or $Y2 <> $Y Then
          $X = Max(0, Min($hImage.Width - 1, $X))
          $Y = Max(0, Min($hImage.Height - 1, $Y))
          $X2 = Max(0, Min($hImage.Width - 1, $X2))
          $Y2 = Max(0, Min($hImage.Height - 1, $Y2))

          $XS = Min($X, $X2)
          $YS = Min($Y, $Y2)
          $WS = Abs($X - $X2) + 1
          $HS = Abs($Y - $Y2) + 1
          $bPrivate = True
          ShowSelection
        Else
          'IF NOT $bPrivate THEN DoPaste
          DoPaste
          HideSelection
        Endif
        EndUndo

      Case "fill"
        FloodFill($X, $Y, $iColor, 0)

      Case "fill-alt"
        FloodFill($X, $Y, $iColor, 1)

    End Select

  'END WITH

End


Private Sub RefreshZoom()

  Dim iIndex As Integer
  
  iIndex = $aZoom.Find($iScale)

  If cmbZoom.Index <> iIndex Then cmbZoom.Index = iIndex

  'ME.Resize(Min($iMaxW, $hImage.Width * $iScale + (ME.Width - ME.ClientW) + 8), Min($iMaxH, $hImage.Height * $iScale + (ME.Height - ME.ClientH) + 8))
  $iScale1 = $iScale + 1

  'dwgIcon.Hide
  dwgIcon.Resize($hImage.Width * $iScale, $hImage.Height * $iScale)
  'RefreshSelect
  RefreshAllImage

  If dwgPaste.Visible Then
    dwgPaste.Move($XS * $iScale, $YS * $iScale, $hPaste.Width * $iScale, $hPaste.Height * $iScale)
  Endif

  DrawTitle

End


Private Sub RefreshImage(X As Integer, Y As Integer, W As Integer, H As Integer)

  X = X * $iScale
  Y = Y * $iScale
  W = W * $iScale
  H = H * $iScale

  dwgIcon.Refresh(X - 1, Y - 1, W + 2, H + 2)
  If Not $bNoPreview Then dwgPreview.Refresh(X - 1 + 4, Y - 1 + 4, W + 2, H + 2)

End


Private Sub RefreshAllImage()

  dwgIcon.Refresh(svwIcon.ScrollX, svwIcon.ScrollY, svwIcon.ClientW, svwIcon.ClientH)
  If Not $bNoPreview Then dwgPreview.Refresh

End



Public Sub Modify(Optional bReset As Boolean)

  If Project.ReadOnly Or $bReadOnly Then Return
  If $bModify <> bReset Then Return

  $bModify = Not bReset
  DrawTitle
  If $bModify Then Inc Project.TimeStamp

End


Public Sub dwgIcon_Leave()

  HideCoord

End


Private Sub SetPixel(X As Integer, Y As Integer, C As Integer)

  If $bTrans Then
    $hImage[X, Y] = Color.Blend(C, $hImage[X, Y])
  Else
    $hImage[X, Y] = C
  Endif
  'Modify

End

Private Sub SetPixelAlt(X As Integer, Y As Integer, C As Integer, C2 As Integer)

  If (X + Y) And 1 Then
    C = C2
  Endif 
  
  If $bTrans Then
    $hImage[X, Y] = Color.Blend(C, $hImage[X, Y])
  Else
    $hImage[X, Y] = C
  Endif
  'Modify

End


Private Sub DrawPoint(X As Integer, Y As Integer, C As Integer)

  SetPixel(X, Y, C)
  RefreshImage(X, Y, 1, 1)
  Modify

End


Private Sub DrawLine(X1 As Integer, Y1 As Integer, X2 As Integer, Y2 As Integer, C As Integer)

  Dim X As Integer
  Dim Y As Integer
  Dim DX As Float
  Dim DY As Float
  Dim D As Integer
  Dim XX As Float
  Dim YY As Float
  Dim LX As Integer
  Dim LY As Integer
  Dim bCalc As Boolean

  $bNoPreview = True

  D = Max(Abs(X2 - X1), Abs(Y2 - Y1))
  D = Max(D, 1)

  DX = (X2 - X1) / D
  DY = (Y2 - Y1) / D

  'PRINT "-------"
  'PRINT "D ="; D; " DX ="; DX; " "; Sgn(DX); " DY ="; DY; " "; Sgn(DY)

  X = X1
  Y = Y1

  Do
    'PRINT "X ="; X; " Y ="; Y

    DrawPoint(X, Y, C)

    If X = X2 And Y = Y2 Then Break

    bCalc = False

    Do

      XX = XX + DX
      YY = YY + DY

      If Abs(XX) > 0.5 Then
        X = X + Sgn(DX)
        XX = XX - Sgn(DX)
        bCalc = True
      Endif

      If Abs(YY) > 0.5 Then
        Y = Y + Sgn(DY)
        YY = YY - Sgn(DY)
        bCalc = True
      Endif

    Loop Until bCalc

  Loop
  
  $bNoPreview = False
  dwgPreview.Refresh

End

Private Sub DrawRect(X As Integer, Y As Integer, W As Integer, H As Integer, C As Integer, Optional iMode As Integer = -1)

  Dim XX As Integer
  Dim YY As Integer

  'WITH FIconTool

    If iMode < 0 Then iMode = $iMode

    If iMode > 0 Then

      If iMode = 2 Then C = OtherColor(C)

      For XX = X To X + W - 1
        For YY = Y To Y + H - 1
          SetPixel(XX, YY, C)
        Next
      Next

    Endif

    If iMode <> 1 Then

      If iMode = 2 Then C = OtherColor(C)

      For XX = X To X + W - 1
        SetPixel(XX, Y, C)
        SetPixel(XX, Y + H - 1, C)
      Next

      For YY = Y + 1 To Y + H - 2
        SetPixel(X, YY, C)
        SetPixel(X + W - 1, YY, C)
      Next

    Endif

    RefreshImage(X, Y, W, H)
    
    Modify

  'END WITH

End


Private Sub DrawEllipse(X As Integer, Y As Integer, W As Integer, H As Integer, C As Integer)

  Dim hTemp As New Picture
  Dim hImage As Image
  Dim XX As Integer
  Dim YY As Integer
  Dim C2 As Integer

  'WITH FIconTool

    'hTemp.Type = Picture.Bitmap
    hTemp.Resize(W, H)
    hTemp.Fill(0)

    Draw.Begin(hTemp)

    Select Case $iMode

      Case 0
        Draw.LineStyle = LINE.Solid
        Draw.Foreground = 1
        Draw.FillStyle = Fill.None

      Case 1
        Draw.LineStyle = LINE.None
        Draw.FillStyle = Fill.Solid
        Draw.FillColor = 1

      Case 2
        Draw.LineStyle = LINE.Solid
        Draw.Foreground = 1
        Draw.FillStyle = Fill.Solid
        Draw.FillColor = 2

    End Select

    Draw.Ellipse(0, 0, W, H)
    Draw.End

    hImage = hTemp.Image
    C2 = OtherColor(C)

    For XX = 0 To W - 1
      For YY = 0 To H - 1
        Select Case hImage[XX, YY]
          Case 1
            SetPixel(X + XX, Y + YY, C)
          Case 2
            SetPixel(X + XX, Y + YY, C2)
        End Select
      Next
    Next

    Modify

    RefreshImage(X, Y, W, H)

  'END WITH

End


Private Sub DrawGhost(Optional bNoBegin As Boolean)

  Dim iS2 As Integer
  Dim iSH As Integer
  Dim iWH As Integer

  'WITH FIconTool

    If $sTool = "select" And Not $bSelect Then Return

    iS2 = $iScale \ 2
    iSH = $iScale
    iWH = iSH * 2 + 1

    If Not bNoBegin Then Draw.Begin(dwgIcon)

    Select Case $sTool

      Case "line"

        Draw.Invert = True
        Draw.LineStyle = Line.Solid
        Draw.LineWidth = 3
        Draw.FillStyle = Fill.None
        Draw.Foreground = Color.White
        Draw.Line($X * $iScale + iS2, $Y * $iScale + iS2, $X2 * $iScale + iS2, $Y2 * $iScale + iS2)
        Draw.Rect($X * $iScale, $Y * $iScale - 1, $iScale1, $iScale1)
        Draw.Rect($X2 * $iScale, $Y2 * $iScale - 1, $iScale1, $iScale1)

      Case "select"

        Draw.Invert = True
        Draw.LineStyle = Line.Solid
        Draw.LineWidth = 3
        Draw.FillStyle = Fill.None
        Draw.Foreground = Color.White
        Draw.Rect(Min($X, $X2) * $iScale, Min($Y, $Y2) * $iScale, (Abs($X - $X2) + 1) * $iScale + 1, (Abs($Y - $Y2) + 1) * $iScale + 1)

      Case "rect"

        Draw.Invert = True
        Draw.LineStyle = Line.Solid
        Draw.LineWidth = 3
        Draw.FillStyle = Fill.None
        Draw.Foreground = Color.White
        Draw.Rect(Min($X, $X2) * $iScale, Min($Y, $Y2) * $iScale, (Abs($X - $X2) + 1) * $iScale + 1, (Abs($Y - $Y2) + 1) * $iScale + 1)
        If $iMode = 0 Then
          If Abs($X - $X2) > 1 And Abs($Y - $Y2) > 1 Then
            Draw.Rect((Min($X, $X2) + 1) * $iScale, (Min($Y, $Y2) + 1) * $iScale, (Abs($X - $X2) - 1) * $iScale + 1, (Abs($Y - $Y2) - 1) * $iScale + 1)
          Endif
        Endif

      Case "circle"

        Draw.Invert = True
        Draw.LineStyle = LINE.Solid
        Draw.LineWidth = 3
        Draw.FillStyle = Fill.None
        Draw.Foreground = Color.White
        Draw.Ellipse(Min($X, $X2) * $iScale, Min($Y, $Y2) * $iScale, (Abs($X - $X2) + 1) * $iScale + 1, (Abs($Y - $Y2) + 1) * $iScale + 1)
        If $iMode = 0 Then
          If Abs($X - $X2) > 1 And Abs($Y - $Y2) > 1 Then
            Draw.Ellipse((Min($X, $X2) + 1) * $iScale, (Min($Y, $Y2) + 1) * $iScale, (Abs($X - $X2) - 1) * $iScale + 1, (Abs($Y - $Y2) - 1) * $iScale + 1)
          Endif
        Endif

    End Select

    If Not bNoBegin Then
      Draw.End
      $bGhost = Not $bGhost
    Endif

  'END WITH

End


Private Sub BeginUndo()

  If $iBeginUndo = 0 Then
    $hUndo[$iUndo] = $hImage.Copy()
    $iUndo = ($iUndo + 1) Mod MAX_UNDO
  Endif
  Inc $iBeginUndo

End

Private Sub EndUndo()
  
  Dec $iBeginUndo
  
End

Private Sub SetUndo()
  
  BeginUndo
  EndUndo
  
End



Public Sub Undo()

  If HasSelection() Then
    HideSelection
    Return
  Endif

  Inc Application.Busy

  Dec $iUndo
  If $iUndo < 0 Then $iUndo = MAX_UNDO - 1
  If $hUndo[$iUndo] Then
    $hImage = $hUndo[$iUndo]
    $hUndo[$iUndo] = Null
    'PRINT svwICon.ClientX; svwIcon.ClientY; svwIcon.ClientW, svwIcon.ClientH
    'PRINT svwICon.ScrollX; svwIcon.ScrollY
    'dwgIcon.Refresh(svwIcon.ScrollX, svwIcon.ScrollY, svwIcon.ClientW, svwIcon.ClientH)
    'svwIcon.Refresh
    RefreshZoom
    If dwgPaste.Visible Then dwgPaste.Refresh
    Modify
  Endif

  Dec Application.Busy

End


' PRIVATE SUB RefreshSelect()
'
'   DIM X AS Integer
'   DIM Y AS Integer
'   DIM X2 AS Integer
'   DIM Y2 AS Integer
'   DIM W AS Integer
'   DIM H AS Integer
'
'   IF $bSelect THEN
'
'     panSelectN.Visible = FALSE
'     panSelectS.Visible = FALSE
'     panSelectW.Visible = FALSE
'     panSelectE.Visible = FALSE
'
'     X = $XS * $iScale
'     Y = $YS * $iScale
'     X2 = ($XS + $WS) * $iScale
'     Y2 = ($YS + $HS) * $iScale
'     W = $WS * $iScale
'     H = $HS * $iScale
'
'     panSelectN.Move(X - WIDTH_SEL, Y - WIDTH_SEL, W + WIDTH_SEL * 2, WIDTH_SEL)
'     panSelectS.Move(X - WIDTH_SEL, Y2, W + WIDTH_SEL * 2, WIDTH_SEL)
'
'     panSelectW.Move(X - WIDTH_SEL, Y, WIDTH_SEL, H)
'     panSelectE.Move(X2, Y, WIDTH_SEL, H)
'
'   ENDIF
'
'   panSelectN.Visible = $bSelect
'   panSelectS.Visible = $bSelect
'   panSelectW.Visible = $bSelect
'   panSelectE.Visible = $bSelect
'
' END

Public Function HasSelection() As Boolean

  Return dwgPaste.Visible

End



Public Sub HideSelection()

  If Not dwgPaste.Visible Then Return

  If $bPrivate Then
    DoPaste
    $bPrivate = False
  Endif

  $bSelect = False
  $XS = 0
  $YS = 0
  dwgPaste.Visible = False

End


Private Sub ShowSelection()

  $bSelect = True
  CopySelection
  ShowPaste
  If $bPrivate Then 
    DeleteSelection
    RefreshPaste
  Endif
  Wait

End


Private Sub FloodFill(X As Integer, Y As Integer, C As Integer, iMode As Integer)

  Dim aStack As New Integer[]
  Dim aNextStack As New Integer[]
  Dim C2 As Integer
  Dim CS As Integer
  Dim X1 As Integer
  Dim Y1 As Integer
  Dim X2 As Integer
  Dim Y2 As Integer

  'WITH FIconTool

    If iMode = 1 Then
      C2 = OtherColor(C)
    Else
      C2 = C
    Endif

  'END WITH

  CS = $hImage[X, Y]

  If $bTrans Then 
    If Color.Blend(C, CS) = CS Then Return
    If Color.Blend(C2, CS) = CS Then Return
  Else
    If CS = C Or CS = C2 Then Return
  Endif

  Inc Application.Busy

  X1 = X
  Y1 = Y
  X2 = X
  Y2 = Y

  aNextStack.Push(X)
  aNextStack.Push(Y)
  SetPixelAlt(X, Y, C, C2)
  

  While aNextStack.Count

    aStack = aNextStack
    aNextStack = New Integer[]

    While aStack.Count

      Y = aStack.Pop()
      X = aStack.Pop()
      
      X1 = Min(X1, X)
      Y1 = Min(Y1, Y)
      X2 = Max(X2, X)
      Y2 = Max(Y2, Y)
  
      If X > 0 Then
        If $hImage[X - 1, Y] = CS Then
          aNextStack.Push(X - 1)
          aNextStack.Push(Y)
          SetPixelAlt(X - 1, Y, C, C2)
        Endif
      Endif
  
      If Y > 0 Then
        If $hImage[X, Y - 1] = CS Then
          aNextStack.Push(X)
          aNextStack.Push(Y - 1)
          SetPixelAlt(X, Y - 1, C, C2)
        Endif
      Endif
  
      If X < ($hImage.Width - 1) Then
        If $hImage[X + 1, Y] = CS Then
          aNextStack.Push(X + 1)
          aNextStack.Push(Y)
          SetPixelAlt(X + 1, Y, C, C2)
        Endif
      Endif
  
      If Y < ($hImage.Height - 1) Then
        If $hImage[X, Y + 1] = CS Then
          aNextStack.Push(X)
          aNextStack.Push(Y + 1)
          SetPixelAlt(X, Y + 1, C, C2)
        Endif
      Endif
      
    Wend

  Wend

  Modify
  RefreshImage(X1, Y1, X2 - X1 + 1, Y2 - Y1 + 1)

  Dec Application.Busy

End


Private Sub CopySelection()

  'IF dwgPaste.Visible THEN RETURN

  If $bSelect Then
    Clipboard.Copy($hImage.Copy($XS, $YS, $WS, $HS))
  Else
    Clipboard.Copy($hImage)
  Endif

End


Private Sub DeleteSelection()

  SetUndo
  If HasSelection() Then
    DrawRect($XS, $YS, $WS, $HS, -1, 1)
  Else
    $hImage.Fill(-1)
    RefreshAllImage()
    Modify
  Endif

End



Public Sub RefreshPaste()

  If Not $hPaste Then Return

  dwgPaste.Move($XS * $iScale, $YS * $iScale, $hPaste.Width * $iScale, $hPaste.Height * $iScale)
  If Not dwgPaste.Visible Then
    dwgPaste.Show
  Else
    dwgPaste.Refresh
  Endif

  ' IF dwgPaste.Visible THEN dwgPaste.Refresh

End



Public Sub ShowPaste(Optional bReset As Boolean)

  If Clipboard.Type <> Clipboard.Image Then Return

  $hPaste = Clipboard.Paste()
  $WS = $hPaste.Width
  $HS = $hPaste.Height

  If bReset Then
    $XS = ($hImage.Width - $WS) \ 2
    $YS = ($hImage.Height - $HS) \ 2
    svwIcon.Scroll($XS * $iScale, $YS * $iScale)
  Endif

  RefreshPaste

  $bSelect = True

End


Private Sub HidePaste()

  dwgPaste.Hide

End

Private Sub PrintColor(C As Integer)
  
  Print "("; Color[C].Red; ","; Color[C].Green; ","; Color[C].Blue; ","; Color[C].Alpha; ") ";
  
End


Private Sub PasteSelection()

  Dim X As Integer
  Dim Y As Integer
  Dim C As Integer

  If $bTrans Then

    For X = 0 To $hPaste.Width - 1
      For Y = 0 To $hPaste.Height - 1
        'C = $hPaste[X, Y]
        'IF C < 0 THEN CONTINUE
        ' PrintColor(C)
        ' PrintColor($hImage[X + $XS, Y + $YS])
        ' PRINT "-> ";
        ' PrintColor(Color.Blend(C, $hImage[X + $XS, Y + $YS]))
        ' PRINT
        $hImage[X + $XS, Y + $YS] = Color.Blend($hPaste[X, Y], $hImage[X + $XS, Y + $YS])
      Next
    Next

  Else

    For X = 0 To $hPaste.Width - 1
      For Y = 0 To $hPaste.Height - 1
        $hImage[X + $XS, Y + $YS] = $hPaste[X, Y]
      Next
    Next

  Endif

  Modify

End



Public Sub DoPaste()

  Dim bTrans As Boolean

  If Not dwgPaste.Visible Then
    ShowPaste(True)
    $bPrivate = False
    Return
  Endif

  Inc Application.Busy

  SetUndo
  PasteSelection

  Dec Application.Busy

End


Public Sub dwgPaste_MouseDown()

  $X = Mouse.ScreenX - dwgPaste.ScreenX
  $Y = Mouse.ScreenY - dwgPaste.ScreenY

End

Public Sub dwgPaste_MouseMove()

  Dim XP As Integer
  Dim YP As Integer

  RefreshCoord(Mouse.X \ $iScale + $XS, Mouse.Y \ $iScale + $YS)
  
  If Not Mouse.Left Then Return

  XP = (Mouse.ScreenX - $X - dwgIcon.ScreenX) \ $iScale
  YP = (Mouse.ScreenY - $Y - dwgIcon.ScreenY) \ $iScale

  If XP = $XS And YP = $YS Then Return

  $XS = XP
  $YS = YP

  dwgPaste.Refresh
  dwgPaste.Move($XS * $iScale, $YS * $iScale)
  'dwgPaste.Show

  UpdateScroll(Mouse.X + dwgPaste.X, Mouse.Y + dwgPaste.Y)

End

Private Sub UpdateScroll(X As Integer, Y As Integer)

  Dim NX As Integer
  Dim NY As Integer

  If X >= (svwIcon.ScrollX + svwIcon.ClientW) Then
    NX = X - svwIcon.ClientW + 1
  Else If X < svwIcon.ScrollX Then
    NX = Max(0, X)
  Else
    NX = svwIcon.ScrollX
  Endif

  If Y >= (svwIcon.ScrollY + svwIcon.ClientH) Then
    NY = Y - svwIcon.ClientH + 1
  Else If Y < svwIcon.ScrollY Then
    NY = Max(0, Y)
  Else
    NY = svwIcon.ScrollY
  Endif

  svwIcon.Scroll(NX, NY)

End


Public Sub dwgPaste_MouseUp()

  If Mouse.Right Then
    DoPaste
  Endif

End

Public Sub DoFlip(iMode As Integer)

  Dim iAngle As Float

  If dwgPaste.Visible Then

    Select Case iMode

      Case 0
        $hPaste = $hPaste.Mirror(True, False)

      Case 1
        $hPaste = $hPaste.Mirror(False, True)

      Case 2
        $hPaste = $hPaste.Rotate(Rad(-90))

      Case 3
        $hPaste = $hPaste.Rotate(Rad(90))

    End Select

    RefreshPaste

  Else

    SetUndo

    Select Case iMode

      Case 0
        $hImage = $hImage.Mirror(True, False)

      Case 1
        $hImage = $hImage.Mirror(False, True)

      Case 2
        $hImage = $hImage.Rotate(Rad(-90))
        DrawTitle

      Case 3
        $hImage = $hImage.Rotate(Rad(90))
        DrawTitle

    End Select

    RefreshZoom
    Modify

  Endif

End

Public Sub SelectAll()

  HideSelection
  $XS = 0
  $YS = 0
  $WS = $hImage.Width
  $HS = $hImage.Height
  ShowSelection

End


Public Sub Form_KeyPress()

  If Key.Control Then
    If Key.Code = Key["Z"] Then
      Undo
    Else If Key.Code = Key["A"] Then
      If $sTool = "select" Then
        SelectAll
      Endif
    Else If Key.Code = Key["S"] Then
      Save
    Endif
  Else
    If Key.Code = Key["Esc"] Then
      HideSelection
    Endif
  Endif

End


Public Sub Clear()

  If Message.Delete(("Do you want to clear the image ?"), ("Clear"), ("Cancel")) <> 1 Then Return

  SetUndo
  $hImage.Fill(-1)
  RefreshAllImage()
  Modify

End

Public Sub dwgIcon_DblClick()

  DrawGhost

End

Public Sub Form_Close() 

  If $bModify Then
    If Not Project.AboutToQuit Then
      Select Case Message.Question(("This image has been modified.\nDo you want to save it ?"), ("Save"), ("Close"), ("Cancel"))
        Case 1
          Save
        Case 3
          Stop Event
          Return
      End Select
    Endif
  Endif

  Project.Files[Path] = Null

End

Public Sub ZoomIn()

  Dim iPos As Integer

  iPos = $aZoom.Find($iScale)
  If iPos < 0 Or iPos >= ($aZoom.Count - 1) Then Return
  $iScale = $aZoom[iPos + 1]
  RefreshZoom

End

Public Sub ZoomOut()

  Dim iPos As Integer

  iPos = $aZoom.Find($iScale)
  If iPos <= 0 Then Return
  $iScale = $aZoom[iPos - 1]
  RefreshZoom

End


Private Sub Zoom()
  
  $iScale = $aZoom[cmbZoom.Index]
  RefreshZoom
  
End



Public Sub Form_Enter()

  dwgIcon.Mouse = GetMouse()

End


Public Sub SwapColor(Optional bInv As Boolean)

  Dim C1 As Integer
  Dim C2 As Integer

  'WITH FIconTool

    C1 = GetColor(1)
    C2 = GetColor(2)
    If bInv Then Swap C1, C2

  'END WITH

  If dwgPaste.Visible Then

    $hPaste.Replace(C1, C2)
    RefreshPaste

  Else

    SetUndo
    $hImage.Replace(C1, C2)
    RefreshZoom
    Modify

  Endif

End

Public Sub dwgIcon_KeyPress()

  Form_KeyPress  

End

Public Sub dwgPaste_KeyPress()

  Form_KeyPress  

End

Private Sub RedrawColor(iColor As Integer, X As Integer, Y As Integer, W As Integer, H As Integer)

  Draw.FillStyle = Fill.Solid
  Draw.LineStyle = Line.None
  
  Draw.FillColor = Color.Blend(iColor, &H808080&)
  Draw.Rect(X, Y, W, H)

  Draw.FillColor = Color.Blend(iColor, &HC0C0C0&)
  Draw.Rect(X + W \ 2, Y, W \ 2, H \ 2)
  Draw.Rect(X, Y + H \ 2, W \ 2, H \ 2)

  Draw.LineStyle = Line.Solid
  Draw.FillStyle = Fill.None
  Draw.Foreground = Color.Gray

  Draw.Rect(X, Y, W, H)

  Return

End

Public Sub dwgColor_Draw()

  Dim iColor As Integer
  
  iColor = Last.Tag
  If iColor >= 0 And iColor < $cColor.Count Then  
    iColor = $cColor[iColor]
  Else
    iColor = -1
  Endif

  RedrawColor(iColor, 3, 3, 18, 18)

End

Private Sub SetMode(iMode As Integer)
  
  $bIgnoreClick = True
  If $hMode Then $hMode.Value = False
  $iMode = iMode
  $hMode = [btnBorder, btnFilled, btnBorderFilled][iMode]
  
  $hMode.Value = True
  $bIgnoreClick = False
  
End

Private Sub SetTransparent(bTrans As Boolean)
  
  $bIgnoreClick = True
  If $hTrans Then $hTrans.Value = False
  $bTrans = bTrans
  $hTrans = If($bTrans, btnTransparent, btnOpaque)
  $hTrans.Value = True
  $bIgnoreClick = False
  
  If HasSelection() Then RefreshPaste
  
End


Public Sub btnTool_Click()

  If $bIgnoreClick Then Return

  Select Case Last.Tag
  
    Case "move", "select", "pen", "line", "rect", "circle", "fill", "fill-alt", "pipette"
      SetTool(Last)
  
    Case "opaque"
      SetTransparent(False)

    Case "transparent"
      SetTransparent(True)
      
    Case "border"
      SetMode(0)
      
    Case "full"
      SetMode(1)
      
    Case "border-full"
      SetMode(2)
      
    Case "zoom-in"
      ZoomIn
      
    Case "zoom-out"
      ZoomOut
      
    Case "save"
      Me.Save
      
    Case "undo"
      Undo
      
    Case "clear"
      Clear
    
    Case "swap"
      SwapColor
      
    Case "flip-h"
      DoFlip(0)
            
    Case "flip-v"
      DoFlip(1)
            
    Case "rotate"
      DoFlip(2)
            
    Case "rotate-back"
      DoFlip(3)
      
    Case "exchange"
      Swap $iForeground, $iBackground
      RefreshColor
      
    Case "cut"
      If HasSelection() Then
        Clipboard.Copy($hPaste)
        If $bPrivate Then PasteSelection
        BeginUndo
        $bPrivate = False
        DeleteSelection
        HideSelection
        EndUndo
      Else
        BeginUndo
        CopySelection
        DeleteSelection
        EndUndo
      Endif
      
    Case "copy"
      If HasSelection() Then
        Clipboard.Copy($hPaste)
        HideSelection
      Else
        CopySelection
      Endif
    
    Case "paste"
      DoPaste 'PasteSelection
      SetTool(btnSelect)

  End Select
  
End


'----------------------------------------------------------------------------------------

' PRIVATE SUB ChangeMode(hImage AS ToolButton, sMode AS String, sLstPict AS String, sLstToolTip AS String)
' 
'   DIM iMode AS Integer
'   DIM aLstPict AS String[]
'   DIM aLstToolTip AS String[]
' 
'   aLstPict = Split(sLstPict)
'   aLstToolTip = Split(sLstToolTip)
' 
'   iMode = ($cMode[sMode] + 1) MOD aLstPict.Count
' 
'   hImage.Picture = Picture["img/16" &/ aLstPict[iMode] & ".png"]
'   hImage.ToolTip = aLstToolTip[iMode]
' 
'   $cMode[sMode] = iMode
' 
' END


' PUBLIC SUB btnTool_MouseUp()
' 
'   DIM hLast AS ToolButton
'   DIM bCommand AS Boolean
'   DIM bUp AS Boolean
' 
'   hLast = LAST
' 
'   bCommand = TRUE
' 
'   SELECT CASE hLast.Tag
' 
'     CASE "zoom"
' 
'       IF Mouse.Left THEN
'         $hCurrent.ZoomIn
'       ELSE IF Mouse.Right THEN
'         $hCurrent.ZoomOut
'       ENDIF
' 
'     CASE "save"
' 
'       $hCurrent.Save
' 
'     CASE "undo"
' 
'       $hCurrent.Undo
' 
'     CASE "clear"
' 
'       $hCurrent.Clear
' 
'     CASE "swap"
' 
'       $hCurrent.SwapColor(Mouse.Left)
' 
'     CASE "paste"
' 
'       $hCurrent.DoPaste
'       hLast.Value = FALSE
'       IF $hTool <> btnSelect THEN
'         $hLast = btnSelect
'         RevertTool
'       ENDIF
'       RETURN
' 
'     CASE "flip"
' 
'       IF Mouse.Left THEN
'         $hCurrent.DoFlip
'       ELSE
'         ChangeMode(btnFlip, "flip", "flip-h,flip-v,rotate,rotate-back", ("Horizontal flip,Vertical flip,Rotate clockwise,Rotate counter-clockwise"))
'       ENDIF
' 
'     DEFAULT
'       bCommand = FALSE
' 
'   END SELECT
' 
'   IF bCommand THEN
'     'hLast.Border = Border.None
'     hLast.Value = FALSE
'     RETURN
'   ENDIF
' 
'   'IF Button = 1 OR hLast <> $hTool THEN
' 
'   'ELSE
' 
'     SELECT CASE hLast.Tag
' 
'       CASE "rect"
'         IF Mouse.Right THEN
'           ChangeMode(btnRect, "rect", "square,square-f,square-fr", ("Rectangle,Filled rectangle,Filled delimited rectangle"))
'         ENDIF

' 
'       CASE "circle"
'         IF Mouse.Right THEN
'           ChangeMode(btnCircle, "circle", "circle,circle-f,circle-fr", ("Ellipse,Filled ellipse,Filled delimited ellipse"))
'         ENDIF
' 
'       CASE "fill"
'         IF Mouse.Right THEN
'           ChangeMode(btnFill, "fill", "fill,fill-alt", ("Flood fill,Patterned flood fill"))
'         ENDIF
' 
'       CASE "select"
'         IF Mouse.Left THEN
'           IF hLast = $hTool THEN
'             IF NOT $hCurrent.HasSelection() THEN
'               $hCurrent.SelectAll
'             ELSE
'               $hCurrent.HideSelection
'             ENDIF
'           ELSE
'             $hCurrent.HideSelection
'           ENDIF
'         ELSE IF Mouse.Right THEN
'           ChangeMode(btnSelect, "select", "frame,frame-opaque", ("Select and transparent paste,Select and opaque paste"))
'           $hCurrent.RefreshPaste
'         ENDIF
' 
'       'CASE "move"
'       '
'       '  IF Button AND Mouse.Right THEN
'       '    ChangeMode(imgMove, "move", "scroll,move",("Move,Translate"))
'       '  ENDIF
' 
'     END SELECT
' 
'   'ENDIF
' 
'   $hLast = $hTool
'   $hTool = hLast
' 
'   IF $hLast THEN
'     IF $hLast <> $hTool THEN
'       '$hLast.Border = Border.None
'       $hLast.Value = FALSE
'     ENDIF
'   ENDIF
' 
'   ChangeTool
' 
' END


Public Sub SetTool(hTool As ToolButton)

  If Not hTool Then Return

  ' IF hTool = $hTool THEN
  '   $hTool.Value = TRUE
  '   RETURN
  ' ENDIF


  If hTool.Tag = "pipette" Then $hLast = $hTool

  $bIgnoreClick = True
  If $hTool Then $hTool.Value = False
  $hTool = hTool
  $hTool.Value = True 
  $bIgnoreClick = False 

  $sTool = $hTool.Tag

  Select $sTool

    Case "move"
      SetIcon(Mouse.SizeAll)

    Case "pen"
      SetIcon(Mouse.Arrow)

    Case Else
      SetIcon(Mouse.Cross)

  End Select
  
End


Public Sub RevertTool()

  SetTool($hLast)

End



Public Sub dwgColor_MouseDown()

  Dim C As Integer

  C = Last.Tag

  If C < $cColor.Count Then
    C = $cColor[C]
  Else
    C = -1
  Endif

  If Mouse.Left Then
    $iForeground = C
  Else
    $iBackground = C
  Endif

  RefreshColor

End

Private Sub RefreshColor()

  dwgForeground.ToolTip = FormatColor($iForeground)
  dwgBackground.ToolTip = FormatColor($iBackground)
  dwgForeground.Refresh
  dwgBackground.Refresh

End

Private Sub FormatColor(iColor As Integer) As String
  
  Return Subst("R: &1", Color[iColor].Red) & " " & 
    Subst("G: &1", Color[iColor].Green) & " " & 
    Subst("B: &1", Color[iColor].Blue) & " " & 
    Subst("A: &1", Color[iColor].Alpha)
    
End


Public Sub SetForeground(iColor As Integer)

  $iForeground = iColor
  RefreshColor

End

Public Sub SetBackground(iColor As Integer)

  $iBackground = iColor
  RefreshColor

End



Public Sub dwgForeground_Draw()

  'Draw.LineStyle = Line.None 'LINE.Solid
  RedrawColor($iForeground, 3, 3, dwgForeground.Width - 6, dwgForeground.Height - 6)

End


Public Sub dwgBackground_Draw()

  'Draw.LineStyle = Line.None 'LINE.Solid
  RedrawColor($iBackground, 3, 3, dwgBackground.Width - 6, dwgBackground.Height - 6)
  
End


Public Function GetColor(iButton As Integer) As Integer

  If iButton = 1 Then
    Return $iForeground
  Else
    Return $iBackground
  Endif

End


Public Sub dwgForeground_MouseUp()

  If FColorChooser.Run("&H" & Hex$($iForeground, 8), True) Then Return
  $iForeground = FColorChooser.Value
  RefreshColor

End

Public Sub dwgBackground_MouseUp()

  If FColorChooser.Run("&H" & Hex$($iBackground, 8), True) Then Return
  $iBackground = FColorChooser.Value
  RefreshColor

End

Public Function OtherColor(C As Integer) As Integer

  If C = $iBackground Then
    Return $iForeground
  Else
    Return $iBackground
  Endif

End


Private Sub SetIcon(iMouse As Integer)

  $iMouse = iMouse
  Form_Enter

End

Public Function GetMouse() As Integer

  Return $iMouse

End

Public Sub Form_Activate()

  ' To be activated  

End


Public Sub cmbZoom_Click()

  Object.Lock(cmbZoom)
  Zoom
  Object.UnLock(cmbZoom)

End


Private Function ReadOnly_Read() As Boolean

  Return $bReadOnly  

End


Public Sub OnProjectDebug()

  SetReadOnly

End

Public Sub Reload()

  Dim iInd As Integer

  HideSelection

  $hImage = Image.Load(Path)
  
  For iInd = 0 To 31
    $hUndo[iInd] = Null
  Next 
  $iUndo = 0
  
  $XD = COORD_HIDE
  $YD = COORD_HIDE

  Modify(True)
  
  dwgIcon.Refresh

End


Public Sub mnuReload_Click()

  If IsModified() Then
    If Message.Warning(("The file has been modified.\n\nAll your changes will be lost."), ("Reload"), ("Cancel")) <> 1 Then Return
  Endif

  Reload

End

' PUBLIC SUB Form_Resize()
' 
'   panPreview.Move(ME.W - $hImage.W - 8, ME.H - $hImage.H - 8, $hImage.W + 8, $hImage.H + 8)
' 
' END

Public Sub dwgPreview_Draw()

  Draw.Image($hImage, 4, 4)

End

' PUBLIC SUB btnPreview_Click()
' 
'   svwPreview.Visible = btnPreview.Value
'   IF svwPreview.Visible THEN splPreview.Layout = CStr(dwgPreview.W) & "," & CStr(ME.H - dwgPreview.W - 16)
' 
' END
