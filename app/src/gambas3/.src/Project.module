' Gambas module file

'
' Gambas 3
' Integrated Development Environment for Gambas
'
' Copyright (C) Benoît Minisini, Fabien Bodard, Charlie Reinl, José Luis Redrejo, Robert Rowe
'
' This program is free software; you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation; either version 2 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 51 Franklin St, Fifth Floor,
' Boston, MA  02110-1301  USA
'

Public ProjectTree As ColumnView
Public ProjectFilter As String
Public ProjectMessage As Label
Public Workspace As Workspace

Public ActiveForm As Object

Public Path As String
Public Name As String
Public Dir As String
Public SourceDir As String
Public ReadOnly As Boolean

Public Title As String
Public Startup As String
Public Components As String[]
Public Libraries As String[]
Public Arguments As String[]
Public Environment As String[]
Public KeepDebugInfo As Boolean
Public CreateShortcut As Boolean
Public RunAfterMakingExec As String
Public ControlPublic As Boolean
Public ModulePublic As Boolean
Public MajorVersion As Integer
Public MinorVersion As Integer
Public ReleaseVersion As Integer
'PUBLIC SnapToGrid AS Boolean
'PUBLIC ShowGrid AS Boolean
Public Snap As Integer
Public Localize As Boolean
Public Description As String
Public Icon As String

Public Systems As String[]
Public Menus As Collection
Public Groups As Collection
Public ExtraDependencies As Collection
Public ExtraFiles As Collection
Public SameDependencies As Boolean
Public SameFiles As Boolean
Public ExtraAutoconfTest As String
Public Categories As Collection
Public MimeTypes As String[]
Public ExtraDesktop As String
Public Prefix As Boolean
Public UseRelease As Boolean
Public PackageName As String
Public Maintainer As String
Public Address As String
Public Vendor As String
Public Url As String
Public License As String
Public CreateEachDirectory As Boolean

Public TabSize As Integer
Public Version As String
Public FullVersion As String
Public FullVersionWithRevision As String
Public ExecPath As String
Public SourcePath As String
Public Language As String
Public CreateComponent As Boolean
Public ComponentState As Integer
'Public Stack As Integer
'Public StackTrace As Boolean
Public Authors As String
Public VersionFile As Boolean
Public UseTerminal As Boolean

Public Running As Boolean

'Private Recent As New String[]
'Private RecentDate As New Date[]

Public Const FORM_MAGIC As String = "# Gambas Form File 3.0"
Public Const FORM_MAGIC_1 As String = "# Gambas Form File 1.0"
Public Const FORM_MAGIC_2 As String = "# Gambas Form File 2.0"
Public Const PROJECT_MAGIC_1 As String = "# Gambas Project File 1.0"
Public Const PROJECT_MAGIC_2 As String = "# Gambas Project File 2.0"
Public Const PROJECT_MAGIC As String = "# Gambas Project File 3.0"
Public Const ACTION_MAGIC As String = "# Gambas Action File 3.0"
Public Const CONNECTION_MAGIC As String = "# Gambas Connection File 3.0"

Public Const DEFAULT_FONT As String = "Monospace,9"

Public Const DEFAULT_URL As String = "http://www.endoftheinternet.com/"

Public Const FILTER_ADDED As String = " +"
Public Const FILTER_EXPORTED As String = " X"

Public Files As New Collection

Public AboutToQuit As Boolean

Public Const MAX_ICON_SIZE As Integer = 32768

Public EXAMPLES_DIR As String

'Public ShowAlwaysProperty As Boolean

Private Const IMAGE_DIR As String = "img/16"

'Private Const KEY_MODULE As String = "$M"
'Private Const KEY_CLASS As String = "$C"
'Private Const KEY_FORM As String = "$F"
Public Const KEY_SOURCE As String = "$S"
Public Const KEY_MISC As String = "$O"
Public Const KEY_PROJECT As String = "$P"
Public Const KEY_CONNECTION As String = "$D"

Private Const CLASS_AUTH_CAR As String = "abcdefghijklmnopqrstuvwxyz0123456789"
Private Const CLASS_AUTH_CAR_COMPONENT As String = "_"
Private Const CLASS_AUTH_FIRST_CAR As String = "abcdefghijklmnopqrstuvwxyz_"
Private Const FILE_FORBIDDEN_CAR As String = "?*/~"

Private Const PROJECT_FILE As String = ".project"
Private Const STARTUP_FILE As String = ".startup"

Private OUTPUT_FILE As String

Public Browser As String
Public ImageEditors As String[] = ["Gimp", "KIconEdit", "KolourPaint", "Krita"]
Private IMAGE_EXT As String[] = ["jpg", "jpeg", "gif", "bmp", "xpm", "png", "tif", "tiff"]

Private $sOldRefreshLibrary As String

Public ExampleTitle As New Collection

Public TimeStamp As Integer
Public Config As Settings

Public RestoringFiles As Boolean

Private $aInheritance As New String[]
Private $iNoRefresh As Integer
Private $bDoRefresh As Boolean
Private $cProjectFilter As Collection

Private $cImageCache As New Collection

Private $hCurrentPopup As Menu

Private $hLock As File

' Path of source files
Private $cSourceDir As Collection

' Subversion state of files
Public LockedPaths As Collection
Public AddedPaths As Collection

' I'm using the IDE to test the interpreter with valgrind!
Private $bTesting As Boolean

Public Sub _init()

  ExampleTitle["Automation"] = ("Automation")
  ExampleTitle["Basic"] = ("Basic")
  ExampleTitle["Database"] = ("Database")
  ExampleTitle["Drawing"] = ("Drawing")
  ExampleTitle["Games"] = ("Games")
  ExampleTitle["Image"] = ("Image")
  ExampleTitle["Misc"] = ("Miscellaneous")
  ExampleTitle["Networking"] = ("Networking")
  ExampleTitle["OpenGL"] = ("OpenGL")
  ExampleTitle["Printing"] = ("Printing")
  ExampleTitle["Sound"] = ("Sound")
  ExampleTitle["Video"] = ("Video")
  ExampleTitle["Control"] = ("Controls")

End

Private Sub InitWebView()

  Dim sPath As String

  If Not WebSettings.Cache.Path Then
    sPath = System.User.Home &/ ".cache"
    Try Mkdir sPath
    sPath &/= "gambas3"
    Try Mkdir sPath
    sPath &/= "help"
    Try Mkdir sPath
    WebSettings.Cache.Path = sPath
    WebSettings.Cache.Enabled = True
  Endif

End

Public Sub Main()

  Dim sPath As String
  Dim iTest As Integer
  Dim iInd As Integer
  Dim sArg As String

  Application.Env["APPMENU_DISPLAY_BOTH"] = "1"

  Select Case LCase(Settings["/Theme"])
    Case "kde"
      Application.Theme = "kde4"
    Case "gnome"
      Application.Theme = "gnome"
    Case "gambas"
      Application.Theme = "gambas"
  End Select
  'DB.Debug = True

  OUTPUT_FILE = Temp$()
  'CLASSES_FILE = Temp$()

  'EXAMPLES_DIR = "Ceci est une très longue phrase dont j'ai l'espoir qu'elle soit correctement coupée par le ballon affiché par la fenêtre de débogage"
  'EXAMPLES_DIR = Replace(EXAMPLES_DIR, " ", "0")
  EXAMPLES_DIR = System.Path &/ "share/gambas" & Split(System.Version, ".")[0] & "/examples"

  Application.ShowTooltips = Settings["/ShowTooltip", True]

  RefreshBreakpointPicture

  For iInd = 1 To Application.Args.Count - 1
    sArg = Application.Args[iInd]
    If sArg = "-t" Then
      $bTesting = True
      Continue
    Endif
    If Left(sArg) <> "-" Then
      sPath = Application.Args[iInd]
      Break
    Endif
  Next

  If $bTesting And If sPath Then
    InitVersion
    InitWebView
    CRecentFile.Load
    FMain.Load
    Project.Open(sPath)
    FSearch.FindProject("else")
    Project.Close
    FMain.Close
    Project.Exit
    Return
  Endif

  InitVersion
  InitWebView
  'CRecentFile.Load
  FMain.Load
  Application.MainWindow = FMain

  Do

    If Not sPath Then sPath = FWelcome.Run()
    'sPath = User.Home &/ "gambas/test/gambas"

    If sPath Then
      Project.Open(sPath)
    Else
      Project.Exit
      FMain.Close
      Return
    Endif

    If Project.Name Then Break

    sPath = ""

  Loop

  Inc Application.Busy

  'FProperty.Show
  'FToolBox.Show
  'FFormStack.Load

  'If Settings["/ShowMascot", False] Then FMain.ShowShow

  FMain.Show
  RefreshActivate

  Dec Application.Busy

  If Settings["/ShowTipOnStartup", True] Then
    FTips.Run
  Endif

  'Project.Activate(NULL)

End

Private Sub InitVersion()

  Dim sVer As String
  Dim aVer As String[]

  Shell "gbx" & System.Version & " -V" To sVer
  FullVersion = Trim(Mid$(sVer, InStr(sVer, "-") + 1))
  aVer = Split(FullVersion, ".")
  aVer.Remove(aVer.Max)
  Version = aVer.Join(".")

  FullVersionWithRevision = FullVersion
  If FullVersionWithRevision Ends ".0" Then
    FullVersionWithRevision = Left$(FullVersionWithRevision, -2)
  Endif
  sVer = VersionControl.GetVersion(File.Dir(File.Dir(File.Dir(Application.Path))))
  If sVer Then
    'Version &= " (r" & sVer & ")"
    FullVersionWithRevision &= " (r" & sVer & ")"
  Endif

Catch

  Version = "?"

End

Private Sub LastOpenedFiles()

  Dim nOpen As Integer
  Dim iInd As Integer
  Dim aOpen As String[]
  Dim hForm As Object
  Dim iActive As Integer
  Dim hActive As Object
  Dim aFold As Integer[]
  Dim sPath As String

  Inc Application.Busy
  RestoringFiles = True
  Workspace.Lock

  nOpen = Config["/OpenFile/Count", 0]
  iActive = Config["/OpenFile/Active", 0]
  For iInd = 1 To nOpen
    aOpen = Split(Config["/OpenFile/File[" & CStr(iInd) & "]"], ":")
    sPath = aOpen[0]
    If Left(sPath) <> "/" Then sPath = Project.Dir &/ sPath
    If Not Exist(sPath) Then sPath = FindPath(File.Name(sPath))
    If Not Exist(sPath) Then Continue
    If VersionControl.InConflict(sPath) Then Continue
    If IsConnectionPath(sPath) Then Continue
    hForm = OpenFile(sPath)
    If Not hForm Then Continue
    If aOpen.Count = 2 Then Try hForm.SetState(aOpen[1])
    aFold = Config["/OpenFile/Fold[" & CStr(iInd) & "]"]
    If aFold Then Try hForm.SetFoldedProc(aFold)
    If iInd = iActive Then hActive = hForm
  Next

  Workspace.Unlock
  RestoringFiles = False

  If hActive Then
    Activate(hActive)
    Workspace.ActiveWindow = hActive
  Endif

Finally

  Dec Application.Busy

End

Public Function Open(sDir As String, Optional bInAnotherWindow As Boolean) As Boolean

  Dim sOldPath As String
  Dim sOldName As String
  Dim bConvert As Boolean
  Dim sVer As String
  Dim sFile As String
  Dim hLock As Stream
  Dim aDir As String[]
  Dim iStep As Integer
  Dim bStopConvert As Boolean

  If Not Exist(sDir &/ ".project") Then
    FMain.ShowError(("This project does not exist.") & "\n\n" & sDir)
    Return True
  Endif

  If bInAnotherWindow Then
    Exec [Application.Path &/ Application.Name & ".gambas", sDir]
    Return True
  Endif

  sOldPath = Project.Path
  sOldName = Project.Name

  sVer = CheckProjectVersion(sDir &/ PROJECT_FILE)
  If sVer Then
    If sVer = "?" Then
      Message.Error(("This is not a Gambas project."))
      Return True
    Else If sVer = "1.0" Then
      Message.Error(("This is a Gambas 1.0 project. Use Gambas 2 to convert it."))
      Return True
    Else If sVer = "2.0" Then
      If Message.Warning(Subst(("This is a Gambas 2.0 project.\n\nDo you want to convert it?"), sVer), ("Convert"), ("Cancel")) = 2 Then
        Return True
      Else
        bConvert = True
      Endif
    Endif
  Endif

  If bConvert Then
  
    If Exist(sDir &/ ".lock") Then
      If Message.Warning(("This project seems to be already opened.\n\nOpening the same project twice can lead to data loss."),
          ("Open after all"), ("Do not open")) = 2 Then
        Return True
      Endif
    Endif
    
  Else
  
    Try hLock = Lock sDir &/ ".lock"
  
    If Not hLock Then
      If Message.Warning(("This project seems to be already opened.\n\nOpening the same project twice can lead to data loss."),
          ("Open after all"), ("Do not open")) = 2 Then
        Return True
      Endif
    Endif
    
  Endif

  ReadOnly = Not Access(sDir, gb.Write)
  If Not ReadOnly Then
    If Exist(sDir &/ ".startup") And If Not Access(sDir &/ ".startup", gb.Write) Then ReadOnly = True
  Endif

  If bConvert Then
    
    If ReadOnly Then
      Message.Error(("This project is read-only.") & " " & ("It cannot be converted."))
      Return True
    Endif
    
  Endif

  If Not $bTesting Then
    If CloseProject() Then Return True
  Endif

  Project.Dir = sDir

  If bConvert Then

    ' Create Gambas 2 lock file
    Try File.Save(sDir &/ ".lock", "")
    
    FConvert.Start(("Copying project inside a temporary directory..."))
    Project.Dir = Temp$()
    Shell "cp -R " & Shell$(sDir) & " " & Shell$(Project.Dir) Wait
    If Process.LastValue Then Error.Raise(("Unable to create temporary directory"))

  Endif

_INIT_AGAIN:

  Path = Project.Dir &/ PROJECT_FILE
  Name = File.Name(Project.Dir)
  SourceDir = Project.Dir &/ ".src"

  ProjectFilter = ""
  VersionControl.Refresh

  If bConvert And If Not Exist(SourceDir) Then

    If ReadOnly Then
      Message.Error(("This project is read-only.") & " " & ("It cannot be converted."))
      Return True
    Endif

    bStopConvert = True
    FConvert.SetMessage(("Converting project structure..."))

    ' Needed for MoveFile()
    RefreshSourceCache
    VersionControl.CheckPaths()

    InsertDirectory(SourceDir)
    aDir = Dir(Project.Dir, "*")
    iStep = 0
    For Each sFile In aDir
      If CModule.Ext.Exist(File.Ext(sFile)) Then MoveFile(Project.Dir &/ sFile, SourceDir &/ sFile)
      Inc iStep
      FConvert.SetProgress(iStep / aDir.Count)
    Next

    RefreshSourceCache
    VersionControl.CheckPaths()

    ReadProject(True)
    WriteProject(True)

    MakeDirectoryIcon
    If ConvertProject() Then Goto _CANCEL

    If bStopConvert Then
      FConvert.Stop
      bStopConvert = False
    Endif

    FConvert.SetMessage(("Applying conversion..."))
    Shell "rm -rf " & Shell$(sDir & "~") Wait
    Move sDir To sDir & "~"
    Shell "mv -f " & Shell$(Project.Dir) & " " & Shell$(sDir) Wait
    If Process.LastValue Then
      Try Move sDir & "~" To sDir
      Error.Raise(("Unable to apply conversion"))
    Endif
    
    ' Remove lock file from the backup project
    Try Kill (sDir & "~") &/ ".lock"

    Project.Dir = sDir

    bConvert = False

    Goto _INIT_AGAIN

  Else If Not Exist(SourceDir) Then

    ' Needed for MoveFile()
    RefreshSourceCache
    VersionControl.CheckPaths()

    InsertDirectory(SourceDir)
    aDir = Dir(Project.Dir, "*")
    For Each sFile In aDir
      If CModule.Ext.Exist(File.Ext(sFile)) Then MoveFile(Project.Dir &/ sFile, SourceDir &/ sFile)
    Next

  Endif

  Config = New Settings(sDir &/ ".settings")

  Inc $iNoRefresh
  ' ReadProject(bConvert)
  ' If Not ReadOnly Then
  '   If Not Exist(Project.Dir &/ ".hidden") Then Project.InsertDirectory(Project.Dir &/ ".hidden")
  '   If bConvert Then WriteProject(True)
  ' Endif
  ReadProject
  If Not ReadOnly Then
    If Not Exist(Project.Dir &/ ".hidden") Then Project.InsertDirectory(Project.Dir &/ ".hidden")
  Endif
  Dec $iNoRefresh

  Inc Project.TimeStamp

  MConnection.Password.Clear

  If $bTesting Then 
    RefreshSourceCache
    VersionControl.CheckPaths()
  Else
    Refresh
  Endif

  DefineStartup(Startup, True)

  CRecentFile.Add(sDir)

  If Not $bTesting
    FMain.OnProjectChange
    FSearch.OnProjectChange
    FHelpBrowser.OnProjectChange
    'FOpenProject.OnUpdateRecent
    Design.ClearOutput
    Design.ReadBreakpoints
  Endif

  $hLock = hLock

  If bConvert Then
    MakeDirectoryIcon
    If ConvertProject() Then Goto _CANCEL
  Endif

  If bStopConvert Then FConvert.Stop

  LastOpenedFiles
  CPosition.Clear

  If ReadOnly Then FMain.ShowWarning(("This project is read-only."))

  'SetMessage(("OK"))
  Return

Catch

  If bStopConvert Then FConvert.Stop

  If Error.Text Then
    Message.Error(("Cannot open project file :\n") & sDir & "\n\n" & Error.Text & "\n" & Error.Where)
  Endif

_CANCEL:

  If hLock Then Try Unlock #hLock

  Path = sOldPath
  Project.Dir = File.Dir(Path)
  Name = sOldName
  $iNoRefresh = 0

  If Path Then ReadProject

  Return True

End

Public Sub CloseAllWindows()

  Dim hForm As Window

  Workspace.Lock
  For Each hForm In Files
    hForm.Close
  Next
  Workspace.Unlock

End

Public Sub ReloadAll()

  Dim hForm As Object

  For Each hForm In Files
    Try hForm.Reload
  Next

End

Private Function CloseProject() As Boolean

  Dim hForm As Object
  Dim bModif As Boolean
  Dim nOpen As Integer
  Dim sState As String
  Dim aFold As Integer[]
  Dim sPath As String

  'IF Len(Path) = 0 THEN RETURN

  If Path Then

    If Running Then
      Design.Stop
      'WAIT 0.5
    Endif

    For Each hForm In Files
      If hForm.IsModified() Then
        bModif = True
        Break
      Endif
    Next

    If bModif Then
      If FSave.Run(AboutToQuit) Then Return True
    Endif

    'FFind.Close

    Inc Application.Busy

    Design.WriteBreakpoints

    Config.Clear("/OpenFile")
    For Each hForm In Workspace.Windows

      If Not hForm.Closed Then

        If Not hForm.Path Then
          Debug "hForm.Path = NULL ?"
          'Stop
        Endif

        Inc nOpen
        If hForm = ActiveForm Then Config["/OpenFile/Active"] = nOpen

        sState = ""
        Try sState = hForm.GetState()

        aFold = Null
        Try aFold = hForm.GetFoldedProc()

        If sState Then sState = ":" & sState
        sPath = hForm.Path
        If sPath Begins Project.Dir Then
          sPath = Mid$(sPath, Len(Project.Dir) + 1)
          If Left(sPath) = "/" Then sPath = Mid$(sPath, 2)
        Endif
        Config["/OpenFile/File[" & CStr(nOpen) & "]"] = sPath & sState

        If aFold And If aFold.Count Then Config["/OpenFile/Fold[" & CStr(nOpen) & "]"] = aFold

      Endif

    Next

    If Not $bTesting Then
      CloseAllWindows
      Workspace.Lock
      For Each hForm In Files
        hForm.Delete
      Next
      Workspace.Unlock
    Endif
    Config["/OpenFile/Count"] = nOpen

    'FFind.WriteConfig
    Try Config = Null

    CPosition.Clear
    Files.Clear
    ActiveForm = Null

    If $hLock Then
      Unlock #$hLock
      Try Kill Project.Dir &/ ".lock"
      $hLock = Null
    Endif

    Dec Application.Busy

  Endif

  If Not AboutToQuit Then
    FProperty.HideAll
    FFormStack.HideAll
  Endif

  Return False

End

Public Function Close() As Boolean

  Dim hForm As Form
  Dim iInd As Integer
  Dim sLig As String

  AboutToQuit = True
  If CloseProject() Then
    AboutToQuit = False
    Return True
  Endif

End

Public Sub Exit()

  CSampleCode.Exit
  CRecentFile.Exit
  CComponent.Exit

End

Private Sub AddEmblem(hSource As Image, sEmblem As String) As Image

  Dim hEmblem As Image
  Dim iSize As Integer
  Dim hImage As Image

  iSize = ((hSource.Height \ 2) \ 8) * 8

  hEmblem = Picture[sEmblem].Image.Stretch(iSize * 1.5, iSize * 1.5)

  hImage = New Image(hSource.Width + iSize, hSource.Height, Color.Transparent)
  hImage.PaintImage(hSource, iSize, 0)
  hImage.PaintImage(hEmblem, 0, (hImage.H - hEmblem.H) / 2)
  Return hImage

End

Private Sub AddLinkEmblem(hSource As Image) As Image

  Dim hImage As New Image(hSource.Width + 1, hSource.Height + 1, Color.Transparent)

  hImage.PaintImage(hSource, 1, 0)
  hImage.PaintImage(Picture["img/16/link.png"].Image, 0, hImage.Height - 16)
  Return hImage

End

Private Sub MakeExportedIcon(hImage As Image)

  Dim X, Y As Integer
  Dim iCol As Integer
  Dim iGray As Integer
  Dim hColorInfo As ColorInfo

  For X = 0 To hImage.W - 1
    For Y = 0 To hImage.H - 1

      iCol = hImage[X, Y]
      ' With Color[Color.Desaturate(iCol)]
      '   iGray = (255 - .Blue) * (255 - .Alpha) / 255
      ' End With
      ' Print Mid$(" .,-~+=oOINS8&%@", iGray \ 16 + 1, 1);

      If Color.GetAlpha(iCol) > 192 Then Continue
      If X = 0 Or If X = (hImage.W - 1) Or If Y = 0 Or If Y = (hImage.H - 1) Or If Color[hImage[X - 1, Y]].Alpha = 255 Or If Color[hImage[X + 1, Y]].Alpha = 255 Or If Color[hImage[X, Y - 1]].Alpha = 255 Or If Color[hImage[X, Y + 1]].Alpha = 255 Then
        hColorInfo = Color[Color.Darker(iCol)]
        hColorInfo.Alpha = hColorInfo.Alpha \ 2
        hImage[X, Y] = hColorInfo.Color
      Endif
    Next
  Next

End

Public Sub MakeModuleIcon(sModule As String, iSize As Integer, Optional bStartup As Boolean, Optional bExported As Boolean) As Image

  Dim hImage As Image
  Dim hImageModule As Image
  Dim hImageStartup As Image
  Dim sKey As String

  If Not $cImageCache["base"] Then $cImageCache["base"] = Picture["icon:/32/file"].Image

  If iSize = 0 Then iSize = 16

  sKey = sModule & "-" & iSize & If(bStartup, "s", "") & If(bExported, "x", "") & ".png"
  hImage = $cImageCache[sKey]
  If Not hImage Then
    hImage = $cImageCache["base"]
    hImage = hImage.Stretch(iSize, iSize)
    hImageModule = Image.Load("img/module" &/ sModule & ".png") '.Stretch(iSize / 2, iSize / 2)
    hImage.PaintImage(hImageModule, iSize / 4, iSize / 4, iSize / 2, iSize / 2)

    If bExported Then MakeExportedIcon(hImage)

    If bStartup Then
      hImageStartup = Image.Load("img/16/startup.png").Stretch(iSize \ 2, iSize \ 2)
      hImage.PaintImage(hImageStartup, 0, (hImage.H - hImageStartup.H) \ 2)
    Endif

    $cImageCache[sKey] = hImage
  Endif

  Return hImage

End

Public Sub GetFileIcon(sPath As String, Optional iSize As Integer) As Picture

  Dim hImage As Image
  Dim hPict As Picture
  Dim hStartup As Picture
  Dim sKey As String
  Dim sCacheKey As String
  Dim bLink As Boolean
  Dim sIcon As String
  Dim sExt As String
  Dim bStartup As Boolean
  Dim iFileSize As Long
  Dim hFile As File
  Dim sPrefix As String
  Dim bNoStartup As Boolean
  Dim iDim As Integer
  Dim bConflict As Boolean
  Dim hConflict As Image
  Dim sModule As String
  Dim sLocalPrefix As String
  Dim bLocked As Boolean
  Dim bAdded As Boolean
  Dim hProject As CProjectInfo
  Dim sLink As String
  Dim bExported As Boolean
  
  If iSize Then
    sPrefix = "icon:/" & iSize
    sLocalPrefix = "img/" & iSize
    'bNoStartup = iSize <> 16
  Else
    sPrefix = "icon:/small"
    sLocalPrefix = "img/16"
  Endif

  With Stat(sPath)

    bLink = .Type = gb.Link
    bConflict = False
    bLocked = IsLocked(sPath)
    bAdded = IsAdded(sPath)

    If IsDir(sPath) Then

      If bLink Then
        sLink = GetAbsoluteLink(sPath, .Link)
        'If Left(sLink) <> "/" Then sLink = sPath &/ sLink
        sLink = File.Dir(sLink)
        hProject = New CProjectInfo(sLink)
        sIcon = hProject.Icon
        If iSize = 0 Then iSize = 16
      Else
        sIcon = sPrefix &/ "directory"
      Endif

    Else

      bConflict = VersionControl.InConflict(sPath)
      
      sIcon = sPrefix &/ "file"

      sExt = File.Ext(sPath)
      Select Case sExt

        Case "form", "class", "module", "webpage", "report"
          If IsSourcePath(sPath) Then
            sModule = sExt
            sIcon = sExt & "-" & iSize
            bStartup = File.BaseName(sPath) = Startup And Not bNoStartup
            If sExt = "class" Or If sExt = "module" Then
              bExported = IsExported(sPath)
            Endif
          Endif

        Case "jpg", "jpeg", "xpm", "bmp", "png", "gif"

          If bLink Then
            Try hFile = Open sPath
            If Error Then
              iFileSize = 0
            Else
              iFileSize = Lof(hFile)
              Close hFile
            Endif
          Else
            iFileSize = .Size
          Endif

          If iFileSize > MAX_ICON_SIZE Then
            sIcon = sPrefix &/ "image"
          Else
            sIcon = sPath
          Endif

        Case "svg"
          sIcon = sPrefix &/ "image"

        Case "htm", "html", "css"
          sIcon = sPrefix &/ "html"

        Case "txt", "text"
          sIcon = sPrefix &/ "text"

        Case "connection"
          sIcon = sLocalPrefix &/ "database.png"

      End Select

    Endif

  End With

  If Left$(sIcon) = "/" Then

    Try hImage = Image.Load(sIcon)
    If hImage Then

      If iSize Then
        hImage = hImage.Stretch(hImage.Width * iSize / hImage.Height, iSize)
      Else
        iSize = 32
        If hImage.Height > iSize Then
          hImage = hImage.Stretch(hImage.Width * iSize / hImage.Height, iSize)
        Endif
        If hImage.Width > iSize Then
          hImage = hImage.Stretch(iSize, hImage.Height * iSize / hImage.Width)
        Endif
      Endif

      'hPict = hImage.Picture
    Else
      hImage = Picture[sPrefix &/ "image"].Image
    Endif

    If bConflict Then hImage = AddEmblem(hImage, "icon:/32/warning")
    If bLocked Then hImage = AddEmblem(hImage, "icon:/32/lock")
    If bAdded Then hImage = AddEmblem(hImage, "icon:/32/add")

    If bLink Then
      hImage = AddLinkEmblem(hImage)
    Endif

    hPict = hImage.Picture

  Else

    sKey = File.Dir(sIcon) &/ File.BaseName(sIcon) & "-"
    If bLink Then sKey &= "l"
    If bStartup Then sKey &= "s"
    If bConflict Then sKey &= "c"
    If bLocked Then sKey &= "k"
    If bAdded Then sKey &= "a"
    If bExported Then sKey &= "x"
    If Right(sKey) = "-" Then sKey = Left(sKey, -1)
    sKey &= ".png"

    'hPict = NULL
    'IF NOT bNoStartup THEN hPict = Picture[sKey]

    sCacheKey = Replace(sKey, "icon:/", "$/")
    Try hPict = Picture[sCacheKey]
    If Not hPict Then

      If sModule Then
        hImage = MakeModuleIcon(sModule, iSize, bStartup, bExported)
      Else
        Try hImage = Picture[sIcon].Image
        If Error Then hImage = Picture[sPrefix &/ "file"].Image
      Endif
      'If Not hPict Then hPict = Picture[sPrefix &/ "file"]
      'If Not hPict Then hPict = Picture["img/16/unknown.png"]
      'hPict = hPict.Copy()

      'If bStartup Then hImage = AddEmblem(hImage, "icon:/32/play")
      If bConflict Then hImage = AddEmblem(hImage, "icon:/32/warning")
      If bLocked Then hImage = AddEmblem(hImage, "icon:/32/lock")
      If bAdded Then hImage = AddEmblem(hImage, "icon:/32/add")

      If iSize Then
        hImage = hImage.Stretch(hImage.Width * iSize / hImage.Height, iSize)
      Endif

      If bLink Then
        hImage = AddLinkEmblem(hImage)
      Endif

      hPict = hImage.Picture

      If Not bNoStartup Then Picture[sCacheKey] = hPict

    Endif

  Endif

  Return hPict

End

Public Sub GetParentClass(sPath As String) As String

  Dim hFile As File
  Dim sLine As String

  If Left(sPath) <> "/" Then sPath = FindPath(sPath)

  Try hFile = Open sPath For Input
  ' Possible, if sPath is a broken symbolic link
  If Error Then Return

  While Not Eof(hFile)
    Line Input #hFile, sLine
    sLine = Trim(sLine)
    If Not sLine Then Continue
    If Left(sLine) = "'" Then Continue
    If sLine Like "INHERITS *" Then
      Highlight.Analyze(sLine)
      sLine = Highlight.Symbols[1]
      'sLine = Scan(sLine, "INHERITS *")[0]
      If Comp(sLine, File.BaseName(sPath), gb.IgnoreCase) = 0 Then sLine = ""
      Return sLine
    Endif
    If sLine Like "CREATE" Then Continue
    If sLine Like "EXPORT" Then Continue
    If sLine Like "CREATE *" Then Continue
    If sLine Like "EXPORT *" Then Continue
    Break
  Wend

End

Private Sub AddFile(sDir As String, sFile As String, Optional bAfter As Boolean, Optional bIgnoreInheritance As Boolean) As Boolean

  Dim bIgnore As Boolean
  Dim sPath As String
  Dim sKey As String
  Dim bShow As Boolean
  Dim sExt As String
  Dim sParent As String
  Dim sParentClass As String
  Dim hImage As Image
  Dim hPict As Picture
  Dim bChecked As Boolean
  Dim bDir As Boolean
  Dim sAfter As String
  Dim hForm As Object
  Dim hModule As CModule
  Dim bSource As Boolean

  If $cProjectFilter And If Not $cProjectFilter.Exist(sDir &/ sFile) Then Return

  sPath = sDir &/ sFile
  sKey = sPath
  sParent = sDir

  If sDir = Project.Dir Then
    sParent = KEY_MISC
  Else If sDir = Project.Dir &/ ".hidden" Then
    sParent = KEY_PROJECT
  Else If sDir = SourceDir Then
    sParent = KEY_SOURCE
  Else If sDir = Project.Dir &/ ".connection" Then
    sParent = KEY_CONNECTION
  Endif

  With Stat(sPath)

    If .Hidden Then Return

    bShow = False
    bSource = IsSourcePath(sDir &/ sFile) 'Like (SourceDir &/ "*")

    If IsDir(sPath) Then

      If sFile = "CVS" Or If sFile = "CVSROOT" Then Return

      'IF cDir THEN cDir.Add(sPath)
      bDir = True
      'sIcon = "icon:/small/directory" 'IMAGE_DIR &/ "close.png"
      'bShow = True

    Else

      'IF InStr(.Perm.User & .Perm.Group & .Perm.Other, "x") THEN CONTINUE

      sExt = Lower(File.Ext(sFile))
      bChecked = False

      If bSource Then

        If CModule.Ext.Exist(sExt) Then

          'sIcon = IMAGE_DIR &/ sExt & ".png"
          bShow = sDir = SourceDir
          bChecked = True

          sParent = ""

          If sExt = "class" Then
            For Each hModule In CModule.All
              If Exist(sDir &/ File.BaseName(sFile) & "." & hModule.Key) Then
                bIgnore = True
                Break
              Endif
            Next

            If Not bIgnore Then
              'IF sFile = "ReportContainer.class" THEN STOP
              sParent = FindKey(GetParentClass(sPath))
              If sParent Then
                If File.Ext(sParent) <> "class" Then
                  sParent = ""
                Else If Not ProjectTree.Exist(sParent) Then
                  If Not bIgnoreInheritance Then
                    $aInheritance.Add(sPath)
                    bIgnore = True
                  Else
                    sParent = ""
                  Endif
                  'Else
                  '  $aInheritance.Add(sPath & "\n" & sParentClass)
                Endif
              Endif
            Endif
            ' Else If sExt = "module" Then
            ' Else
            '   'hModule = CModule[sExt]
            '   'sParent = hModule.TreeKey
            '   'If Not hModule.Used Then bIgnore = True
            '   sParent = sDir
          Else If sExt <> "module" Then
            If Not HasModule(sExt) Then
              bIgnore = True
            Endif
          Endif

          If Not sParent Then sParent = sDir
          If sParent = SourceDir Then sParent = KEY_SOURCE

          If $cSourceDir[sFile] <> sPath Then
            bIgnore = True
          Endif

          sFile = File.BaseName(sFile)

        Endif

      Else If IsConnectionPath(sDir &/ sFile) Then

        If Components.Exist("gb.db") And If sExt = "connection" Then
          sFile = File.BaseName(sFile)
        Else
          bIgnore = True
        Endif

      Endif

      If Not bChecked Then

        If Right$(sFile) = "~" Then
          bIgnore = True
        Else If sDir = Project.Dir And If sExt = "gambas" Then
          bIgnore = True
        Endif

      Endif

    Endif

    If sExt = "mine" Or If Left(sExt) = "r" And IsDigit(Mid$(sExt, 2)) Then
      If Exist(sDir &/ File.BaseName(sPath)) Then
        bIgnore = True
      Endif
    Endif

    If Not bIgnore Then

      hPict = GetFileIcon(sPath)

      If bAfter Then
        With ProjectTree
          .MoveTo(sParent)
          .MoveChild
          If Not bDir Then
            While .Available
              If Not IsDir(.Item.Key) Then Break
              sAfter = .Item.Key
              .MoveNext
            Wend
          Endif
          While .Available
            If String.Comp(.Item.Text, sFile, gb.IgnoreCase + gb.Natural) > 0 Then Break
            If bDir And If Not IsDir(.Item.Key) Then Break
            sAfter = .Item.Key
            .MoveNext
          Wend
        End With
      Endif

      With ProjectTree.Add(sKey, sFile, hPict, sParent)
        .Editable = Not IsLocked(sKey)
        'If $cProjectFilter Then .Expanded = True
        If bAfter Then .MoveAfter(sAfter)
        If bShow Then
          ProjectTree.MoveTo(sKey)
          Do
            If ProjectTree.MoveParent() Then Break
            ProjectTree.Item.Expanded = True
          Loop
        Endif
      End With

      If bDir Then
        If Not bSource Then
          ProjectTree.Add(sKey & "/", "",, sKey)
          bDir = False
        Endif
      Endif

      hForm = Files[sKey]
      If hForm Then hForm.Icon = GetFileIcon(sKey, 16)

    Endif

  End With

  Return bDir

End

Private Sub DoRefreshAfter()

  Dim sKey As String
  Dim sParent As String
  Dim iInd As Integer
  Dim iCount As Integer
  Dim aElt As String[]

  If $aInheritance.Count = 0 Then Return

  Do
    iCount = $aInheritance.Count
    For iInd = 0 To iCount - 1
      'aElt = Split($aInheritance[0], "\n")
      'sKey = aElt[0]
      'sParent = aElt[1]
      sKey = $aInheritance[0]
      $aInheritance.Remove(0)
      AddFile(File.Dir(sKey), File.Name(sKey), True)
      ' If ProjectTree.Exist("@"
      '
      ' ProjectTree.Add("@" & sKey
    Next
    If $aInheritance.Count >= iCount Then Break
  Loop

  If $aInheritance.Count Then
    For iInd = 0 To $aInheritance.Max
      sKey = $aInheritance[iInd]
      AddFile(File.Dir(sKey), File.Name(sKey), True, True)
      $aInheritance[iInd] = File.BaseName(sKey)
    Next
    If Not ProjectFilter Then
      FMain.ShowError("<b>" & ("The following classes have circular inheritance:") & "</b>\n\n" & $aInheritance.Join(", "))
    Endif
    $aInheritance.Clear
  Endif

End

Private Procedure AddDir(Optional sDir As String)

  Dim cDir As New String[]
  Dim sFile As String
  Dim aFile As New String[]

  If sDir Then
    cDir.Add(sDir)
  Else
    cDir.Add(Project.Dir)
    If SourceDir <> Project.Dir Then cDir.Add(SourceDir)
  Endif

  $aInheritance.Clear

  Repeat

    sDir = cDir[0]
    aFile.Clear

    '$bGetSource = FALSE

    For Each sFile In Dir(sDir, "*")
      If IsDir(sDir &/ sFile) Then aFile.Add("D" & sFile)
    Next

    For Each sFile In Dir(sDir, "*")
      If Not IsDir(sDir &/ sFile) Then aFile.Add("F" & sFile)
    Next

    aFile.Sort(gb.Language + gb.Natural)

    For Each sFile In aFile

      sFile = Mid$(sFile, 2)
      If AddFile(sDir, sFile, True) Then cDir.Add(sDir &/ sFile)
      'AddFile(sDir, sFile, True)

    Next

    cDir.Remove(0)

  Until cDir.Count = 0

  DoRefreshAfter

End

Public Sub FillDir(sDir As String)

  ProjectTree.MoveTo(sDir)
  If ProjectTree.MoveChild() Then Return
  If ProjectTree.Item.Key <> sDir & "/" Then Return

  Inc Application.Busy
  ProjectTree[sDir & "/"].Delete
  AddDir(sDir)
  Dec Application.Busy

Catch

  Debug Error.Where; ": "; Error.Text
  Dec Application.Busy

End

Private Sub EnsureKey(sKey As String)

  Dim sPath As String
  Dim sElt As String

  sPath = "/"
  For Each sElt In Split(sKey, "/")
    sPath &/= sElt
    If ProjectTree.Exist(sPath) Then FillDir(sPath)
  Next

End

Public Sub SelectKey(sKey As String)

  Dim hModule As CModule
  Dim sBase As String

  EnsureKey(sKey)

  If Not ProjectTree.Exist(sKey) Then
    If Right$(sKey, 6) = ".class" Then
      sBase = Left$(sKey, -6)
      For Each hModule In CModule.All
        sKey = sBase & "." & hModule.Key
        If ProjectTree.Exist(sKey) Then Break
      Next
    Endif
  Endif

  Try ProjectTree[sKey].Selected = True
  Try ProjectTree[sKey].EnsureVisible

End

' PRIVATE SUB UpdateInheritance()
'
'   DIM sPath AS String
'   DIM sParent AS String
'
'   FOR EACH sPath IN Dir(Project.Dir, "*.class")
'
'     IF Exist(Project.Dir &/ File.SetExt(sPath, "form")) THEN CONTINUE
'
'     sParent = GetParentClass(sPath)
'     IF sParent THEN
'       sParent = FindKey(sParent)
'       IF File.Ext(sParent) <> "class" THEN sParent = ""
'     ENDIF
'   ENDIF
'   IF NOT sParent THEN
'     sParent = KEY_CLASS
'   ENDIF
'
'   NEXT
'
' END

Public Sub RefreshRoot()

  ProjectTree[Project.Dir].Picture = GetIcon(Project.Dir, 16)

End

Private Sub RefreshSourceCache()

  Dim sPath As String
  Dim hForm As Object

  $cSourceDir = New Collection(gb.IgnoreCase)

  For Each sPath In RDir(SourceDir, "*", gb.File + gb.Directory, True)
    If CModule.Ext.Exist(File.Ext(sPath)) Then
      $cSourceDir[File.Name(sPath)] = SourceDir &/ sPath
    Endif
  Next

  For Each hForm In Files
    If IsSourcePath(hForm.Path) Then hForm.Path = $cSourceDir[File.Name(hForm.Path)]
  Next

End

Private Sub UpdateTitle()

  Dim sTitle As String

  sTitle = Name & " " & MajorVersion & "." & MinorVersion & "." & ReleaseVersion
  If ReadOnly Then sTitle &= " [" & ("read-only") & "]"
  sTitle &= " - " & Application.Title
  If Application.Version Like "*.99.*" Then sTitle &= " - " & ("ALPHA VERSION, USE AT YOUR OWN RISK! :-)")
  FMain.Title = sTitle

End

Private Sub AddPathToFilter(sPath As String)

  $cProjectFilter[sPath] = True
  While Len(sPath) > Len(Project.Dir)
    sPath = File.Dir(sPath)
    $cProjectFilter[sPath] = True
  Wend

End

Private Sub InitProjectFilter()

  Dim sPath As String
  Dim sFile As String
  Dim bVal As Boolean
  Dim sFilter As String

  $cProjectFilter = Null
  If Not ProjectFilter Then Return

  If ProjectFilter = FILTER_ADDED Then

    $cProjectFilter = New Collection

    For Each AddedPaths
      sPath = AddedPaths.Key
      AddPathToFilter(sPath)
    Next

  Else If ProjectFilter = FILTER_EXPORTED Then

    $cProjectFilter = New Collection

    For Each sPath In $cSourceDir
      If IsExported(sPath) Then AddPathToFilter(sPath)
    Next

  Else

    sFilter = String.LCase(ProjectFilter)

    $cProjectFilter = New Collection

    For Each sFile In RDir(Project.Dir)

      sPath = Project.Dir &/ sFile

      If IsDir(sPath) Then Continue
      If Right(sPath) = "~" Then Continue
      If Left(File.Name(sFile)) = "." Then Continue
      If InStr(sPath, "/.svn/") Then Continue

      sFile = File.Name(sFile)
      If sPath Begins (Project.Dir &/ ".src") Then sFile = File.BaseName(sFile)
      If InStr(String.LCase(sFile), sFilter) = 0 Then Continue

      AddPathToFilter(sPath)

    Next

  Endif

End

Private Sub DoRefresh(Optional bReset As Boolean)

  Dim sFile As String
  Dim sDir As String
  Dim sKey As String
  Dim sKeyReset As String
  Dim hFile As Object
  Dim sPath As String
  Dim sFamily As String
  Dim hModule As CModule

  '$bDisplayForm = Settings["/DisplayForm"]

  If $iNoRefresh Then Return

  If Not bReset Then
    sKeyReset = ProjectTree.Key
  Endif

  RefreshSourceCache
  VersionControl.CheckPaths()
  InitProjectFilter

  With ProjectTree

    .Clear()

    .Background = If(Len(ProjectFilter), Color.LightBackground, Color.Default)

    sKey = Project.Dir
    .Add(sKey, Name, GetIcon(Project.Dir, 16))

    .Add(KEY_PROJECT, ("Project"), Picture["icon:/small/directory"], sKey)
    '.Add(KEY_MODULE, ("Modules"), Picture["icon:/small/directory"], sKey)
    '.Add(KEY_CLASS, ("Classes"), Picture["icon:/small/directory"], sKey)
    .Add(KEY_SOURCE, ("Sources"), Picture["icon:/small/directory"], sKey)

    If Components.Exist("gb.db") Then
      .Add(KEY_CONNECTION, ("Connections"), Picture["icon:/small/directory"], sKey)
    Endif

    ' For Each hModule In CModule.All
    '   If hModule.Used Then
    '     .Add(hModule.TreeKey, hModule.NamePlural, Picture["icon:/small/directory"], sKey)
    '   Endif
    ' Next

    .Add(KEY_MISC, ("Data"), Picture["icon:/small/directory"], sKey)

    '$bGetSource = TRUE

    AddDir()
    If Exist(Project.Dir &/ ".hidden") Then AddDir(Project.Dir &/ ".hidden")
    If Exist(Project.Dir &/ ".connection") Then AddDir(Project.Dir &/ ".connection")

  End With

  With ProjectTree
    .MoveFirst
    While .Available
      .Item.Expanded = True
      .MoveNext
    Wend
  End With

  If sKeyReset Then sKey = sKeyReset

  SelectKey(sKey)

  DefineStartup(Startup, True)

  For Each sFamily In CFamily.List
    If Not HasModule(sFamily) Then
      For Each hFile In Files
        sPath = Files.Key
        If Not IsSourcePath(sPath) Then Continue
        If Exist(File.SetExt(sPath, sFamily)) Then
          Files.Remove(sPath)
          hFile.Delete
        Endif
      Next
    Endif
  Next

  ' Path may not exist in the tree if a filter is active

  For Each sPath In AddedPaths
    sPath = AddedPaths.Key
    EnsureKey(sPath)
    Try ProjectTree[sPath].EnsureVisible
  Next

  If $cProjectFilter Then
    For Each $cProjectFilter
      sPath = $cProjectFilter.Key
      EnsureKey(sPath)
      Try ProjectTree[sPath].EnsureVisible
    Next
  Endif

  UpdateTitle
  $bDoRefresh = False

End

Public Sub timRefresh_Timer()

  DoRefresh

End

Private Sub DisableRefresh()

  If $iNoRefresh = 0 Then $bDoRefresh = False
  Inc $iNoRefresh

End

Public Sub Refresh(Optional bReset As Boolean)

  If bReset Or If $iNoRefresh = 0 Then
    DoRefresh(bReset)
  Else
    $bDoRefresh = True
  Endif

End

Private Sub EnableRefresh()

  Dec $iNoRefresh
  If $iNoRefresh = 0 Then
    If $bDoRefresh Then DoRefresh()
  Endif

End

Public Function IsEditor(hFile As Object) As Boolean

  Return Object.Type(hFile) = "FEditor"

End

Public Function IsForm(hFile As Object) As Boolean

  If hFile Then Return Object.Type(hFile) = "FForm"

End

Private Sub IsTextFile(sPath As String) As Boolean

  Dim hFile As File
  Dim sStr As String
  Dim sCar As String
  Dim iInd As Integer
  Dim iCode As Integer
  Dim sTest As String

  hFile = Open sPath
  sStr = Read #hFile, -256

  While sStr
    sCar = String.Left(sStr)
    sStr = Mid$(sStr, Len(sCar) + 1)
    If Not sCar Then Break
    If Len(sCar) = 1 Then
      iCode = Asc(sCar)
      If iCode = &HFE Then Return False
      If iCode = &HFF Then Return False
      If iCode < 32 And If iCode <> 10 And If iCode <> 9 Then Return False
    Else If sStr Then
      Try sTest = Conv(sCar, "UTF-8", "UCS-4LE")
    Endif
    If Error Then Return False
  Wend

  Return True

End

Public Function LoadFile(sPath As String) As Object

  Dim hForm As Object
  Dim bError As Boolean
  Dim sType As String

  'DIM hActive AS Object

  hForm = Files[sPath]

  If Not hForm Then

    Inc Application.Busy

    If VersionControl.InConflict(sPath) Then Error.Raise("File in conflict")

    SetMessage(Subst(("Loading &1..."), File.Name(sPath)))

    'PRINT "Load: "; sPath

    'hActive = ActiveForm

    If IsSourcePath(sPath) Then

      sType = File.Ext(sPath)

      Select Case sType

        Case "module", "class"
          hForm = New FEditor(sPath)

        Case "form", "report"
          If HasModule(sType) Then
            hForm = New FForm(sPath)
          Endif

        Case "webpage"
          If HasModule("webpage") Then
            hForm = New FTextEditor(sPath, Null, True)
          Endif

      End Select

    Else If IsConnectionPath(sPath) Then

      If MConnection.CheckPassword(sPath) Then
        Dec Application.Busy
        Return
      Endif
      hForm = New FConnectionEditor(sPath)

    Endif

    If Not hForm Then

      Select Case Lower(File.Ext(sPath))

        Case "png", "gif", "jpg", "jpeg", "bmp", "xpm"
          hForm = New FIconEditor(sPath)

        Case Else
          ' Check that it is not a binary file
          If Not IsTextFile(sPath) Then
            Dec Application.Busy
            Files[sPath] = Null
            FMain.ShowError(("Cannot open a binary file.") & "\n\n" & sPath, sPath)
            Return
          Endif
          hForm = New FTextEditor(sPath)

      End Select

    Endif

    Files[sPath] = hForm
    If hForm Then
      bError = hForm.LoadFile()
      If bError Then
        Files[sPath] = Null
        Try hForm.Delete
        Dec Application.Busy
        Return
      Endif
      hForm.Icon = GetFileIcon(sPath, 16)
    Endif

    If hForm Then FSearch.OnNewForm(hForm)

    Dec Application.Busy

  Endif

  Return hForm

'Catch

  Dec Application.Busy
  Files[sPath] = Null
  FMain.ShowError(("Cannot open file.") & "\n\n" & Error.Text & "\n" & Error.Where, sPath)

End

Public Function FindPath(sClass As String) As String

  Dim sPath As String

  sPath = $cSourceDir[sClass]
  If sPath Then Return sPath

  sPath = $cSourceDir[sClass & ".class"]
  If sPath Then Return sPath

  sPath = $cSourceDir[sClass & ".module"]
  If sPath Then Return sPath

End

Private Sub FindKey(sClass As String) As String

  Dim hModule As CModule

  Dim sPath As String
  Dim aDir As String[]
  Dim iInd As Integer

  If Not sClass Then Return

  For Each hModule In CModule.All
    sPath = $cSourceDir[sClass & "." & hModule.Key]
    If sPath Then Return sPath
  Next

  Return FindPath(sClass)

End

Public Sub ShowFile(hForm As Form)

  Workspace.Add(hForm)
  Workspace.ActiveWindow = hForm
  hForm.SetFocus

Catch

  FMain.ShowError(("Cannot open file.") & "\n\n" & Error.Text & "\n" & Error.Where)

End

Public Sub OpenFile(sPath As String, Optional iLine As Integer, Optional iColumn As Integer = -1) As Object

  Dim hForm As Object

  If InStr(sPath, "/") = 0 Then sPath = FindPath(sPath)

  Try Stat(sPath, True)
  If Error Then
    FMain.ShowWarning(("File not found!") & "\n" & sPath)
    Project.Refresh
    Return
  Endif

  'IF File.Ext(sPath) = "form" THEN
  '  FProperty.Show
  '  FToolBox.Show
  'ENDIF

  If VersionControl.InConflict(sPath) Then
    FConflict.Run(sPath)
    If VersionControl.InConflict(sPath) Then Return
    RefreshKey(sPath)
  Endif

  LoadFile(sPath)

  hForm = Files[sPath]
  If Not hForm Then Return

  CPosition.Disable

  ShowFile(hForm)

  'hForm.Show

  'IF Object.Type(hForm) = "FEditor" THEN
  '  hForm.Editor.SetFocus
  'ENDIF

  If iLine Then
    hForm.GotoCenter(iLine - 1, iColumn)
  Endif

  CPosition.Enable

  CPosition.SaveCurrent

  Return hForm

End

Public Function ExistForm(sClass As String) As Boolean

  Dim sFamily As String

  For Each sFamily In CFamily.List
    If $cSourceDir.Exist(sClass & "." & sFamily) Then Return True
  Next

End

Public Sub FindForm(sClass As String) As String

  Dim sFamily As String
  Dim sPath As String

  For Each sFamily In CFamily.List
    sPath = $cSourceDir[sClass & "." & sFamily]
    If Exist(sPath) Then Return sPath
  Next

End

Public Sub OpenForm(sName As String, Optional sModule As String = "form", Optional sControl As String)

  Dim sPath As String
  Dim hForm As FForm

  sPath = $cSourceDir[sName & "." & sModule]
  If Exist(sPath) Then
    hForm = OpenFile(sPath)
    If sControl Then hForm.SelectControl(sControl)
  Endif

End

Private Function AddMessage(sVoid As String) As String

  Dim iPos As Integer
  Dim sMsg As String

  If Stat(OUTPUT_FILE).Size = 0 Then

    SetMessage(sVoid)
    Return

  Else

    sMsg = RTrim(File.Load(OUTPUT_FILE))
    iPos = RInStr(sMsg, "\n")
    If iPos Then sMsg = Mid$(sMsg, iPos + 1)
    Return sMsg

  Endif

End

Private Sub TranslateMessage(sErr As String) As String

  Dim aErr As String[]

  aErr = Split(sErr, "\t")
  aErr.Resize(5)
  If Left(aErr[1]) = "#" Then
    Select CInt(Mid$(aErr[1], 2))
      Case 1
        aErr[1] = ("first")
      Case 2
        aErr[2] = ("second")
      Case 3
        aErr[1] = ("third")
      Default
        aErr[1] = Subst(("&1th"), Mid$(aErr[1], 2))
    End Select
  Endif

  Return Subst(Tr$(aErr[0]), aErr[1], aErr[2], aErr[3], aErr[4])

End

Private Sub CompileError(sMsg As String)

  Dim iPos As Integer
  Dim sFile As String
  Dim iLine As Integer
  Dim iColumn As Integer
  Dim hForm As FEditor
  Dim sErr As String
  Dim sInfo As String
  Dim aInfo As String[]

  iPos = RInStr(sMsg, "\n")
  If iPos Then sMsg = Mid$(sMsg, iPos + 1)

  If LCase(sMsg) Begins "gbc: error: " Then

    sMsg = TranslateMessage(Mid$(sMsg, Len("gbc: error: ") + 1))
    SetMessage(sMsg)
    'Message.Error(("Cannot compile the project.") & "\n" & sMsg)

  Else

    iPos = InStr(sMsg, " ")
    sInfo = Left$(sMsg, iPos - 1)
    sMsg = Mid$(sMsg, iPos + 1)

    aInfo = Split(sInfo, ":", "", True)

    sFile = aInfo[0]
    Try iLine = CInt(aInfo[1])
    Try iColumn = CInt(aInfo[2])
    'if iLine = 0 then return

    'sFile = File.Dir(Path) &/ File.Name(sFile)

    hForm = OpenFile($cSourceDir[sFile], iLine, iColumn - 1)

    If sMsg Begins "error: " Then sMsg = Mid$(sMsg, 8)

    sErr = TranslateMessage(sMsg)

    If hForm And If iLine >= hForm.Editor.Lines.Count Then
      SetMessage(File.BaseName(sFile) & ": " & sErr & " " & ("in form definition"))
      sMsg = "<b>" & sErr & "</b> " & ("in form definition")
    Else If iLine >= 1 Then
      SetMessage(File.BaseName(sFile) & "." & CStr(iLine) & ": " & sErr)
      sMsg = "<b>" & sErr & "</b> " & Subst(("in &1:&2."), File.Name(sFile), CStr(iLine))
    Else
      SetMessage(File.BaseName(sFile) & ": " & sErr)
      sMsg = "<b>" & sErr & "</b> " & Subst(("in &1."), File.Name(sFile))
    Endif

  Endif

  If hForm Then
    hForm.ShowErrorMessage(sMsg, "make")
  Else
    FMain.ShowMessage(sMsg, "make")
  Endif

  'Catch

End

' PUBLIC FUNCTION Quote(sPath AS String) AS String
'
'   DIM sQuote AS String
'   DIM iInd AS Integer
'   DIM sCar AS String
'
'   sPath = SConv$(sPath)
'   'DEBUG sPath
'
'   FOR iInd = 1 TO Len(sPath)
'
'     sCar = Mid$(sPath, iInd, 1)
'
'     IF InStr("0123456789abcdefghijklmnopqrstuvwxyz.-/_~", LCase(sCar)) = 0 THEN
'       sCar = "\\" & sCar
'     ENDIF
'
'     sQuote = sQuote & sCar
'
'   NEXT
'
'   RETURN sQuote
'
' END

Private Function Escape(sStr As String) As String

  Dim sRes As String
  Dim iInd As Integer
  Dim sCar As String
  Dim iPos As Integer

  For iInd = 1 To Len(sStr)

    sCar = Mid$(sStr, iInd, 1)
    iPos = InStr("\"\\\n\r\t", sCar)

    If iPos Then sCar = "\\" & Mid$("\"\\nrt", iPos, 1)

    sRes = sRes & sCar

  Next

  Return sRes

End

Public Sub Process_Read()

  Dim sLig As String

  sLig = Read #Last, -4096
  Print sLig;

End

Public Sub Process_Kill()

  Dim sLink As String = Last.Tag

  If sLink Then RefreshKey(sLink)

Catch ' Can fail when Process_Kill is raised after the IDE has been closed

End

Public Sub DeleteCompiledFiles()

  Dim sFile As String

  Exec ["rm", "-rf", Project.Dir &/ ".gambas"] Wait

  If Exist(Project.Dir &/ ".lang") Then
    For Each sFile In Dir(Project.Dir &/ ".lang", "*.pot")
      Try Kill Project.Dir &/ ".lang" &/ sFile
    Next
  Endif

End

Public Function GetCompileCommand(bAll As Boolean, bNoDebug As Boolean, bIDE As Boolean) As String

  Dim sExec As String

  sExec = System.Path &/ "bin/gbc" & System.Version & " -e "
  If bAll Then sExec &= "-a "
  If Not bNoDebug Then sExec &= "-g "
  If Localize Then sExec &= "-t "
  If ControlPublic Then sExec &= "-p "
  If ModulePublic Then sExec &= "-m "
  'sExec = sExec & "-c " & Quote(CLASSES_FILE) & " " & Quote(Project.Dir) & " > " & OUTPUT_FILE & " 2>&1"
  If bIDE Then
    sExec = sExec & Shell$(Project.Dir)
    sExec = sExec & " > " & OUTPUT_FILE & " 2>&1"
  Endif

  Return sExec

End

Private Sub CreateLangDirectory()

  Dim sDir As String = Project.Dir &/ ".lang"

  If Not Exist(sDir) Then
    Mkdir sDir
    VersionControl.AddDir(sDir)
  Endif

End

Private Sub GetInfoFile() As String

  Try Return File.Load(Project.Dir &/ ".info")

End

Public Function Compile(Optional bAll As Boolean, Optional bNoDebug As Boolean, Optional bNoMessage As Boolean) As Boolean

  Dim sExec As String
  Dim sRes As String
  Dim sDir As String
  Dim sPath As String
  Dim iPos As Integer
  Dim sTrans As String
  Dim sBefore, sAfter As String

  If Project.ReadOnly Then Return
  If Project.Running Then Return 'TRUE

  If LockIt() Then Return True

  sDir = Project.Dir

  FProperty.SaveProperty
  Save(True)

  If VersionControl.HasConflict() Then
    UnlockIt()
    If Not bNoMessage Then Message.Warning(("Some project source files are in conflict.\nPlease solve them if you want to compile the project."))
    Return True
  Endif

  SetMessage(("Compiling project") & " " & Project.Name & "...")

  GetVersion

  If bAll Then
    'CleanUp
    DeleteCompiledFiles
    WriteProject(True)
  Endif

  sBefore = GetInfoFile()

  sExec = GetCompileCommand(bAll, bNoDebug, True)
  Shell sExec Wait

  'Stat(OUTPUT_FILE)
  sRes = AddMessage(("Nothing to do."))

  If sRes Then
    If Process.LastValue Then

      UnlockIt()
      If Not bNoMessage Then CompileError(sRes)
      Return True

    Else

      If Localize Then
        WriteProjectTranslation
        sPath = sDir &/ ".lang/.pot"
        Shell "msgcat " & Shell$(sDir) &/ ".lang/*.pot > " & Shell$(sPath) & " 2>/dev/null" Wait
        sTrans = File.Load(sPath)
        iPos = InStr(sTrans, "#,")
        If iPos Then sTrans = Mid$(sTrans, iPos)
        File.Save(sDir &/ ".lang/.pot", sTrans)
      Endif

      'SetMessage(("OK"))
      'FMain.ShowAnimate("Happy")

    Endif
  Endif

  sAfter = GetInfoFile()

  If sAfter <> sBefore Then
    RefreshLibrary(True)
  Endif

  UnlockIt()

End

Private Function CheckRunning(Optional bCompileAll As Boolean) As Boolean

  If Project.Running Then Return
  If Compile(bCompileAll) Then Return True
  If CheckStartupClass() Then Return True

End

Public Sub Run(Optional bCompileAll As Boolean, Optional iDebug As Integer)

  If CheckRunning(bCompileAll) Then Return

  If iDebug = 1 Then
    Design.Step
  Else If iDebug = 2 Then
    Design.Forward
  Else If iDebug = 3 Then
    Design.ReturnFrom
  Else
    Design.Run
  Endif

End

Public Sub Forward()

  If CheckRunning() Then Return
  Design.Forward

End

Public Sub ReturnFrom()

  If CheckRunning() Then Return
  Design.ReturnFrom

End

Public Sub RunUntil(hForm As FEditor, iLine As Integer)

  If CheckRunning() Then Return
  Design.RunUntil(hForm, iLine)

End

Public Sub Step()

  If Compile() Then Return
  If CheckStartupClass() Then Return

  Design.Step

End

Public Sub Save(Optional bReset As Boolean)

  Dim hForm As Object

  Inc Application.Busy

  For Each hForm In Files
    If hForm Is FEditor Then
      If hForm.Save(bReset) Then Break
    Else
      If hForm.Save() Then Break
    Endif

  Next

  Dec Application.Busy

End

Public Sub CopyProject(sSrc As String, sDst As String)

  Dim sFile As String

  Try Mkdir sDst

  For Each sFile In Dir(sSrc)
    If sFile = ".svn" Or sFile = "CVS" Or sFile = ".lock" Then Continue
    If IsDir(sSrc &/ sFile) Then
      CopyProject(sSrc &/ sFile, sDst &/ sFile)
    Else
      Copy sSrc &/ sFile To sDst &/ sFile
    Endif
  Next

End

Public Sub SaveAs()

  FSaveProjectAs.Run

End

Private Sub GetAbsoluteLink(sPath As String, sLink As String) As String

  Dim aPath As String[]
  Dim iInd As Integer
  Dim sElt As String

  If Left$(sLink) = "/" Then Return sLink

  aPath = Split(File.Dir(sPath) &/ sLink, "/")

  While iInd < aPath.Count
    sElt = aPath[iInd]
    If sElt = "." Or If sElt = "" Then
      aPath.Remove(iInd)
    Else If sElt = ".." Then
      If iInd Then
        aPath.Remove(iInd - 1, 2)
        Dec iInd
      Else
        aPath.Remove(iInd)
      Endif
    Else
      Inc iInd
    Endif
  Wend

  Return "/" & aPath.Join("/")

End

Public Sub MakeRelativeLink(sLink As String, sPath As String) As String

  Dim aPath As String[]
  Dim aLink As String[]
  Dim iInd As Integer
  Dim iMax As Integer

  aPath = Split(File.Dir(sPath), "/")
  aLink = Split(sLink, "/")

  iMax = Min(aPath.Max, aLink.Max)
  For iInd = 0 To iMax
    If aPath[iInd] <> aLink[iInd] Then Break
  Next

  If iInd <= iMax And (aPath.Count - iInd) <= 4 Then

    sLink = String$(aPath.Count - iInd, "../")
    While iInd < aLink.Count
      sLink = sLink &/ aLink[iInd]
      Inc iInd
    Wend

  Endif

  Return sLink

End

Public Sub InsertSource(sName As String, sType As String, sDir As String, Optional sTemplate As String, Optional bNoRefresh As Boolean, Optional bNoOpen As Boolean, Optional bLink As Boolean)

  Dim sPath As String
  Dim sData As String

  sPath = sDir &/ File.BaseName(sName) & "." & sType
  If Exist(sPath) Then
    FMain.ShowWarning(("File already exists."))
    Return
  Endif

  If bLink Then
    sTemplate = MakeRelativeLink(sTemplate, sPath)
    Link sTemplate To sPath ' swapped
  Else If Left(sTemplate) = "/" Then
    Try Copy sTemplate To sPath
  Else
    File.Save(sPath, sTemplate)
  Endif

  VersionControl.AddFile(sPath)

  $cSourceDir[sName] = sPath

  If Not bNoRefresh Then Refresh
  If Not bNoOpen Then OpenFile(sPath)

End

Public Sub InsertFile(sName As String, sDir As String, Optional sTemplate As String, Optional bNoOpen As Boolean, Optional bLink As Boolean)

  Dim sPath As String
  Dim sData As String

  sPath = sDir &/ sName

  If Len(sTemplate) Then

    If Exist(sPath) Then
      If IsDir(sPath) Then
        FMain.ShowWarning(("Directory already exists."))
      Else
        FMain.ShowWarning(("File already exists."))
      Endif
      Return
    Endif

    'SHELL "cp " & Quote(sTemplate) & " " & Quote(sPath) WAIT
    If bLink Then
      sTemplate = MakeRelativeLink(sTemplate, sPath)
      Try Link sTemplate To sPath ' swapped
      If Not Exist(sPath) Then
        FMain.ShowError(("Cannot link template file.") & "\n\n" & Error.Text)
        Return
      Endif
    Else
      Try Copy sTemplate To sPath
      If Not Exist(sPath) Then
        FMain.ShowError(("Cannot copy template file.") & "\n\n" & Error.Text)
        Return
      Endif
    Endif

  Endif

  VersionControl.AddFile(sPath)

  Refresh
  'RefreshLibrary

  If Not bNoOpen Then OpenFile(sPath)

End

Public Sub MakeDir(sDir As String) As Boolean

  Dim sPath As String
  Dim sElt As String

  For Each sElt In Split(sDir, "/")
    sPath &/= sElt
    Try Mkdir "/" & sPath
  Next

  If Not Exist(sDir) Or If Not IsDir(sDir) Then Return True

End

Public Function InsertDirectory(sDir As String, Optional bNoVerCtrl As Boolean) As Boolean

  Dim sPath As String
  Dim sElt As String

  If Exist(sDir) Then
    FMain.ShowWarning(("Directory already exists."))
    Return True
  Endif

  sPath = "/"
  For Each sElt In Split(sDir, "/")
    sPath &/= sElt
    If Len(sPath) > Len(Project.Dir) And If Not Exist(sPath) Then
      Try Mkdir sPath
      If Error Then
        Message.Error(Error.Text)
        Return False
      Endif
      If Not bNoVerCtrl Then VersionControl.AddDir(sPath)
      RefreshKey(sPath)
    Endif
  Next

  Return True

End

Private Sub RefreshActivate()

  Dim hActive As Object = ActiveForm

  ActiveForm = Null
  Activate(hActive)

End

Public Sub Activate(hForm As Object)

  Dim sType As String
  Dim bEditor As Boolean
  Dim bTextEditor As Boolean

  If AboutToQuit Then Return

  'Debug hForm

  If hForm Then
    SelectKey(hForm.Path)
    If ActiveForm = hForm Then Return
    'ELSE
    'IF NOT ActiveForm THEN RETURN
  Endif

  ActiveForm = hForm

  If Not ActiveForm Then

    FProperty.HideAll
    FFormStack.HideAll
    FMain.ShowTool(False)
    sType = ""

  Else

    FProperty.RefreshAll
    FFormStack.RefreshAll

    sType = Object.Type(ActiveForm)

    FMain.ShowTool(sType = "FForm") 'Or ShowAlwaysProperty)

  Endif

  bEditor = sType = "FEditor"
  bTextEditor = sType = "FTextEditor"

  Action["break"].Enabled = bEditor
  Action["watch"].Enabled = bEditor
  Action["until"].Enabled = bEditor

  'FFind.OnProjectActivate
  FToolBox.OnProjectActivate

  Try ActiveForm.SetFocus

  FMain.HideDebug(sType = "FConnectionEditor")

  FSearch.Update
  
  CPosition.SaveCurrent
  
End

Public Sub Deactivate(hForm As Object)

  If ActiveForm <> hForm Then Return

  'DEBUG hForm

  'DEBUG "DeActivate: "; hForm.Title

  Select Case Object.Type(hForm)

    Case "FForm"
      FProperty.HideAll
      FFormStack.HideAll
      'FProperty.Hide
      ' FToolBox.Hide

  End Select

End

Private Sub GetVersion() As Boolean

  Dim sDir As String
  Dim sVer As String
  Dim aVer As String[]
  Dim iMajor As Integer
  Dim iMinor As Integer
  Dim iRelease As Integer

  If Not VersionFile Then Return True

  sDir = Project.Dir
  Do
    sDir = File.Dir(sDir)
    If sDir = "/" Then Return True
    If Exist(sDir &/ "VERSION") Then Break
  Loop

  sVer = Trim(File.Load(sDir &/ "VERSION"))

  aVer = Split(Trim(sVer), ".")

  iMajor = aVer[0]
  Try iMinor = aVer[1]

  MajorVersion = iMajor
  MinorVersion = iMinor

  Try iRelease = aVer[2]
  If Not Error Then ReleaseVersion = iRelease

End

Public Function MakeExecutable(Optional bDoNotIncVersion As Boolean, Optional bSilent As Boolean) As Boolean

  Dim sExec As String
  Dim sPath As String
  Dim sExecPath As String
  Dim bOK As Boolean

  If CheckStartupClass() Then Return True

  DisableRefresh

  sExecPath = Project.Dir &/ Project.Name & ".gambas"

  If Not bSilent Then

    sExecPath = GetExecPath()
    If Not Exist(File.Dir(sExecPath)) Then sExecPath = Project.Dir &/ File.Name(sExecPath)

    'IF Dialog.SaveFile() THEN RETURN TRUE
    sExecPath = FMakeExecutable.Run(sExecPath)
    If Not sExecPath Then
      EnableRefresh
      Return
    Endif

    sExecPath = File.SetExt(sExecPath, "gambas")
    If sExecPath Begins (Project.Dir & "/") Then
      ExecPath = Mid$(sExecPath, Len(Project.Dir) + 2)
    Else
      ExecPath = sExecPath
    Endif

  Endif

  SetMessage(("Making executable..."))

  If Compile(True) Then
    EnableRefresh
    Return True
  Endif

  Exec ["rm", "-rf", Project.Dir &/ ".gambas.save"] Wait
  Exec ["cp", "-rf", Project.Dir &/ ".gambas", Project.Dir &/ ".gambas.save"] Wait
  'MOVE Project.Dir &/ ".gambas" TO Project.Dir &/ ".gambas.save"

  If Not Compile(True, Not KeepDebugInfo) Then

    GetVersion()

    sExec = System.Path &/ "bin/gba" & System.Version & " -o " & Shell$(sExecPath) & " " & Shell$(Project.Dir) & " > " & OUTPUT_FILE & " 2>&1"
    Shell sExec Wait
    If Process.LastValue Then Error.Raise(Trim(File.Load(OUTPUT_FILE)))
    'SetMessage(("OK"))

    If Not VersionFile And If Not bDoNotIncVersion Then Inc ReleaseVersion
    WriteProject(True, True)

    If RunAfterMakingExec Then
      Shell Replace(RunAfterMakingExec, "$(FILE)", Shell$(sExecPath)) Wait
    Endif

    UpdateTitle

    bOK = True

  Endif

  Exec ["rm", "-rf", Project.Dir &/ ".gambas"] Wait
  Try Move Project.Dir &/ ".gambas.save" To Project.Dir &/ ".gambas"
  If Error Then Debug Error.Text

_ERROR:

  EnableRefresh
  Return Not bOK

Catch

  FMain.ShowError(("Cannot make executable.") & "\n\n" & Error.Text & "\n" & Error.Where)
  EnableRefresh
  Return True

End

Public Sub ExistClass(sClass As String) As Boolean

  If $cSourceDir.Exist(sClass & ".class") Then Return True
  If $cSourceDir.Exist(sClass & ".module") Then Return True

End

Public Function GetClasses(Optional bFullPath As Boolean) As String[]

  Dim sPath As String
  Dim aClass As New String[]
  Dim sExt As String

  Dim sFile As String
  Dim aModule As New String[]
  Dim bStop As Boolean

  For Each sPath In $cSourceDir

    sExt = File.Ext(sPath)
    If sExt = "class" Or If sExt = "module" Then
      If bFullPath Then
        aClass.Add(sPath)
      Else
        aClass.Add(File.BaseName(sPath))
      Endif
    Endif

  Next

  aClass.Sort(gb.IgnoreCase + gb.Natural)

  'If Not bFullPath Then aModule.Sort

  Return aClass

End

Private Sub CheckProjectVersion(sPath As String) As String

  Dim hFic As File
  Dim sLig As String

  hFic = Open sPath

  Line Input #hFic, sLig
  If sLig = PROJECT_MAGIC_1 Then Return "1.0"
  If sLig = PROJECT_MAGIC_2 Then Return "2.0"
  If sLig <> PROJECT_MAGIC Then Return "?"

End

' Private Sub CreateConnectionDirectory()
'
'   If Libraries.Exist("gb.db") Then
'     Mkdir Project.Dir &/ ".connection"
'   Endif
'
' End

Public Sub ReadProject(Optional bConvert As Boolean)

  Dim hFic As File
  Dim sLig As String
  Dim iPos As Integer
  Dim sKey As String
  Dim sVal As String
  Dim cVer As String[]
  Dim sElt As String
  Dim iElt As Integer
  Dim aMissing As New String[]
  Dim sMsg As String
  Dim hComp As CComponent

  hFic = Open Path For Input

  Components = New String[]
  Libraries = New String[]
  Title = ""
  TabSize = Settings["/DefaultTabSize", 2]
  Arguments = New String[]
  Environment = New String[]
  MajorVersion = 0
  MinorVersion = 0
  ReleaseVersion = 1
  'SnapToGrid = TRUE
  'ShowGrid = TRUE
  Snap = Desktop.Scale 'Settings["/DefaultGridResolution", 8]
  ControlPublic = False
  ModulePublic = False
  KeepDebugInfo = True
  Localize = False
  Description = ""
  Authors = ""
  Icon = ""
  Systems = New String[]
  Menus = New Collection
  Categories = New Collection
  MimeTypes = New String[]
  Groups = New Collection
  ExtraDependencies = New Collection
  ExtraFiles = New Collection
  ExtraDesktop = ""
  SameDependencies = False
  SameFiles = False
  ExtraAutoconfTest = ""
  Prefix = False
  UseRelease = False
  PackageName = ""
  ExecPath = Project.Name & ".gambas"
  SourcePath = ""
  CreateComponent = False
  ComponentState = CComponent.STABLE
  CreateShortcut = False
  RunAfterMakingExec = ""
  Language = ""
  VersionFile = False
  'Stack = 0
  'StackTrace = False
  UseTerminal = False
  Maintainer = ""
  Vendor = ""
  Address = ""
  Url = ""
  License = ""
  CreateEachDirectory = False

  While Not Eof(hFic)

    Line Input #hFic, sLig
    sLig = Trim(sLig)

    If Len(sLig) = 0 Then Continue
    If Left$(sLig, 1) = "#" Then Continue

    iPos = InStr(sLig, "=")
    If iPos = 0 Then Continue

    sKey = Lower$(Trim(Left$(sLig, iPos - 1)))
    sVal = Trim(Mid$(sLig, iPos + 1))

    Select sKey

      Case "title"
        Title = sVal

      Case "startup"
        'DefineStartup(sVal, True)
        Startup = sVal

      Case "component"
        hComp = CComponent.All[sVal]
        If hComp And If Not hComp.Hidden Then
          Components.Add(sVal)
        Else
          aMissing.Add(sVal)
        Endif

      Case "library"
        If bConvert Then
          For Each sVal In MConvert.ConvertComponent(sVal)
            If CComponent.All.Exist(sVal) Then
              If Not Components.Exist(sVal) Then Components.Add(sVal)
            Else
              aMissing.Add(sVal)
            Endif
          Next
        Else
          If Not Libraries.Exist(sVal) Then Libraries.Add(sVal)
        Endif

      Case "tabsize"
        TabSize = Val(sVal)

      Case "arguments"
        Arguments = Split(Unquote(sVal), "\n")

      Case "environment"
        Environment = Split(Unquote(sVal), "\n")

      Case "version"
        cVer = Split(sVal, ".")
        Try MajorVersion = Val(cVer[0])
        Try MinorVersion = Val(cVer[1])
        Try ReleaseVersion = Val(cVer[2])

      Case "versionfile"
        VersionFile = Val(sVal) <> 0

      Case "localize", "translate"
        Localize = Val(sVal) <> 0

      Case "language"
        Language = sVal

      Case "keepdebuginfo"
        KeepDebugInfo = Val(sVal) <> 0

      Case "createshortcut"
        CreateShortcut = Val(sVal) <> 0

      Case "runafter"
        RunAfterMakingExec = sVal

      Case "makecomponent"
        CreateComponent = Val(sVal) <> 0

      Case "alphacomponent"
        If Val(sVal) Then ComponentState = CComponent.UNSTABLE

      Case "state"
        ComponentState = Val(sVal)
        If ComponentState < 0 Or ComponentState > 2 Then ComponentState = CComponent.UNSTABLE

      Case "controlpublic"
        ControlPublic = Val(sVal) <> 0

      Case "modulepublic"
        ModulePublic = Val(sVal) <> 0

      Case "description"
        Description = Unquote(sVal)

      Case "authors"
        Authors = Unquote(sVal)

      Case "icon"
        Icon = sVal

      Case "systems"
        Systems = Split(sVal, ",")

      Case "menus"
        iElt = 0
        For Each sElt In Split(sVal, ",")
          If iElt >= Systems.Count Then Break
          Menus[Systems[iElt]] = sElt
          Inc iElt
        Next

      Case "categories"
        iElt = 0
        For Each sElt In Split(sVal, ",")
          If iElt >= Systems.Count Then Break
          Categories[Systems[iElt]] = sElt
          Inc iElt
        Next

      Case "groups"
        iElt = 0
        For Each sElt In Split(sVal, ",")
          If iElt >= Systems.Count Then Break
          Groups[Systems[iElt]] = sElt
          Inc iElt
        Next

      Case "extradependencies"
        iElt = 0
        For Each sElt In Split(sVal, ",")
          If iElt >= Systems.Count Then Break
          ExtraDependencies[Systems[iElt]] = sElt
          Inc iElt
        Next

      Case "extrafiles"
        iElt = 0
        For Each sElt In Split(sVal, ",")
          If iElt >= Systems.Count Then Break
          ExtraFiles[Systems[iElt]] = sElt
          Inc iElt
        Next

      Case "extraautoconftest"
        ExtraAutoconfTest = Unquote(sVal)

      Case "extradesktop"
        ExtraDesktop = Unquote(sVal)

      Case "prefix"
        Prefix = Val(sVal)

      Case "userelease"
        UseRelease = Val(sVal)

      Case "packagename"
        PackageName = sVal

      Case "maintainer"
        Maintainer = sVal

      Case "vendor"
        Vendor = sVal

      Case "address"
        Address = sVal

      Case "url"
        Url = sVal

      Case "license"
        License = sVal

      Case "execpath"
        ExecPath = sVal

      Case "sourcepath"
        SourcePath = sVal

      Case "useterminal"
        UseTerminal = Val(sVal) <> 0

      Case "createeachdirectory"
        CreateEachDirectory = Val(sVal) <> 0

      Case "samedependencies"
        SameDependencies = Val(sVal) <> 0

      Case "samefiles"
        SameFiles = Val(sVal) <> 0

      Case "mimetypes"
        MimeTypes = Split(sVal, ",", Chr$(34), True)

    End Select

  Wend

  Close hFic

  VersionFile = Not GetVersion()
  
  If aMissing.Count Then
    sMsg = Subst(("Some components are missing: &1"), aMissing.Join(", "))
    If Message.Error(sMsg, ("Continue"), ("Cancel")) = 2 Then
      Error.Raise("")
    Endif
  Endif

  If Not $bTesting Then FMain.UpdateTranslate
  RefreshLibrary
  'CreateConnectionDirectory

End

Public Sub WriteProjectTranslation()

  Dim sPath As String
  Dim hFic As File

  sPath = Project.Dir &/ ".lang/#project.pot"
  Try Kill sPath
  If Localize Then

    CreateLangDirectory

    hFic = Open sPath For Create
    Print #hFic, "# "; Path
    Print #hFic, File.Load("pot-header.txt")
    If Title Then
      Print #hFic, "#: .project:1"
      Print #hFic, "msgid \""; Escape(Title); "\""
      Print #hFic, "msgstr \"\"\n"
    Endif
    If Description Then
      Print #hFic, "#: .project:2"
      Print #hFic, "msgid \""; Escape(Description); "\""
      Print #hFic, "msgstr \"\"\n"
    Endif
    Close #hFic

  Endif

End

Public Sub WriteProject(Optional bComponentDoNotChange As Boolean, Optional bMakeShortcut As Boolean)

  Dim hFic As File
  Dim sLib As String
  Dim sSys As String
  Dim sElt As String
  Dim aElt As String[]
  Dim sPath As String
  Dim sVal As String
  Dim iKey As Integer
  Dim iCount As Integer
  Dim hComp As CComponent
  Dim sShortcut As String

  If Project.ReadOnly Then Return

  If CreateComponent
    ' If bMakeShortcut Then
    '   If Project.CreateShortcut Then
    '     InstallComponent
    '   Else
    '     UninstallComponent
    '   Endif
    ' Endif
  Else
    MakeShortcut(bMakeShortcut)
    If Not bComponentDoNotChange Then RefreshLibrary
  Endif

  ' Creates the .project file

  sPath = Path
  Try Kill sPath & ".tmp"
  hFic = Open sPath & ".tmp" For Create

  Print #hFic, PROJECT_MAGIC
  Print #hFic, "# Compiled with Gambas "; FullVersion
  'PRINT #hFic, "Project="; Name

  If Title Then Print #hFic, "Title="; Title
  If Startup Then Print #hFic, "Startup="; Startup
  'If Stack Then Print #hFic, "Stack="; Stack
  'If StackTrace Then Print #hFic, "StackTrace=1"
  If UseTerminal Then Print #hFic, "UseTerminal=1"
  If Icon Then Print #hFic, "Icon="; Icon

  GetVersion()
  Print #hFic, "Version="; CStr(MajorVersion) & "." & CStr(MinorVersion) & "." & CStr(ReleaseVersion)
  If VersionFile Then Print #hFic, "VersionFile=1"

  For Each hComp In CComponent.All
    If Components.Find(hComp.Key) >= 0 Then
      Print #hFic, "Component="; hComp.Key
    Endif
  Next

  For Each sVal In Libraries
    Print #hFic, "Library="; sVal
  Next

  If Description Then Print #hFic, "Description="; Quote(Description)
  If Authors Then Print #hFic, "Authors="; Quote(Authors)

  If Arguments.Count Then Print #hFic, "Arguments="; Quote(Arguments.Join("\n"))
  If Environment.Count Then Print #hFic, "Environment="; Quote(Environment.Join("\n"))

  Print #hFic, "TabSize="; CStr(TabSize)
  If Localize Then Print #hFic, "Translate=1"
  If Language Then Print #hFic, "Language="; Language
  If Not KeepDebugInfo Then Print #hFic, "KeepDebugInfo=0"
  If CreateShortcut Then Print #hFic, "CreateShortcut=1"
  If RunAfterMakingExec Then Print #hFic, "RunAfter="; RunAfterMakingExec
  If CreateComponent Then Print #hFic, "MakeComponent=1"
  If ControlPublic Then Print #hFic, "ControlPublic=1"
  If ModulePublic Then Print #hFic, "ModulePublic=1"
  If ExecPath <> (Project.Name & ".gambas") Then
    Print #hFic, "ExecPath="; ExecPath
  Endif
  If SourcePath Then Print #hFic, "SourcePath="; SourcePath

  If Maintainer Then Print #hFic, "Maintainer="; Maintainer
  If Vendor Then Print #hFic, "Vendor="; Vendor
  If Address Then Print #hFic, "Address="; Address
  If Url And If Url <> DEFAULT_URL Then Print #hFic, "Url="; Url
  If License Then Print #hFic, "License="; License
  If Prefix Then Print #hFic, "Prefix=1"
  If UseRelease Then Print #hFic, "UseRelease=1"
  If PackageName Then Print #hFic, "PackageName="; PackageName
  If CreateEachDirectory Then Print #hFic, "CreateEachDirectory=1"
  If MimeTypes.Count Then Print #hFic, "MimeTypes="; MimeTypes.Join(",", Chr$(34))
  If ExtraDesktop Then Print #hFic, "ExtraDesktop=" & Quote(ExtraDesktop)

  If Systems.Count Then

    Print #hFic, "Systems="; Systems.Join(",")

    sElt = ""
    For Each sSys In Systems
      sElt = sElt & "," & Menus[sSys]
    Next
    Print #hFic, "Menus="; Mid$(sElt, 2)

    sElt = ""
    For Each sSys In Systems
      sElt = sElt & "," & Categories[sSys]
    Next
    Print #hFic, "Categories="; Mid$(sElt, 2)

    sElt = ""
    For Each sSys In Systems
      sElt = sElt & "," & Groups[sSys]
    Next
    Print #hFic, "Groups="; Mid$(sElt, 2)

    aElt = New String[]
    For Each sSys In Systems
      aElt.Add(ExtraDependencies[sSys])
    Next
    Print #hFic, "ExtraDependencies="; aElt.Join(",")

    If SameDependencies Then Print #hFic, "SameDependencies=1"

    aElt = New String[]
    For Each sSys In Systems
      aElt.Add(ExtraFiles[sSys])
    Next
    Print #hFic, "ExtraFiles="; aElt.Join(",")

    If SameFiles Then Print #hFic, "SameFiles=1"

    If ExtraAutoconfTest Then Print #hFic, "ExtraAutoconfTest=" & Quote(ExtraAutoconfTest)

  Endif

  Close #hFic

  Try Kill sPath
  Move sPath & ".tmp" To sPath

  ' ' Creates the .startup file
  ' ' This is done automatically by the compiler now!
  '
  ' sPath = Project.Dir &/ STARTUP_FILE
  ' Try Kill sPath & ".tmp"
  ' hFic = Open sPath & ".tmp" For Create
  '
  ' Print #hFic, Startup
  ' Print #hFic, Title
  ' Print #hFic, Stack
  ' Print #hFic, If(StackTrace, "1", "0")
  ' Print #hFic, Version
  ' Print #hFic
  '
  ' For Each hComp In CComponent.All
  '   If Libraries.Find(hComp.Key) >= 0 Then
  '     Print #hFic, hComp.Key
  '   Endif
  ' Next
  '
  ' Print #hFic
  '
  ' Close #hFic
  '
  ' Try Kill sPath
  ' Move sPath & ".tmp" To sPath

  WriteProjectTranslation

  FMain.UpdateTranslate
  FMain.UpdateMenu
  UpdateTitle
  'CreateConnectionDirectory

Catch

  FMain.ShowError(("Cannot write project file.") & "\n\n" & Error.Text)

End

Public Sub GetExecPath() As String
  
  If Left(ExecPath) = "/" Then
    Return ExecPath
  Else
    Return Project.Dir &/ ExecPath
  Endif
  
End


Public Sub MakeShortcut(Optional bForce As Boolean)

  Dim sDesktopPath As String
  Dim sPath As String
  Dim sShortcut As String

  If Not CreateShortcut Then Return

  sDesktopPath = Desktop.Path &/ Name & ".desktop"

  If Not bForce Then
    If Not Exist(sDesktopPath) Then Return
  Endif

  sShortcut = File.Load("shortcut.desktop")
  sShortcut = Replace(sShortcut, "$(NAME)", If(Title, Title, Name))
  sShortcut = Replace(sShortcut, "$(EXEC)", GetExecPath())

  sPath = ""
  If Icon And If Exist(Project.Dir &/ Icon) Then
    sPath = Project.Dir &/ Icon
  Endif
  sShortcut = Replace(sShortcut, "$(ICON)", sPath)

  File.Save(sDesktopPath, sShortcut)

Catch

  FMain.ShowError(("Unable to create desktop shortcut.") & "\n\n" & Error.Text & "\n" & Error.Where)

End

Private Sub MakeLink(sSrc As String, sDst As String)

  If Not Exist(sDst) Then Link sSrc To sDst

End

Private Sub RefreshForComponent()

  Dim hForm As Object

  RefreshLibrary(True)

  FFormStack.RefreshAll(, True)

  For Each hForm In Files
    If IsForm(hForm) And If hForm.Visible Then
      hForm.RefreshForComponent
    Endif
  Next

End

' Public Sub InstallComponent()
'
'   Dim sDir As String = Component.UserPath
'   Dim sClass As String
'   Dim sIcon As String
'
'   MakeDir(sDir)
'
'   MakeLink(Project.ExecPath, sDir &/ Name & ".gambas")
'   MakeLink(Project.Dir &/ ".component", sDir &/ Name & ".component")
'
'   sDir = File.Dir(File.Dir(sDir)) &/ "share/gambas" & System.Version & "/info"
'   MakeDir(sDir)
'
'   MakeLink(Project.Dir &/ ".info", sDir &/ Name & ".info")
'   MakeLink(Project.Dir &/ ".list", sDir &/ Name & ".list")
'
'   sDir = File.Dir(sDir) &/ "control" &/ Name
'
'   For Each sClass In GetClasses(True)
'     If Not IsExported(sClass) Then Continue
'     sClass = LCase(File.BaseName(sClass))
'     sIcon = Project.Dir &/ ".hidden/control" &/ sClass & ".png"
'     If Exist(sIcon) Then
'       MakeDir(sDir)
'       MakeLink(sIcon, sDir &/ sClass & ".png")
'     Endif
'   Next
'
'   If Not CComponent.All.Exist(Name) Then
'     CComponent.FullReset
'   Endif
'   If Not Components.Exist(Name) Then
'     Components.Add(Name)
'   Endif
'   RefreshForComponent
'
' Catch
'
'   FMain.ShowError(("Unable to install component.") & "\n\n" & Error.Text & "\n" & Error.Where)
'
' End
'
' Public Sub UninstallComponent()
'
'   Dim sDir As String = Component.UserPath
'   Dim bRefresh As Boolean
'
'   'MakeDir(sDir)
'
'   bRefresh = Exist(sDir &/ Name & ".component")
'
'   Try Kill sDir &/ Name & ".gambas"
'   Try Kill sDir &/ Name & ".component"
'
'   sDir = File.Dir(File.Dir(sDir)) &/ "share/gambas" & System.Version & "/info"
'
'   Try Kill sDir &/ Name & ".info"
'   Try Kill sDir &/ Name & ".list"
'
'   sDir = File.Dir(sDir) &/ "control" &/ Name
'   Exec ["rm", "-rf", sDir] Wait
'
'   If bRefresh Then
'     If CComponent.All.Exist(Name) Then
'       CComponent.FullReset
'     Endif
'     If Not CComponent.All.Exist(Name) Then
'       If Components.Exist(Name) Then
'         Components.Remove(Components.Find(Name))
'       Endif
'       RefreshForComponent
'     Endif
'   Endif
'
' Catch
'
'   FMain.ShowError(("Unable to uninstall component.") & "\n\n" & Error.Text & "\n" & Error.Where)
'
' End

Public Function GetNextEditor(sKey As String) As String

  Dim sFirst As String
  Dim sFile As String
  Dim bNext As Boolean

  If Not sKey Then bNext = True

  For Each sFile In GetClasses(True)

    If bNext Then Return sFile

    If Not sFirst Then
      sFirst = sFile
    Endif

    If sFile = sKey Then
      bNext = True
    Endif

  Next

  If bNext Then Return sFirst

End

Public Function GetPreviousEditor(sKey As String) As String

  Dim sLast As String
  Dim sFile As String

  For Each sFile In GetClasses(True)

    If sFile = sKey Then
      If sLast Then
        Return sLast
      Endif
    Endif

    sLast = sFile

  Next

  Return sLast

End

Public Sub SetMessage(sMsg As String)

  ' If FMain.ShowVisible And If sMsg <> ("OK") Then
  '   FMain.ShowInfo(sMsg)
  ' Endif
  If $bTesting Then Return
  FMain.SetMessage(sMsg)

End

Public Sub DeleteFile(sPath As String)

  Dim sExt As String
  Dim hForm As Object
  Dim bLink As Boolean
  Dim bProject As Boolean
  Dim sName As String
  Dim hModule As CModule
  Dim sPathPot As String
  Dim bReloadComponent As Boolean

  If Not Exist(sPath) Then Return

  bLink = Stat(sPath).Type = gb.Link
  bProject = IsSourcePath(sPath)
  If bProject Then bReloadComponent = IsExported(sPath)

  hForm = Files[sPath]

  If hForm Then
    hForm.Delete
    Files[sPath] = Null
  Endif

  Try ProjectTree.Remove(sPath)

  If Not bLink Then
    Try Kill sPath & "~"
    Try Move sPath To sPath & "~"
  Else
    Try Kill sPath
  Endif

  VersionControl.RemoveFile(sPath)

  If bProject Then

    sName = File.BaseName(sPath)
    sExt = File.Ext(sPath)

    Try Kill Project.Dir &/ ".gambas" &/ UCase(sName)
    sPathPot = Project.Dir &/ ".lang" &/ sName & ".pot"
    If Exist(sPathPot) Then
      Try Kill sPathPot
      VersionControl.RemoveFile(sPathPot)
    Endif

    DeleteFile(File.Dir(sPath) &/ File.BaseName(sPath) & ".class")
    For Each hModule In CModule.All
      DeleteFile(File.Dir(sPath) &/ sName & "." & hModule.Key)
    Next

    $cSourceDir.Remove(File.Name(sPath))

    If sName = Startup Then
      DefineStartup("")
    Endif

    If bReloadComponent Then Compile(True,, True)

  Endif

  'CATCH

  'Message("*Unable to delete file.||" & sPath)
  'Refresh

End

Public Sub DeleteDir(sDir As String, Optional bNoVerCtrl As Boolean)

  Dim sFile As String

  For Each sFile In Dir(sDir, "*~")
    Try Kill sDir &/ sFile
  Next

  If Not bNoVerCtrl And If VersionControl.Enabled() Then

    VersionControl.RemoveDir(sDir)
    If Exist(sDir) Then
      Try Rmdir sDir
      If Error Then Message.Warning(("The directory will be removed at the next commit."))
    Endif

  Else

    Rmdir sDir

  Endif

  Project.RefreshKey(sDir)

End

Private Function CheckStartupClass() As Boolean

  If Startup Then Return

  FMain.ShowWarning(("You must define a startup class or form!"))

  Return True

End

Public Function CheckFileName(sName As String, Optional sDir As String) As String

  Dim iInd As Integer

  If Not sName Then Goto VOID_NAME

  If String.Left$(sName) = "." Then
    iInd = 1
    Goto BAD_START
  Endif

  For iInd = 1 To String.Len(sName)

    If InStr(FILE_FORBIDDEN_CAR, String.Mid$(sName, iInd, 1)) Then Goto BAD_CHAR

  Next

  If Len(sDir) Then
    If Exist(sDir &/ sName) Then Goto ALREADY_EXIST
  Endif

  Return

VOID_NAME:

  Return ("Please type a name.")

BAD_CHAR:

  Return ("This name contains a forbidden character:") & " [ " & String.Mid$(sName, iInd, 1) & " ]"

BAD_START:

  Return ("The name cannot begins with a dot.")

ALREADY_EXIST:

  Return ("This name is already used. Choose another one.")

End

Public Function CheckClassName(sName As String, Optional bCheckNotExist As Boolean) As String

  Dim iInd As Integer
  Dim sCar As String

  If Not sName Then Goto VOID_NAME

  If Not IsAscii(sName) Then Goto BAD_CHAR

  iInd = 1

  If InStr(CLASS_AUTH_FIRST_CAR, LCase(Left(sName))) = 0 Then Goto BAD_CHAR

  For iInd = 2 To Len(sName)
    sCar = LCase(Mid$(sName, iInd, 1))
    If Project.CreateComponent And If InStr(CLASS_AUTH_CAR_COMPONENT, sCar) Then Continue
    If InStr(CLASS_AUTH_CAR & "_", sCar) = 0 Then Goto BAD_CHAR
  Next

  If bCheckNotExist Then
    If Project.Exist(sName) Then Goto ALREADY_EXIST
  Endif

  Return

VOID_NAME:

  Return ("Please type a name.")

BAD_CHAR:

  Return ("This name contains a forbidden character:") & " [ " & String.Mid$(sName, iInd, 1) & " ]" & "\n\n" &
    ("A class name must begin with a letter or an underscore, followed by any letter or digit.")

ALREADY_EXIST:

  Return ("This name is already used. Choose another one.")

End

' Private Sub RenamePathCollection(cCol As Collection, sOld As String, sNew As String)
'
'   Dim aRename As New String[]
'   Dim vVal As Variant
'   Dim sKey As String
'
'   For Each vVal In cCol
'     sKey = cCol.Key
'     If sKey = sOld Or If sKey Begins sOld &/ "/" Then aRename.Add(sKey)
'   Next
'
'   For Each sKey In aRename
'     vVal = cCol[sKey]
'     cCol[sKey] = Null
'     If sKey <> sOld Then
'       sKey = sNew &/ Mid$(sKey, Len(sOld) + 1)
'     Endif
'     cCol[sNew] = vVal
'   Next
'
' End

Private Function RenameOneFile(sDir As String, sName As String, sNewName As String, Optional sExt As String) As String

  Dim sPath As String
  Dim sCheck As String
  Dim hForm As Object
  Dim sNewPath As String
  Dim sNewFormPath As String
  Dim aRename As String[]
  Dim bRecompile As Boolean

  sPath = sDir &/ sName
  If sExt Then sPath = sPath & "." & sExt
  If Not Exist(sPath) Then Return

  sNewPath = sDir &/ sNewName
  If sExt Then sNewPath = sNewPath & "." & sExt

  If Exist(sNewPath) Then
    Error.Raise(("Destination already exists"))
  Endif

  If IsDir(sPath) Then
    If VersionControl.Enabled() Then
      VersionControl.MoveDir(sPath, sNewPath)
      'If Exist(sPath) Then LockedPaths[sPath] = True
    Else
      Move sPath To sNewPath
    Endif
  Else If Stat(sPath).Type = gb.Link Then
    Move sPath To sNewPath
    VersionControl.MoveFile(sPath, sNewPath)
  Else
    Copy sPath To sNewPath
    VersionControl.MoveFile(sPath, sNewPath)
    Try Kill sPath
  Endif

  If sExt Then
    Try Kill Project.Dir &/ ".gambas" &/ UCase(sName)
    If Not Error Then bRecompile = True
    'Try Kill Project.Dir &/ ".list"
    'Try Kill Project.Dir &/ ".info"
    'Debug sDir &/ ".gambas" &/ UCase(sName); ": "; Exist(sDir &/ ".gambas" &/ UCase(sName))
  Endif

  ' Update source cache

  aRename = New String[]
  For Each sCheck In $cSourceDir
    If sCheck = sPath Or If sCheck Begins sPath &/ "/" Then aRename.Add(sCheck)
  Next

  For Each sCheck In aRename

    If sCheck = sPath Then
      $cSourceDir[File.Name(sPath)] = Null
      $cSourceDir[File.Name(sNewPath)] = sNewPath
    Else
      sNewFormPath = sNewPath &/ Mid$(sCheck, Len(sPath) + 1)
      $cSourceDir[File.Name(sPath)] = Null
      $cSourceDir[File.Name(sNewFormPath)] = sNewFormPath
    Endif

  Next

  ' Update Files collection

  aRename.Clear
  For Each hForm In Files
    sCheck = hForm.Path
    If sCheck = sPath Or If sCheck Begins sPath &/ "/" Then
      If Not aRename.Exist(sCheck) Then aRename.Add(sCheck)
    Endif
  Next

  For Each sCheck In aRename

    hForm = Files[sCheck]
    Files[sCheck] = Null

    If sCheck = sPath Then
      hForm.Rename(sNewName, sNewPath)
      Files[sNewPath] = hForm
    Else
      sNewFormPath = sNewPath &/ Mid$(sCheck, Len(sPath) + 1)
      hForm.Rename(hForm.Name, sNewFormPath)
      Files[sNewFormPath] = hForm
    Endif

  Next

  'RenamePathCollection(LockedPaths, sPath, sNewPath)
  'RenamePathCollection(AddedPaths, sPath, sNewPath)

  'If bRecompile Then Compile

  Return sNewPath

End

Public Sub GetClassesOnly() As String[]

  Dim sPath As String
  Dim sFile As String
  Dim aClass As New String[]
  Dim sClass As String

  For Each sPath In $cSourceDir
    sFile = File.Name(sPath)
    If File.Ext(sFile) <> "class" Then Continue
    sClass = File.BaseName(sFile)
    If ExistForm(sClass) Then Continue
    aClass.Add(sClass)
  Next

  Return aClass.Sort(gb.Natural)

End

Private Sub RefreshInheritance()

  Dim sClass As String
  Dim sKey As String

  $aInheritance.Clear

  For Each sKey In $cSourceDir
    If Not File.Ext(sKey) = "class" Then Continue
    Try ProjectTree[sKey].Delete
    $aInheritance.Add(sKey)
  Next

  DoRefreshAfter

End

Public Sub RefreshKey(sKey As String, Optional sOld As String)

  If Not sKey Then Return
  If Not sOld Then sOld = sKey

  EnsureKey(sOld)
  Try ProjectTree[sOld].Delete
  If Error Then
    If sOld <> sKey Then Return
  Endif

  If Not Exist(sKey) Then Return

  If IsSourcePath(sKey) And If File.Ext(sKey) = "class" And If Not ExistForm(File.BaseName(sKey)) Then
    RefreshInheritance
    Return
  Endif

  If AddFile(File.Dir(sKey), File.Name(sKey), True) Then AddDir(sKey)
  'If IsDir(sKey) Then AddDir(sKey)

  If sOld <> sKey And If Exist(sOld) Then
    If AddFile(File.Dir(sOld), File.Name(sOld), True) Then AddDir(sOld)
    'If IsDir(sOld) Then AddDir(sOld)
  Endif

End

Public Sub RenameFile(sPath As String, sNewName As String)

  Dim sName As String
  Dim sExt As String
  Dim sDir As String
  Dim sNewPath As String
  Dim sMsg As String
  Dim sFamily As String

  sDir = File.Dir(sPath)
  sExt = File.Ext(sPath)

  If Not IsDir(sPath) And If Project.IsSourcePath(sPath) Then

    sName = File.BaseName(sPath)
    If sName = sNewName Then Return

    If UCase(sName) <> UCase(sNewName) Then
      sMsg = CheckClassName(sNewName, True)
      If sMsg Then Error.Raise(sMsg)
    Endif

    If sName = Startup Then
      Startup = sNewName
      WriteProject(True)
    Endif

    sNewPath = RenameOneFile(sDir, sName, sNewName, sExt)

    If CFamily.List.Exist(sExt) Then
      RenameOneFile(sDir, sName, sNewName, "class")
    Else If sExt = "class" Then
      For Each sFamily In CFamily.List
        If Exist(sDir &/ sName & "." & sFamily) Then RenameOneFile(sDir, sName, sNewName, sFamily)
      Next
    Endif
    
  Else

    If Project.IsConnectionPath(sPath) Then sNewName = File.SetExt(sNewName, ".connection")

    sName = File.Name(sPath)
    If sName = sNewName Then Return

    sMsg = CheckFileName(sNewName)
    If sMsg Then Error.Raise(sMsg)

    sNewPath = RenameOneFile(sDir, sName, sNewName)

  Endif

  RefreshKey(sNewPath, sPath)
  'AddFile(File.Dir(sNewPath), File.Name(sNewPath), TRUE)
  'IF IsDir(sNewPath) THEN AddDir(sNewPath)

  Try ProjectTree[sNewPath].Selected = True
  Try ProjectTree[sNewPath].EnsureVisible

Catch

  sMsg = Error.Text
  RefreshKey(sPath)
  FMain.ShowError(Subst(("Unable to rename '&1'") & "\n\n" & sMsg, File.Name(sPath)), sPath)

End

Public Function Exist(sName As String) As Boolean

  Return Project.GetClasses().Find(sName, gb.IgnoreCase) >= 0

End

Private Function LockIt() As Boolean

  If Application.Busy Then Return True
  Inc Application.Busy
  'PRINT "Lock"

End

Private Sub UnLockIt()

  If Application.Busy < 1 Then Return
  Dec Application.Busy

End

' Private Sub LoadRecent()
'
'   Dim nRecent As Integer
'   Dim hMenu As Menu
'   Dim iInd As Integer
'   Dim sPath As String
'
'   nRecent = Settings["/Recent/Count", 0]
'
'   Recent.Clear
'   RecentDate.Clear
'
'   For iInd = 1 To nRecent
'     sPath = Settings["/Recent/File[" & CStr(iInd) & "]"]
'     If sPath Then
'       If Exist(sPath) Then
'         Recent.Add(sPath)
'         RecentDate.Add(CDate(Settings["/Recent/Date[" & CStr(iInd) & "]"]))
'         If Recent.Count >= DEFAULT_MAX_RECENT Then Break
'       Endif
'     Endif
'   Next
'
' End

' Private Sub AddRecent(sPath As String)
'
'   Dim iInd As Integer
'   Dim nMax As Integer
'
'   If Right$(sPath) = "/" Then sPath = Left$(sPath, -1)
'
'   'sPath = "(" & File.BaseName(sPath) & ") " & File.Dir(sPath)
'
'   While iInd < Recent.Count
'
'     If Recent[iInd] = sPath Then
'       Recent.Remove(iInd)
'       RecentDate.Remove(iInd)
'     Else
'       Inc iind
'     Endif
'
'   Wend
'
'   Recent.Add(sPath, 0)
'   RecentDate.Add(CStr(Date(Now)), 0)
'
'   'nMax = Settings["/Recent/Max", DEFAULT_MAX_RECENT]
'   While Recent.Count > DEFAULT_MAX_RECENT
'     Recent.Remove(Recent.Max)
'     RecentDate.Remove(RecentDate.Max)
'   Wend
'
'   SaveRecent
'
' End

' Private Sub SaveRecent()
'
'   Dim iInd As Integer
'
'   Settings.Clear("/Recent")
'
'   Settings["/Recent/Count"] = Recent.Count
'
'   For iInd = 0 To Recent.Count - 1
'     Settings["/Recent/File[" & CStr(iInd + 1) & "]"] = Recent[iInd]
'     Settings["/Recent/Date[" & CStr(iInd + 1) & "]"] = CStr(RecentDate[iInd])
'   Next
'
'   Settings.Save
'
' End

' Public Sub ClearRecent()
'
'   Recent.Clear
'   RecentDate.Clear
'   SaveRecent
'
' End

Public Function CheckProjectName(sName As String, Optional sDir As String) As String

  Dim iInd As Integer
  Dim sCar As String

  sName = Trim(sName)

  If Not sName Then
    Return ("Please type a project name.")
  Endif

  For iInd = 1 To Len(sName)

    sCar = Mid$(sName, iInd, 1)

    If iInd = 1 Then
      If sCar = "." Then Return ("The project name cannot begin with a dot.")
    Endif

    If Asc(sCar) > 127 Then Return ("Non-ASCII characters are forbidden in a project name.")
    If InStr(" ?*/\\", sCar) Then Return ("The following characters are forbidden in a project name: ? * / \\ SPACE")

  Next

  If sDir Then
    sDir &/= sName
    If Exist(sDir &/ PROJECT_FILE) Then
      Return ("This project already exists.")
    Else If Exist(sDir) Then
      If IsDir(sDir) Then
        Return Subst(("The project directory already exists."), sDir)
      Else
        Return Subst(("The project directory cannot be created because a file with the same name already exists."), sDir)
      Endif
    Endif
  Endif

End

Public Sub MakeSourcePackageTo(sPath As String)

  Dim sCmd As String
  Dim sOpt As String

  Inc Application.Busy
  
  Save
  
  If Right$(sPath, 3) = ".gz" Then
    sOpt = "z"
  Else If Right$(sPath, 4) = ".bz2" Then
    sOpt = "j"
  Else If Right$(sPath, 3) = ".xz" Then
    sOpt = "J"
  Endif

  sCmd = "cd " & Shell$(File.Dir(Project.Dir)) & ";"
  sCmd &= " tar cfvh" & sOpt & " " & Shell$(sPath)
  sCmd &= " --exclude=" & Shell$(".gambas/*")
  sCmd &= " --exclude=" & Shell$("*~")
  sCmd &= " --exclude=" & Shell$("core.*")
  sCmd &= " --exclude=" & Shell$(".lock")
  sCmd &= " --exclude=" & Shell$(".lang/*.pot")
  sCmd &= " --exclude=" & Shell$(".lang/.pot")
  sCmd &= " --exclude=" & Shell$(".xvpics")
  sCmd &= " --exclude=" & Shell$(".svn")
  sCmd &= " " & Shell$(File.Name(Project.Dir)) & " > /dev/null"

  Shell sCmd Wait

  Dec Application.Busy

End

Public Sub MakePackage()

  Dim sDir As String = SourcePath

  If Not sDir Then sDir = System.User.Home

  Dialog.Path = sDir &/ Name & "-" & Subst("&1.&2", MajorVersion, MinorVersion) & IIf(ReleaseVersion > 0, "." & ReleaseVersion, "") & ".tar.gz"
  Dialog.Title = ("Create source package")
  Dialog.Filter = ["*.tar.gz", ("Source packages"), "*.tar.bz2", ("Source packages"), "*.tar.xz", ("Source packages")]
  Dialog.AutoExt = True

  If Dialog.SaveFile() Then Return

  If File.Dir(Dialog.Path) <> System.User.Home Then
    SourcePath = File.Dir(Dialog.Path)
    Project.WriteProject
  Endif

  MakeSourcePackageTo(Dialog.Path)

End

Public Sub RefreshForm()

  Dim hFile As Object

  For Each hFile In Project.Files

    If Object.Type(hFile) = "FForm" Then
      hFile.Refresh
    Endif

  Next

End

Public Sub RefreshEditor()

  Dim hFile As Object

  For Each hFile In Project.Files

    If Project.IsEditor(hFile) Then
      hFile.Refresh
    Endif

  Next

End

Public Sub RefreshLibrary(Optional bForce As Boolean)

  Dim sLib As String
  Dim sClass As String
  Dim aLib As New String[]
  Dim hComp As CComponent
  Dim sLibComp As String

  ' Sort components

  For Each hComp In CComponent.All
    If Components.Find(hComp.Key) >= 0 Then
      aLib.Add(hComp.Key)
    Endif
  Next
  Components = aLib.Copy()

  For Each sLib In Libraries
    aLib.Add(File.Name(sLib))
  Next

  sLibComp = aLib.Join(" ")

  If sLibComp <> $sOldRefreshLibrary Or If bForce Then

    CComponent.Reset

    For Each sLib In Components
      CComponent.All[sLib].Load
    Next

    For Each sLib In Libraries
      CComponent.AddLibrary(sLib)
    Next

    If Not $bTesting Then
      CComponent.LoadProjectComponent
      FToolBox.RefreshToolbar(bForce)
      FCompletion.RefreshLibrary
      FProperty.RefreshAll
      'Why refreshing the project?
      'Project.Refresh
    Endif

    $sOldRefreshLibrary = sLibComp

  Endif

End

Public Function IsSourcePath(sPath As String) As Boolean

  Dim sExt As String

  If SourceDir <> {Dir} Then Return sPath & "/" Begins SourceDir &/ "/"

  If Left(sPath) = "/" Then
    If File.Dir(sPath) <> SourceDir Then Return
  Endif

  sExt = File.Ext(sPath)
  If CModule.Ext.Exist(sExt) Then Return True

End

Public Function IsFormPath(sPath As String) As Boolean

  If Not IsSourcePath(sPath) Then Return

  If File.Ext(sPath) = "class" Then Return
  Return Exist(File.SetExt(sPath, "class"))

End

Public Function IsImagePath(sPath As String) As Boolean

  Return IMAGE_EXT.Exist(File.Ext(sPath))

End

Public Sub IsConnectionPath(sPath As String) As Boolean

  Return sPath Begins Project.Dir &/ ".connection" &/ "/"

End

Public Sub IsHiddenPath(sPath As String) As Boolean

  Return sPath Begins Project.Dir &/ ".hidden" &/ "/"

End

Public Function StripPath(sPath As String) As String

  Dim sDir As String

  sDir = Project.Dir
  If Right$(sDir) <> "/" Then sDir = sDir & "/"

  If Left$(sPath, Len(sDir)) = sDir Then
    Return Mid$(sPath, Len(sDir) + 1)
  Else
    Return sPath
  Endif

End

Public Sub RunTool(sTool As String)

  Dim aExec As New String[]

  aExec.Add(System.Path &/ "bin" &/ sTool & ".gambas")
  aExec.Add(Project.Dir)

  Exec aExec

End

Public Function GetExamples(Optional sParent As String) As String[]

  Dim sFile As String
  Dim sFile2 As String
  Dim aList As New String[]

  If sParent Then

    If sParent = "." Then sParent = ""

    If Exist(EXAMPLES_DIR &/ sFile &/ ".project") Then Return

    For Each sFile In Dir(EXAMPLES_DIR &/ sParent)
      If Left(sFile) = "." Then Continue
      'IF Exist(EXAMPLES_DIR &/ sParent &/ sFile &/ ".project") THEN
      aList.Add(sParent &/ sFile)
      'ENDIF
    Next

  Else If IsDir(EXAMPLES_DIR) Then

    For Each sFile In Dir(EXAMPLES_DIR, "*", gb.Directory)
      If Left(sFile) = "." Then Continue
      If Exist(EXAMPLES_DIR &/ sFile &/ ".project") Then
        aList.Add(sFile)
      Else
        For Each sFile2 In Dir(EXAMPLES_DIR &/ sFile, "*", gb.Directory)
          If Left(sFile2) = "." Then Continue
          aList.Add(sFile &/ sFile2)
        Next
      Endif
    Next

  Endif

  aList.Sort(gb.Natural)

  'Finally

  Return aList

End

Public Sub DefineStartup(sPath As String, Optional bDoNotWrite As Boolean)

  sPath = File.BaseName(sPath)
  If Not Project.Exist(sPath) Then sPath = ""

  Swap Startup, sPath
  If sPath Then RefreshKey(FindKey(sPath))
  If Startup Then RefreshKey(FindKey(Startup))

  If Not bDoNotWrite Then
    WriteProject(True)
    Compile
  Endif

Catch

End

Public Sub GetUniqueName(sDir As String, sName As String, Optional sSuffix As String = "&1") As String

  Dim iInd As Integer
  Dim sDest As String
  Dim sExt As String
  Dim sPath As String

  sDest = sDir &/ sName

  While Exist(sDest)
    Inc iInd
    sExt = File.Ext(sName)
    If sExt Then
      sDest = sDir &/ File.BaseName(sName) & Subst(sSuffix, CStr(iInd)) & "." & sExt
    Else
      sDest = sDir &/ sName & Subst(sSuffix, CStr(iInd))
    Endif
  Wend

  Return File.Name(sDest)

End

Public Sub GetUniqueSourceName(sName As String) As String

  Dim iInd As Integer
  Dim sNewName As String
  Dim sExt As String
  Dim sPath As String

  sNewName = sName

  While $cSourceDir.Exist(sNewName)
    Inc iInd
    sExt = File.Ext(sName)
    sNewName = File.BaseName(sName) & CStr(iInd) & "." & File.Ext(sName)
  Wend

  Return sNewName

End

Public Sub CopyFile(sSrc As String, sDst As String)

  Dim sDest As String

  sDest = File.Dir(sDst) &/ GetUniqueName(File.Dir(sDst), File.Name(sDst), " (&1)")
  Copy sSrc To sDest

  VersionControl.AddFile(sDest)

  RefreshKey(sDest)
  SelectKey(sDest)

Catch

  Message.Error(Subst(("Cannot copy file &1."), sSrc) & "\n\n" & Error.Text)

End

Public Sub LinkFile(sSrc As String, sDst As String)

  Dim sDest As String
  Dim aDst As String[]
  Dim aSrc As String[]
  Dim sDir As String
  Dim bDir As Boolean

  bDir = IsDir(sSrc)

  'If IsDir(sSrc) Then
  '  Message.Warning(("Linking a directory is forbidden."))
  '  Return
  'Endif

  sDest = File.Dir(sDst) &/ GetUniqueName(File.Dir(sDst), File.Name(sDst), " (&1)")
  If sSrc Begins Project.Dir &/ "/" Then

    aDst = Split(File.Dir(Mid$(sDest, Len(Project.Dir) + 2)), "/")

    sSrc = Mid$(sSrc, Len(Project.Dir) + 2)
    aSrc = Split(File.Dir(sSrc), "/")

    While aDst.Count > 0 And aSrc.Count > 0
      If aSrc[0] <> aDst[0] Then Break
      aDst.Remove(0)
      aSrc.Remove(0)
    Wend

    sSrc = String(aDst.Count, "../") & aSrc.Join("/") &/ File.Name(sSrc)

  Endif

  If bDir Then RefreshSourceCache

  Link sSrc To sDest ' swapped
  VersionControl.AddFile(sDest)

  If bDir Then RefreshSourceCache

  RefreshKey(sDest)
  SelectKey(sDest)

Catch

  FMain.ShowError(Subst(("Cannot create link &1."), sSrc) & "\n\n" & Error.Text, sSrc)

End

Public Sub MoveFile(sSrc As String, sDst As String, Optional bOther As Boolean)

  Dim hForm As Object
  Dim sLink As String
  Dim sDir As String
  Dim sPath As String
  Dim aMove As String[]
  Dim bIsDir As Boolean

  If sSrc = sDst Then Return

  If Exist(sDst) Then Error.Raise(("Destination already exists"))

  If Len(sDst) > Len(sSrc) And If Left(sDst, Len(sSrc)) = sSrc Then Error.Raise(("Cannot move a directory inside itself."))

  bIsDir = IsDir(sSrc)

  If bOther And If Not bIsDir Then

    sDir = File.Dir(sSrc)
    For Each sSrc In Dir(sDir, File.BaseName(sSrc) & ".*")
      MoveFile(sDir &/ sSrc, File.Dir(sDst) &/ sSrc)
    Next
    Return

  Endif

  With Stat(sSrc)
    If .Type = gb.Link Then
      sLink = GetAbsoluteLink(sSrc, .Link)
      ' If Left(sLink) <> "/" Then
      '   sDir = File.Dir(sSrc)
      '   While Left(sLink, 3) = "../"
      '     sLink = Mid(sLink, 4)
      '     sDir = File.Dir(sDir)
      '   Wend
      '   sLink = sDir &/ sLink
      ' Endif
      DeleteFile(sSrc)
      LinkFile(sLink, sDst)
      Return
    Endif
  End With

  If bIsDir Then
    'Move sSrc To sDst
    If VersionControl.Enabled() Then
      VersionControl.MoveDir(sSrc, sDst)
    Else
      Move sSrc To sDst
    Endif
    'If Exist(sSrc) Then LockedPaths[sSrc] = True
  Else
    Copy sSrc To sDst
    If Right(sSrc) <> "~" Then VersionControl.MoveFile(sSrc, sDst)
    Try Kill sSrc
  Endif

  hForm = Files[sSrc]
  If hForm Then
    hForm.Rename(File.BaseName(sDst), sDst)
    Files[sSrc] = Null
    Files[sDst] = hForm
  Endif

  If $cSourceDir And If IsSourcePath(sSrc) Then
    If bIsDir Then
      RefreshSourceCache
    Else
      $cSourceDir[File.Name(sSrc)] = Null
      $cSourceDir[File.Name(sDst)] = sDst
    Endif
  Endif

  RefreshKey(sDst, sSrc)

  'Refresh
  SelectKey(sDst)

Catch

  FMain.ShowError(Subst(("Cannot move file &1."), File.Name(sSrc)) & "\n\n" & Error.Text, sSrc)

End

' PUBLIC SUB RefreshToolbox()
'
'   FToolBox.ClearToolbar
'
' END

Public Function GetNewName(sPrefix As String, Optional sDir As String) As String

  Dim iInd As Integer
  Dim sName As String
  Dim aFile As String[]
  Dim iFile As Integer

  Do
    Inc iInd
    sName = sPrefix & iInd
    If sDir Then
      If Not Exist(sDir) Then Return sName
      aFile = Dir(sDir, sName & ".*")
      iFile = 0
      While iFile < aFile.Count
        If Right(aFile[iFile]) = "~" Then
          aFile.Remove(iFile)
        Else
          Inc iFile
        Endif
      Wend
      If aFile.Count = 0 And If Not Exist(sDir &/ sName) Then Return sName
    Else
      If Not Project.Exist(sName) Then Return sName
    Endif
  Loop

End

Public Sub ResetScan()

  Dim hFile As Object

  For Each hFile In Files
    Try hFile.Scan = Null
  Next

End

Public Function HasModule(sType As String) As Boolean

  'If sType = "class" Or If sType = "module" Then Return True
  Return CModule[sType].Used

End

Public Sub MakeInstall()

  'Dim iRelease As Integer = Project.ReleaseVersion

  If MakeExecutable(True, True) Then Return
  If FMakeInstall.ShowModal() Then Return

  'Project.ReleaseVersion = iRelease
  'Project.WriteProject

End

Public Sub InitMove(hForm As Form)

  'hForm.Move(Int(Rnd(0, Max(0, Workspace.Width - hForm.Width - 8))), Int(Rnd(0, Max(0, Workspace.Height - hForm.Height - 8))))

End

Public Function StretchIcon(sPath As String, Optional iSize As Integer = 48) As Image

  Dim hImage As Image
  Dim hBackground As Image
  Dim W, H As Integer

  hImage = Image.Load(sPath)
  If hImage.Width > hImage.Height Then
    W = iSize
    H = iSize * hImage.H / hImage.W
    'hImage = hImage.Stretch(iSize, iSize * hImage.H / hImage.W)
  Else
    W = iSize * hImage.W / hImage.H
    H = iSize
    'hImage = hImage.Stretch(iSize * hImage.W / hImage.H, iSize)
  Endif

  If W < iSize Or H < iSize Then
    hBackground = New Image(iSize, iSize)
    hBackground.Fill(Color.Transparent)
    hBackground.PaintImage(hImage, (iSize - W) / 2, (iSize - H) / 2, W, H)
    hImage = hBackground
  Else
    hImage = hImage.Stretch(W, H)
  Endif

  Return hImage

Catch

  Return Image.Load("img/logo/logo-32.png").Stretch(iSize, iSize)

End

Public Function GetIcon(sPath As String, Optional iSize As Integer) As Picture

  Dim hFile As File
  Dim sLig As String
  Dim hImage As Image
  Dim hPict As Picture
  Dim sIcon As String

  hFile = Open sPath &/ ".project"

  While Not Eof(hFile)
    Line Input #hFile, sLig
    If Left$(sLig, 5) = "Icon=" Then
      sIcon = Mid$(sLig, 6)
      Break
    Endif
  Wend

  Close #hFile

  If sIcon Then
    sPath = sPath &/ sIcon
  Else
    sPath = "img/logo/logo-32.png"
  Endif

  If iSize Then
    Return StretchIcon(sPath, iSize).Picture
  Else
    Return Picture.Load(sPath)
  Endif

Catch

  sPath = "img/logo/logo-32.png"

  If iSize Then
    Return StretchIcon(sPath, iSize).Picture
  Else
    Return Picture.Load(sPath)
  Endif

End

Public Sub CleanUp()

  Dim iInd As Integer
  Dim aClear As String[] = [".gambas", ".lock", ".xvpics", "*~", "*.pot", "*.gambas", "core", "core.*", "vgcore.*", ".kdbg*"]
  Dim sClear As String

  For iInd = 0 To aClear.Max
    If iInd Then sClear &= " -o"
    sClear &= " -name \"" & aClear[iInd] & "\""
  Next

  Shell "cd " & Shell$(Project.Dir) & "; rm -rf `find . " & sClear & "`" Wait
  Project.Refresh

End

' Public Sub SetFormIcon(hForm As FForm)
' '
' '   DIM hPict AS Picture
' '   DIM eRap AS Float
' '
' '   'hForm.Raise
' '   hPict = hForm.Grab()
' '   hForm.Refresh
' '   eRap = hPict.Width / hPict.Height
' '   IF eRap > 4 THEN
' '     eRap = 4
' '     hPict = hPict.Copy(0, 0, hPict.Height * eRap, hPict.Height)
' '   ELSE IF eRap < 0.5 THEN
' '     eRap = 0.5
' '     hPict = hPict.Copy(0, 0, hPict.Width, hPict.Width / eRap)
' '   ENDIF
' '   IF eRap > 1 THEN
' '     hPict = hPict.Image.Stretch(32 * eRap, 32).Picture
' '   ELSE
' '     hPict = hPict.Image.Stretch(32, 32 / eRap).Picture
' '   ENDIF
' '
' '   Draw.Begin(hPict)
' '   Draw.Foreground = &H808080&
' '   Draw.Rect(0, 0, hPict.Width, hPict.Height)
' '   Draw.End
' '
' '   ProjectTree[Project.Dir &/ hForm.Name & ".form"].Picture = hPict
' '
' ' CATCH
' '
' '   PRINT Error.Text
' '
' End

Public Function CheckProgram(sProg As String) As Boolean

  Dim iPos As Integer

  iPos = InStr(sProg, " ")
  If iPos Then sProg = Left(sProg, iPos - 1)

  Shell "which " & sProg & " >/dev/null 2>&1" Wait
  If Process.LastValue Then Return True

End

'' Open a URL inside an external browser.
'' <li><u>sLink</u> is the URL to open.

Public Sub OpenWebPage(sLink As String)

  Dim sExec As String
  Dim aTest As String[]
  Dim bCheck As Boolean
  Dim hFirefox As Process

  If Not Browser Then

    Select Case Settings["/Browser"]

      Case "konqueror"
        aTest = ["konqueror"]

      Case "epiphany"
        aTest = ["epiphany"]

      Case "firefox"
        aTest = ["firefox", "mozilla-firefox"]

      Case "seamonkey"
        aTest = ["seamonkey"]

      Case Else

        aTest = [Application.Env["BROWSER"]]

        If Application.Env["KDE_FULL_SESSION"] Then
          aTest.Add("konqueror")
        Else If Application.Env["GNOME_DESKTOP_SESSION_ID"] Then
          aTest.Add("epiphany")
          aTest.Add("firefox")
        Endif

    End Select

    aTest.Add("konqueror")
    aTest.Add("mozilla-firefox")
    aTest.Add("firefox")
    aTest.Add("mozilla")
    aTest.Add("seamonkey")
    aTest.Add("opera")

    For Each sExec In aTest
      bCheck = Not CheckProgram(sExec)
      If bCheck Then Break
    Next

    If Not bCheck Then Return

    Browser = sExec

  Endif

  If Left(sLink) = "/" Then
    sLink = "file://" & Replace(sLink, "?", "%3F")
  Endif

  If Browser = "firefox" Then
    hFirefox = Shell "firefox -remote \"openURL(" & sLink & ",new-window)\"" Wait
    If hFirefox.Value = 2 Then
      Shell Browser & " " & Chr$(34) & sLink & Chr$(34)
    End If
  Else
    Shell Browser & " " & Chr$(34) & sLink & Chr$(34)
  End If

Catch

  Message.Error(Error.Text)

End

Public Sub OpenImage(sLink As String, sEditor As String) As Boolean

  Dim sExec As String
  Dim aTest As String[]
  Dim bCheck As Boolean
  Dim hProcess As Process

  Select Case LCase(sEditor)

    Case "kolourpaint"
      aTest = ["kolourpaint"]

    Case "krita"
      aTest = ["krita"]

    Case "gimp"
      aTest = ["gimp-remote", "gimp"]

    Case "kiconedit"
      aTest = ["kiconedit"]

    Case Else
      Return True

      ' IF Application.Env["KDE_FULL_SESSION"] THEN
      '   aTest = ["kolourpaint", "gimp"]
      ' ELSE IF Application.Env["GNOME_SESSION_ID"] THEN
      '   aTest = ["gimp-remote"]
      ' ENDIF

  End Select

  For Each sExec In aTest
    bCheck = Not CheckProgram(sExec)
    If bCheck Then Break
  Next

  If Not bCheck Then Return

  hProcess = Shell sExec & " " & Chr$(34) & sLink & Chr$(34) As "Process"
  hProcess.Tag = sLink

Catch

  Message.Error(Error.Text)

End

' PUBLIC SUB ClearFound()
'
'   DIM aKey AS NEW String[]
'   DIM sKey AS String
'
'   IF $iFound = 0 THEN RETURN
'
'   WITH ProjectTree
'     .MoveFirst
'
'     DO
'
'       IF NOT .MoveChild() THEN CONTINUE
'       .MoveBack
'
'       IF Left(.Item.Key, 2) = KEY_FIND THEN aKey.Add(.Item.Key)
'
' NEXT_PARENT:
'
'       IF NOT .MoveNext() THEN CONTINUE
'       .MoveBack
'
'       IF .MoveParent() THEN BREAK
'       GOTO NEXT_PARENT
'
'     LOOP
'
'     FOR EACH sKey IN aKey
'       ProjectTree.Remove(sKey)
'     NEXT
'
'   END WITH
'
'   $iFound = 0
'   ProjectTree.Columns.Count = 1
'
' END
'
' PUBLIC SUB AddFound(sName AS String, iLine AS Integer, iCol AS Integer, iLen AS Integer, sText AS String)
'
'   DIM sKey AS String
'   'DIM sAfter AS String
'   DIM sParent AS String
'
'   sParent = FindKey(sName)
'   IF NOT sParent THEN RETURN
'
'   ProjectTree.Columns.Count = 2
'
'   sKey = KEY_FIND & sParent & "@" & Format(iLine, "000000") & "." & Format(iCol, "00000") & "." & iLen
'
' '   ProjectTree.MoveTo(sParent)
' '   IF NOT ProjectTree.MoveChild() THEN
' '     WHILE ProjectTree.Available
' '       ProjectTree.MoveNext
' '     WEND
' '     ProjectTree.MoveBack
' '     sAfter = ProjectTree.Item.Key
' '   ENDIF
' '
' '   DEBUG sKey;; ":";; sAfter
'
'   ProjectTree.Add(sKey, (iLine + 1) & ":" & iCol, Picture["icon:/small/find"], sParent)
'   ProjectTree[sKey][1] = sText
'   ProjectTree[sParent].Expanded = TRUE
'
'   INC $iFound
'
' END
'
' PUBLIC SUB SelectFound(sName AS String, iLine AS Integer, iCol AS Integer, iLen AS Integer)
'
'   DIM sKey AS String
'
'   sKey = FindKey(sName)
'   IF NOT sKey THEN RETURN
'
'   sKey = KEY_FIND & sKey & "@" & Format(iLine, "000000") & "." & Format(iCol, "00000") & "." & iLen
'   TRY ProjectTree[sKey].Selected = TRUE
'
' END



Public Sub GetPicture(sPict As String) As Picture

  If Not sPict Then Return

  If sPict Begins "icon:/" Then
    Return Picture[sPict]
  Else
    Return Picture.Load(Project.Dir &/ sPict)
  Endif

End

Public Sub HasTranslation(sLang As String) As Boolean

  Return Exist(Project.Dir &/ ".lang" &/ sLang & ".po")

End

Public Sub MakeDirectoryIcon(Optional sDir As String)

  Dim sIcon As String
  Dim hDirIcon As Image
  Dim hIcon As Image

  If Not sDir Then
    sDir = Project.Dir
    If Project.Icon Then sIcon = sDir &/ Project.Icon
  Endif

  hDirIcon = Image.Load("img/logo/gambas-folder-64.png")

  If sIcon Then
    Try hIcon = StretchIcon(sIcon, 16)
    If hIcon Then hDirIcon.PaintImage(hIcon, 40, 34)
  Endif

  hDirIcon.Save(sDir &/ ".icon.png")
  File.Save(sDir &/ ".directory", "[Desktop Entry]\nIcon=./.icon.png\n")

Catch

  Error "gambas3: warning: unable to create project directory icon"

End

Public Sub RefreshBreakpointPicture()

  Dim iSize As Integer
  Dim hPict As Picture

  iSize = Font[Settings["/Editor/Font"]].Height
  hPict = Picture["icon:/small/halt"]
  If iSize < Stock.GetSize("small") Then hPict = hPict.Image.Stretch(iSize, iSize).Picture
  Try Editor.BreakpointPicture = hPict

End

Public Sub IsStockAllowed() As Boolean

  Return Components.Exist("gb.form")

End

Public Sub DrawTitle(hForm As Object, Optional bNoReadOnly As Boolean)

  Dim sPath As String
  Dim sTitle As String

  sPath = hForm.Path
  'If IsSourcePath(sPath) Or If IsConnectionPath(sPath) Then
  '  sTitle = File.BaseName(sPath)
  'Else
  sTitle = File.Name(sPath)
  'Endif

  If hForm.IsModified() Then sTitle &= " [*]" & Left(("modified"), 0)
  If Not bNoReadOnly Then
    If hForm.ReadOnly And If Not Project.ReadOnly And If Not Project.Running Then sTitle &= " [" & ("read-only") & "]"
  Endif
  If hForm.Title <> sTitle Then hForm.Title = sTitle

End

Public Sub IsExported(sPath As String) As Boolean

  Dim hFile As File
  Dim sLine As String
  Dim sExt As String

  sExt = File.Ext(sPath)
  If sExt <> "module" And If sExt <> "class" Then Return

  Try hFile = Open sPath
  If Error Then Return

  While Not Eof(hFile)
    Line Input #hFile, sLine
    sLine = Highlight.Purge(Trim(sLine))
    If Not sLine Then Continue
    If Left(sLine) = "'" Then Continue
    If sLine Like "INHERITS *" Then Continue
    If sLine Like "CREATE" Then Continue
    If sLine Like "CREATE *" Then Continue
    If sLine Like "EXPORT" Then Return True
    If sLine Like "EXPORT OPTIONAL" Then Return True
    Break
  Wend

End

Public Sub IsLocked(sPath As String) As Boolean

  If LockedPaths.Exist(sPath) Then Return True
  If sPath = "" Or sPath = "/" Then Return False
  'If IsAdded(sPath) Then Return True
  Return IsLocked(File.Dir(sPath))

End

Public Sub IsAdded(sPath As String, Optional bNoRec As Boolean) As Boolean

  If AddedPaths.Exist(sPath) Then Return True
  'If IsSourcePath(sPath) And If File.Ext(sPath) = "form" And If AddedPaths.Exist(File.SetExt(sPath, "class")) Then Return True
  If bNoRec Then Return False
  If sPath = "" Or sPath = "/" Then Return False
  Return IsAdded(File.Dir(sPath))

End

Public Sub GetCount(sType As String) As Integer

  Dim sPath As String
  Dim iCount As Integer

  For Each sPath In $cSourceDir
    If File.Ext(sPath) = sType Then Inc iCount
  Next
  Return iCount

End

Public Sub GetLinesOfCode() As Integer

  Dim sPath As String
  Dim iCount As Integer
  Dim aLine As String[]
  Dim iPos As Integer
  Dim iComment As Integer
  Dim sCar As String

  For Each sPath In $cSourceDir
    aLine = Split(File.Load(sPath), "\n", "", True)
    iComment = 0
    For iPos = 0 To aLine.Max
      sCar = Left(LTrim(aLine[iPos]))
      If sCar = "'" Or If sCar = "#" Then Inc iComment
    Next
    iCount += aLine.Count - iComment
  Next

  Return iCount

End

Public Sub GetFileSize(iSize As Long) As String

  If iSize < 1000 Then
    Return Subst("&1 B", CStr(iSize))
  Else If iSize < 1000000 Then
    Return Subst("&1 KiB", Format(iSize / 1000, "#.#"))
  Else If iSize < 1000000000 Then
    Return Subst("&1 MiB", Format(iSize / 1000000, "#.#"))
  Else
    Return Subst("&1 GiB", Format(iSize / 1000000000, "#.#"))
  Endif

End

Public Sub SetCurrentPopup(hMenu As Menu)

  If hMenu = $hCurrentPopup Then
    If Not hMenu Or If hMenu.Enabled Then Return
  Endif

  'Debug hMenu.Name

  Try $hCurrentPopup.Enabled = False
  $hCurrentPopup = hMenu
  Try $hCurrentPopup.Enabled = True
  'Debug $hCurrentPopup.Name;; $hCurrentPopup.Window.Title

End

Public Sub IsReadOnly(sPath As String) As Boolean

  If Not Exist(sPath) Then Return True

  Do
    If sPath = Project.Dir Or If sPath = "/" Then Break
    If Stat(sPath).Type = gb.Link Then
      Return True
    Endif
    sPath = File.Dir(sPath)
  Loop

End

Public Sub StoreCombo(hCombo As ComboBox)

  Dim sText As String = hCombo.Text
  Dim iInd As Integer

  If Not sText Then Return

  iInd = hCombo.Find(sText)
  If iInd >= 0 Then hCombo.Remove(iInd)
  hCombo.Add(sText, 0)
  hCombo.Text = sText

End

Private Sub ConvertProject() As Boolean

  Dim sPath As String
  Dim iStep As Integer

  FConvert.Start(("Project cleanup..."))

  Inc $iNoRefresh
  Project.CleanUp
  Dec $iNoRefresh

  FConvert.SetMessage(("Project files conversion..."))

  For Each sPath In $cSourceDir

    If File.Ext(sPath) <> "form" Then Continue
    If Stat(sPath).Type = gb.Link Then Continue

    MConvert.ConvertFile(sPath)
    Inc iStep
    FConvert.SetProgress(iStep / $cSourceDir.Count)

  Next

  For Each sPath In $cSourceDir

    If File.Ext(sPath) = "form" Then Continue
    If Stat(sPath).Type = gb.Link Then Continue

    MConvert.ConvertFile(sPath)
    Inc iStep
    FConvert.SetProgress(iStep / $cSourceDir.Count)

  Next

  FConvert.Stop

Catch

  FConvert.Stop
  Application.Busy = 0
  Message.Error("<b>" & Subst(("Unable to convert &1"), File.Name(sPath)) & "</b><p>" & Error.Text & "<br>" & Error.Where)
  Return True

End
