' Gambas module file

PRIVATE $sMd5 AS String
PRIVATE $sPrjPath AS String
PRIVATE $hOutFile AS File
PRIVATE $sPath AS String
'PRIVATE $aComponents AS NEW String[]
PRIVATE $iClassCount AS Integer
PRIVATE $hOutClass AS File
PRIVATE $sMainScriptPath AS String
PRIVATE $aIncFiles AS NEW String[]
PRIVATE $iLevel AS Integer
PRIVATE $cComponents AS NEW collection
PRIVATE $aSortKey AS NEW Integer[]
PRIVATE $aAppArgs AS NEW String[]
PRIVATE $bNoCache AS Boolean
PRIVATE $bVerbose AS Boolean

PUBLIC SUB Main()

  'DIM sTmpOut AS String = Temp()
  DIM s AS Integer
  DIM sCacheDir AS String = File.Dir(File.Dir(Temp$())) &/ "script-cache"
  DIM sRes AS String
  DIM bCompile AS Boolean
  
  IF NOT Exist(sCacheDir) THEN MKDIR sCacheDir
  
  $sPath = ParseArgs()
  
  IF IsNull($sPath) THEN 
    ERROR "gbs2: No script file specified"
    ERROR "Type 'gbs2 --help' for more information."
    Application.Return = 1
    RETURN 
  ENDIF
  
  IF NOT Exist($sPath) THEN 
    $sPath = Application.Dir &/ $sPath
    IF NOT Exist($sPath) THEN 
      ERROR "gbs2: Script file does not exist: " & Application.Args[1]
      Application.Return = 1
      RETURN 
    ENDIF
  ENDIF 
  
  $sMainScriptPath = File.Dir($sPath)

  'Extract the sum md5
  EXEC ["md5sum", $sPath] TO $sMd5
  $sMd5 = Scan($sMd5, "* *")[0]
    
  IF $bNoCache THEN 
  
    bCompile = TRUE
  
  ELSE  
    
    'Verify if the project was compiled
    IF NOT Exist(sCacheDir &/ $sMd5) THEN bCompile = TRUE

    'Verify the cache file
    bCompile = NOT IsValid(sCacheDir &/ $sMd5 & ".info") 
    
  ENDIF
  
  IF bCompile THEN 
    'If not we Make and Compile it
    MakeVirtualProject
    
    'compile
    'EXEC [System.Path &/ "bin/gbc" & System.Version, "-a", $sPrjPath] TO sRes 
    SHELL (System.Path &/ "bin/gbc" & System.Version & " -ag " & $sPrjPath & " 2>&1") TO sRes
    
    IF sRes <> "OK\n" THEN 
      ERROR sRes
      Application.Return = 1
      RETURN 
    ENDIF
    
    'Make package
    EXEC [System.Path &/ "bin/gba" & system.Version, "-o", sCacheDir &/ $sMd5, $sPrjPath] TO sRes 
    'Save the FileInfo Cache
    File.Save(sCacheDir &/ $sMd5 & ".info", $aIncFiles.Join("\n"))
    
  ENDIF
  
  
  'Execute it
  $aAppArgs.Add(sCacheDir &/ $sMd5, 0)
  EXEC $aAppArgs
  
END

PRIVATE FUNCTION ParseArgs() AS String
  
  DIM s AS String
  DIM i AS Integer
  DIM sApp AS String
  FOR i = 1 TO Application.Args.Count - 1
    s = Application.Args[i]

    IF Left(s) = "-" THEN 
      IF s = "--version" OR IF s = "-V" THEN 
        PRINT Application.Version
        QUIT
      ELSE IF s = "--help" OR IF s = "-h" THEN
        PRINT "GAMBAS Scripter version " & Application.Version 
        PRINT File.Load("helptext")
        QUIT
      ELSE IF s = "--nocache" OR IF s = "-c" THEN
        $bNoCache = TRUE
      ELSE IF s = "--verbose" OR IF s = "-v" THEN
        $bVerbose = TRUE
      ENDIF
    ELSE 
      IF NOT IsNull(sApp) THEN 
        $aAppArgs.Add(s)
        CONTINUE 
      ENDIF
      sApp = s
      'RETURN a
    ENDIF
    
  NEXT
  
  RETURN sApp
END



PRIVATE SUB MakeVirtualProject()
  
  DIM hFile AS File
  DIM s AS String
  DIM sPrjFileContent AS String
  DIM i AS Integer
  $sPrjPath = Temp("project") 

  IF $bVerbose THEN PRINT "gbs2: create project"
  
  'Make the Virtual directory
  TRY MKDIR $sPrjPath
  'File the .project content var
  sPrjFileContent = "# Gambas Project File 2.0\n"
  sPrjFileContent &= "Title=Gambas Script\n"
  sPrjFileContent &= "Startup=MMain\n"
  
  'Open a Main module
  $hOutFile = OPEN $sPrjPath &/ "MMain.module" FOR WRITE CREATE 
  
  'Fill it and create class as need
  GenerateFiles($sPath)
  
  'Complete the components list
  FOR EACH s IN $cComponents
    GetNeededComp(s)
  NEXT
  
  FOR EACH s IN $cComponents
    GetRequiredComp(s)
  NEXT
  
  CComponent.Exit
  
  'Sort components
  $aSortKey.Sort
  
  'Now make the component list with the info collected
  FOR EACH i IN $aSortKey
     sPrjFileContent &= "Library=" & $cComponents[i] & "\n"
     'PRINT $cComponents[i]
  NEXT
  
  'Save the .Project File
  File.Save($sPrjPath &/ ".project", sPrjFileContent)
  
  CLOSE $hOutFile
  'PRINT file.Load($sPrjPath &/ "MMain.module")
END

PRIVATE SUB CompileError(sPath AS String, iLine AS Integer, sMessage AS String)
  
  ERROR sPath; "."; iLine; ": "; sMessage
  CComponent.Exit
  QUIT
  
END


PRIVATE SUB GenerateFiles(Path AS String)
  
  DIM hFile AS File
  DIM sLine AS String
  DIM sPath AS String
  DIM sClass AS String
  DIM bInClass AS Boolean = FALSE
  DIM s AS String
  DIM sCodeBuf AS String
  DIM bAutoMain AS Boolean = TRUE
  DIM aSym AS String[]
  DIM iInd AS Integer
  DIM iLine AS Integer
  
  IF NOT Exist(Path) THEN RETURN 
  'Check if this file is already included: if true not include it
  IF $aIncFiles.Exist(Path) THEN RETURN 
      
  IF $bVerbose THEN PRINT "gbs2: process file: "; Path

  'Increment Recursion level index
  INC $iLevel
  
  'Add file info for file cache
  $aIncFiles.Add(Path)
  $aIncFiles.Add(Stat(Path).LastModified)
  
  hFile = OPEN Path FOR READ 
  
  WHILE NOT Eof(hFile)
    
    INC iLine
    LINE INPUT #hFile, sLine
    IF sLine LIKE "#!*" THEN CONTINUE 
    
    aSym = Highlight.Analyze(sLine)
    
    'Look for file inclusion 
    ' if true call this function recursively
    IF aSym.Count = 2 AND IF aSym[0] = "INCLUDE" AND IF Highlight.Types[1] = Highlight.String THEN 
      sPath = Mid$(aSym[1], 2, -1) 'Trim(Scan(sLine, "INCLUDE *")[0])
      IF NOT Exist(sPath) THEN sPath = $sMainScriptPath &/ sPath
      IF $bVerbose THEN PRINT "gbs2: include script file: " & sPath
      
      GenerateFiles(sPath)
      CONTINUE 
    ENDIF
    
    'Close The Class
    IF aSym.Count = 2 AND IF aSym[0] = "END" AND IF aSym[1] = "CLASS" AND IF bInClass THEN 
      CLOSE #$hOutClass
      'PRINT File.Load($sPrjPath &/ sClass & ".class")
      bInClass = FALSE
      CONTINUE 
    ENDIF
    
    'Open a new Class
    IF aSym.Count = 2 AND IF aSym[0] = "CLASS" AND IF Highlight.Types[1] = Highlight.Symbol THEN 
       'IF NOT IsNull(sCodeBuf) THEN ERROR.Raise("You can't declare a CLASS in a SUB or FUNCTION")
      sClass = aSym[1] 'Trim(Scan(sLine, "CLASS *")[0])
      IF IsNull(sClass) THEN 
        CompileError(Path, iLine, "Class name missing")
        CONTINUE
      ENDIF
      IF $bVerbose THEN PRINT "gbs2: create class: "; sClass
      $hOutClass = OPEN $sPrjPath &/ sClass & ".class" FOR WRITE CREATE
      bInClass = TRUE
      CONTINUE       
    ENDIF
    
    'Add a new component
    IF aSym.Count >= 2 AND IF aSym[0] = "USE" THEN 
      'aSym.Remove(0) 's = aSym[1] 'Trim(Scan(sLine, "USE *")[0])
      FOR iInd = 1 TO aSym.Max STEP 2
        IF Highlight.Types[iInd] <> Highlight.String THEN CompileError(Path, iLine, "Syntax error")
        s = Mid$(aSym[iInd], 2, -1)
        IF $bVerbose THEN PRINT "gbs2: use component: "; s
        '$aComponents.Add(Trim(s))
        IF NOT CComponent.All.Exist(s) THEN CompileError(Path, iLine, Subst("Unknown component: &1", s))
        $cComponents[CComponent.All[s].SortKey] = s
        $aSortKey.Add(CComponent.All[s].SortKey)
        IF iInd < aSym.Max THEN
          s = aSym[iInd + 1]
          IF s <> "," THEN CompileError(Path, iLine, "Comma missing")
        ENDIF
      NEXT
      CONTINUE 
    ENDIF
    
    'Control if the user have not done a Main Sub itself
    IF aSym.Count = 4 AND IF (aSym[0] = "SUB" OR aSym[0] = "PROCEDURE") AND IF aSym[1] = "Main" AND IF aSym[2] = "(" AND IF aSym[3] = ")" THEN 
      IF $bVerbose THEN PRINT "gbs2: Main procedure already defined"
      bAutoMain = FALSE
    ENDIF
    
    'if in class write directly in file ... else use buffer
    IF bInClass THEN 
      PRINT #$hOutClass, sLine
    ELSE 
      sCodeBuf &= sLine & "\n"
      'if END detected then write to module file
      IF sLine LIKE "END*" THEN 
        PRINT #$hOutFile, sCodeBuf
        sCodeBuf = NULL
      ENDIF
    ENDIF
    
      
  WEND
  
  IF bInClass THEN CompileError(Path, iLine, "END CLASS missing")
  
  'If not exist a Main sub and buffer not empty then generate a Main sub
  'With the Buffer content.. if we are not in an include file
  'In this case the free code is forgotten
  IF bAutoMain AND NOT IsNull(sCodeBuf) AND $iLevel = 1 THEN 
    IF $bVerbose THEN PRINT "gbs2: Main procedure not defined, create it"
    PRINT #$hOutFile, "PUBLIC SUB Main()"
    PRINT #$hOutFile, sCodeBuf
    PRINT #$hOutFile, "END"
  ENDIF
  
  CLOSE #hFile
  
  DEC $iLevel
  
END



PUBLIC FUNCTION IsValid(sPath AS String) AS Boolean
  
  DIM aFileInfo AS String[]
  DIM i AS Integer
  DIM bUnChanged AS Boolean = TRUE
  
  IF NOT Exist(sPath) THEN RETURN FALSE
  
  aFileInfo = Split(File.Load(sPath), "\n")
  
  FOR i = 0 TO aFileInfo.Max STEP 2
  
    IF Stat(aFileInfo[i]).LastModified > CDate(aFileInfo[i + 1]) THEN bUnChanged = FALSE
  
  NEXT
  'PRINT IIf(bUnChanged, "Les Dates Colles", "Les dates ne colle pas")
  
  RETURN bUnChanged

 CATCH
   RETURN FALSE
  
END


PUBLIC SUB GetRequiredComp(sComp AS String)
  
  DIM hComp AS CComponent  
  DIM s AS String
  
  FOR EACH s IN CComponent.All[sComp].Require
    IF NOT $cComponents.Exist(s) THEN      
      $cComponents.Add(s, CComponent.All[s].Sortkey)
      $aSortKey.add(CComponent.All[s].SortKey)
      GetRequiredComp(s)   
    ENDIF
  
  NEXT
  
END


PRIVATE SUB GetNeededComp(sComp AS String)
  DIM s, t AS String
  DIM bExist AS Boolean
  
  FOR EACH s IN CComponent.All[sComp].Need
    FOR EACH t IN CComponent.WhoImplement[s]
      IF $cComponents.Exist(t) THEN 
        bExist = TRUE
        BREAK 
      ENDIF
      
    NEXT 
  
    IF NOT bExist THEN  
      t = CComponent.WhoImplement[s][0]
      $cComponents.Add(t, CComponent.All[t].SortKey)
      $aSortKey.add(CComponent.All[t].SortKey)
    ENDIF
    
    GetNeededComp(t)
    
  NEXT
  
END




