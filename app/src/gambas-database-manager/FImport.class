' Gambas class file

STATIC PRIVATE $sPath AS String 
STATIC PRIVATE $hConn AS CConnection

STATIC PRIVATE $sDelim AS String
STATIC PRIVATE $sEscape AS String
STATIC PRIVATE $sCharset AS String
STATIC PRIVATE $iEndOfLine AS Integer

STATIC PRIVATE $iLine AS Integer
STATIC PRIVATE $bImport AS Boolean
STATIC PRIVATE $bCancel AS Boolean

STATIC PUBLIC FUNCTION Run(hConn AS CConnection, sPath AS String) AS Boolean
  
  $sPath = sPath
  $hConn = hConn
  
  RETURN NOT FImport.ShowModal()
  
END

PUBLIC SUB btnOK_Click()

  IF $bImport THEN
    $bCancel = TRUE
  ELSE
    btnOK.Text = ("Cancel")
    WAIT
    DoImport
    btnOK.Text = ("Import")
  ENDIF

END

PUBLIC SUB btnCancel_Click()

  ME.Close

END

PUBLIC SUB Form_Open()

  txtPath.Text = $sPath
  txtPath.Pos = txtPath.Length
  
  cmbTable.List = $hConn.Tables
  cmbTable.Text = File.BaseName($sPath)

END

PUBLIC SUB chkFirstLine_Click()

  cmbKey.Enabled = chkFirstLine.Value
  UpdateKey

END

PRIVATE SUB UpdateDelim()
  
  IF cmbDelim.Text = cmbDelim[0].Text THEN
    $sDelim = Chr$(9)
  ELSE IF cmbDelim.Text = cmbDelim[1].Text THEN
    $sDelim = " "
  ELSE
    $sDelim = cmbDelim.Text    
  ENDIF
  
  $sEscape = cmbEscape.Text
  
  $sCharset = cmbCharset.Text
  
  $iEndOfLine = Choose(cmbEndOfLine.Index + 1, gb.Unix, gb.Windows, gb.Mac)
  
END

PRIVATE FUNCTION Analyze(sLig AS String, OPTIONAL sCharset AS String = Desktop.Charset) AS String[]
  
  TRY sLig = Conv(sLig, $sCharset, sCharset)
  RETURN Split(sLig, $sDelim, $sEscape)
  
END


PRIVATE SUB UpdateKey()

  DIM hFile AS File
  DIM sLig AS String
  DIM aData AS String[]

  IF NOT cmbKey.Enabled THEN RETURN
  
  UpdateDelim
  
  hFile = OPEN $sPath FOR INPUT
  hFile.EndOfLine = $iEndOfLine
  
  WHILE NOT Eof(hFile)
    LINE INPUT #hFile, sLig
    aData = [("(Automatic key)")]
    aData.Insert(Analyze(sLig))
    cmbKey.List = aData
    BREAK
  WEND

FINALLY

  CLOSE hFile

CATCH

  DEBUG Error.Where; ":";; Error.Text

END

PUBLIC SUB cmbDelim_Click()

  UpdateKey

END

PUBLIC SUB cmbEnclose_Click()

  UpdateKey

END

PUBLIC SUB cmbCharset_Click()

  UpdateKey

END

PUBLIC SUB cmbCharset_Activate()

  UpdateKey

END

PUBLIC SUB cmbEndOfLine_Click()

  UpdateKey

END

PRIVATE SUB DoMessage(sMsg AS String)
  
  lstMessage.Add($iLine & ": " & sMsg)
  WAIT
  
END


PRIVATE FUNCTION TransformField(sName AS String) AS String

  sName = Trim(sName)  
  sName = Replace(sName, " ", "_")
  sName = Replace(sName, "-", "_")
  RETURN sName
  
END


PRIVATE SUB DoImport()
  
  DIM hFile AS File
  DIM sLig AS String
  DIM aField AS String[]
  DIM aLine AS String[]
  DIM rData AS Result
  DIM hConn AS Connection
  DIM sTable AS String
  DIM bCreateTable AS Boolean
  DIM hTable AS Table
  DIM I AS Integer
  DIM sName AS String
  DIM sKey AS String
  DIM nImport AS Integer
  DIM cField AS NEW Collection

  $bImport = TRUE 
  tabImport.Index = 1 
  lstMessage.Clear
  hConn = $hConn.Handle
  sTable = Trim(cmbTable.Text)
  bCreateTable = NOT hConn.Tables.Exist(sTable)
  UpdateDelim
  pgbImport.Value = 0
  pgbImport.Show
  
  hConn.Begin
  
  hFile = OPEN $sPath FOR INPUT
  $iLine = 0
  $bCancel = FALSE
  
  IF chkFirstLine.Value THEN
    INC $iLine
    LINE INPUT #hFile, sLig
    aField = Analyze(sLig, $hConn.Charset)
    FOR I = 0 TO aField.Max
      aField[I] = TransformField(aField[I])
    NEXT
  ENDIF
  
  WHILE NOT Eof(hFile)
    INC $iLine
    LINE INPUT #hFile, sLig
    aLine = Analyze(sLig, $hConn.Charset)
    
    IF bCreateTable THEN
      hTable = hConn.Tables.Add(sTable)
      WITH hTable
        IF aField THEN
          IF cmbKey.Index = 0 THEN          
            .Fields.Add("id", db.Serial)
            sKey = "id"
          ENDIF
          FOR I = 0 TO aField.Max
            sName = aField[I]
            TRY .Fields.Add(sName, db.String)
            IF ERROR THEN 
              sName = ("Field") & CStr(I + 1)
              .Fields.Add(sName, db.String)
            ENDIF
            aField[I] = sName
            IF cmbKey.Index = (I + 1) THEN sKey = sName
          NEXT
        ELSE
          .Fields.Add("id", db.Serial)
          FOR I = 1 TO aLine.Count
            .Fields.Add(("Field") & CStr(I), db.String)
          NEXT
          sKey = "id"
        ENDIF
        .PrimaryKey = [sKey]
        .Update
      END WITH
      bCreateTable = FALSE
    ENDIF
  
    rData = hConn.Create(sTable)
    IF aField THEN
      IF aLine.Max < aField.Max THEN
        DoMessage(("Not enough values"))
      ELSE IF aLine.Max > aField.Max THEN
        DoMessage(("Too many values"))
      ENDIF
      FOR I = 0 TO Min(aField.Max, aLine.Max)
        sName = aField[I]
        TRY rData[sName] = aLine[I]
        IF ERROR THEN DoMessage(Conv(sName, $sCharset, Desktop.Charset) & ": " & Error.Text)
      NEXT
    ELSE
      FOR I = 0 TO aLine.Max
        TRY rData[I + 1] = aLine[I]
        IF ERROR THEN DoMessage(("Field") & CStr(I) & ": " & Error.Text)
      NEXT
    ENDIF
    rData.Update
    
    INC nImport
    pgbImport.Value = Seek(hFile) / Lof(hFile)
    IF (nImport AND 15) = 0 THEN WAIT 0.01
    IF $bCancel THEN Error.Raise(("Cancelled by user"))
    
  WEND
  
  pgbImport.Value = 1
  WAIT
  hConn.Commit

  IF nImport = 0 THEN
    DoMessage(("No record imported."))
  ELSE IF nImport = 1 THEN
    DoMessage(("One record imported."))
  ELSE
    DoMessage(Subst(("&1 records imported."), nImport))
  ENDIF
  
FINALLY
  
  CLOSE #hFile
  $bImport = FALSE
  
CATCH

  hConn.Rollback
  DoMessage("** " & Error.Text)
  
END
