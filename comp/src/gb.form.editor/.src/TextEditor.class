' Gambas class file

Export

Inherits UserControl

Public Const _Properties As String = "*,Border=True,ScrollBar{Scroll.*}=Both,Highlight{None;Custom;Gambas;HTML;CSS;WebPage;Diff;JavaScript;SQL},ReadOnly,TabSize{Range:2;64}=2,Wrap,ShowPosition,ShowLimit,ShowCurrent,ShowLineNumber,ShowModified,ShowBraces,ShowIcon,ShowExpand,ShowCursor=True,ShowSpaces"
Public Const _DrawWith As String = "-"
Public Const _DefaultEvent As String = "Change"
Public Const _Similar As String = "TextArea"

Event Cursor
Event Scroll
Event Change
Event Margin
Event KeyPress
Event Highlight(Text As String)

Property Text As String
Property Read Count As Integer
Property Read Line As Integer
Property Read Column As Integer
Property Read SelectionLine As Integer
Property Read SelectionColumn As Integer
Property Read Selected As Boolean
Property Read SelectedText As String
Property ReadOnly As Boolean
Property Highlight As String
Property LineNumberOffset As Integer
Property TabSize As Integer
Property Read Length As Integer
Property Border As Boolean
Property ScrollBar As Integer
Property Overwrite As Boolean
Property Read LineHeight As Integer
Property Read Current As _TextEditor_Line
Property Font As Font
Property StopLine As Integer
Property EndOfLine As Integer
Property Breakpoints As Integer[]
Property Bookmarks As Integer[]
Property Read Styles As _TextEditor_Styles
Property View As TextEditor
Property Read Keywords As String[]
Property Wrap As Boolean 

Property ScrollX As Integer
Property ScrollY As Integer
Property Read ScrollWidth, ScrollW As Integer
Property Read ScrollHeight, ScrollH As Integer

Property ShowLimit As Boolean
Property ShowCurrent As Boolean
Property ShowLineNumber As Boolean
Property ShowModified As Boolean
Property ShowPosition As Boolean
Property ShowIcon As Boolean
Property ShowBraces As Boolean
Property ShowCursor As Boolean
Property ShowExpand As Boolean
Property ShowSpaces As Boolean

Private Const MATCH_STRING As String = "()[]{}"

Static Private $cShortcut As Collection
Static Private $bRemoteDisplayChecked As Boolean
Static Private $bRemoteDisplay As Boolean

Public _Views As TextEditor[]

Private $hPanel As Panel
Private $hView As ScrollArea
Private $hLabelFrame As Panel
Private $hLabel As Label

Private $hDoc As CDocument
Private $hRows As _TextEditor_Rows

Private $hStyles As _TextEditor_Styles
Private $bStyleChanged As Boolean

Private $iLargestLine As Integer
Private $iWidth As Integer
Private $LH As Integer
Private $MW As Integer
Private $iWidthLineNumber As Integer
Private $iPosIcon As Integer

Private $iTabSize As Integer = 2
Private $iTabWidth As Integer
Private $fTabSymbolSize As Float
Private $iSpaceWidth As Integer

Private $X As Integer
Private $X0 As Integer
Private $Y As Integer
Private $XY As Point
Private $bShowCursor As Boolean
Private $bHideCursor As Boolean
Private $LX As Integer
Private $LY As Integer

Private $hTimerCursor As Timer
Private $hTimerChange As Timer
Private $hTimerEnsureVisible As Timer

Private $SX As Integer
Private $SY As Integer
Private $SXY As Point
Private $bMouseDown As Boolean

Private $hTimerScroll As Timer

Private $XM As Integer
Private $YM As Integer = -1
Private $XMO As Integer
Private $YMO As Integer

Private $bReadOnly As Boolean
Private $bOverwrite As Boolean
Private $bTerminal As Boolean

Private $iBackground As Integer
Private $iForeground As Integer
Private $iSelectedBackground As Integer
Private $iLimitColor As Integer
Private $iMultiLineColor As Integer

Private $iLineNumberOffset As Integer
Private $hTabImage As Image
Private $hFont As Font
'Private $hFontBold As Font
Private $iAscent As Integer

Private $fCharWidth As Float
Private $cCachePos As New Collection
Private $cCacheView As New Collection

Private $iStopLine As Integer = -1

Private $bShowLimit As Boolean
Private $bShowCurrent As Boolean
Private $bShowLineNumber As Boolean
Private $bShowModified As Boolean
Private $bShowPosition As Boolean
Private $bShowIcon As Boolean
Private $bShowBraces As Boolean
Private $bShowExpand As Boolean
Private $bShowSpaces As Boolean

Private $bFirstFocus As Boolean

Private $aFold As Integer[]

Private $iSaveCursor As Integer
Private $aSaveCursor As Integer[]
Private $hFontNumber As Font

Private $cLineLayout As Collection
Private $hTimerHeight As Timer
Private $bNoResizeContents As Boolean

Static Private $cGlobalCacheText As New Collection
Private $cCacheText As Collection
Private $sCacheTextKey As String

Private $cCacheLine As New Collection
Private $iLastScrollX As Integer
Private $hTimerCacheLine As Timer
Private $iCacheLineH As Integer

Private $bUpdateHeightAllowed As Boolean

Private $bPrint As Boolean
Private $sPrintBuffer As String

Public Sub _new()
  
  Dim sDisplay As String
  
  If Not $cShortcut Then
    $cShortcut = [
      "CTRL+A": "SelectAll",
      "CTRL+C": "Copy",
      "CTRL+Ins": "Copy",
      "CTRL+V": "Paste",
      "SHIFT+Ins": "Paste",
      "CTRL+X": "Cut",
      "SHIFT+Del": "Cut",
      "CTRL+Y": "Redo",
      "CTRL+Z": "Undo"]
  Endif
  
  If Not $bRemoteDisplayChecked Then
    sDisplay = Env["DISPLAY"]
    If sDisplay And If Left(sDisplay) <> ":" Then $bRemoteDisplay = True
    $bRemoteDisplayChecked = True
  Endif
  
  $hPanel = New Panel(Me) As "ViewPanel"
  $hPanel.Arrangement = Arrange.Fill
  $hPanel.Border = Border.Plain

  $hView = New ScrollArea($hPanel) As "View"
  $hView.Border = False
  $hView.Focus = True
  $hView.Tracking = True
  $hView.Mouse = Mouse.Text
  
  Me.Proxy = $hView
  
  $hTimerCursor = New Timer As "TimerCursor"
  $hTimerCursor.Delay = 500
  
  $hTimerCacheLine = New Timer As "TimerCacheLine"
  $hTimerCacheLine.Delay = 5000
  
  $hRows = New _TextEditor_Rows As "Rows"
  $hStyles = New _TextEditor_Styles As "Styles"
  
  '$hPanel.Background = $hStyles[Highlight.Background].Color

  _SetDocument(Null)
  
End

Private Function Text_Read() As String

  Return $hDoc.Text
  
End

Private Sub CalcSizes()

  Dim I As Integer
  Dim sText As String
  
  $hFont = $hView.Font
  
  '$hFontBold = $hView.Font.Copy()
  '$hFontBold.Bold = True
  
  $LH = $hFont.Height + 1
  $hRows.Height = $LH

  $hFontNumber = Me.Parent.Font.Copy()
  $hFontNumber.Size *= $LH / $hFontNumber.Height
  
  $iAscent = $hFont.Ascent
  $iLargestLine = -1
  $iSpaceWidth = $hFont.TextWidth(" ")
  $iTabWidth = $hFont.TextWidth("m") * $iTabSize
  $fTabSymbolSize = Max(1, $hRows.H / 5)
  $hTabImage = Null
  
  $fCharWidth = $iSpaceWidth
  For I = 33 To 255
    If I > 126 And If I < 160 Then Continue
    If I = 173 Then Continue
    If $hFont.TextWidth(String.Chr$(I)) <> $iSpaceWidth Then 
      $fCharWidth = 0
      Break
    Endif
  Next
  
  If $fCharWidth Then
    sText = String$(4, "AbCdEfGh01#@WwmM")
    $fCharWidth = $hFont.TextWidth(sText) / Len(sText)
  Endif
  
  If Not $bRemoteDisplay Then
    $sCacheTextKey = $hFont.ToString()
    $cCacheText = $cGlobalCacheText[$sCacheTextKey]
    If Not $cCacheText Then
      $cCacheText = New Collection
      $cGlobalCacheText[$sCacheTextKey] = $cCacheText
    Endif
  Endif
  
  _ClearCachePos
  UpdateMargin
  UpdateWidth

  Refresh

End

Private Sub Init()

  $bStyleChanged = True
  $X = 0
  $Y = 0
  $XY = New Point
  $X0 = 0
  $SX = 0
  $SY = 0
  $SXY = New Point
  $YM = -1
  
  $hRows.Clear
  $hRows.Count = $hDoc.Count
  
  CalcSizes
  
  $cCachePos.Clear
  $cCacheView.Clear
  
  If Not $bRemoteDisplay Then
    ClearCacheText
    ClearCacheLine
  Endif
  
  $bShowCursor = True
  GotoCenter(0, 0)
  
  Refresh

End

Private Sub Text_Write(Value As String)

  Goto(0, 0)
  $hDoc.Text = Value
  Init

End

Public Sub Load(Path As String, Optional AddNewLine As Boolean)
  
  Inc Application.Busy
  Goto(0, 0)
  $hDoc.Load(Path, AddNewLine)
  Init
  Dec Application.Busy
  
'Catch
  
'  Dec Application.Busy
'  Error.Propagate
  
End

Public Sub Save(Path As String)
  
  Inc Application.Busy
  $hDoc.HighlightFrom($Y)
  $hDoc.Save(Path)
  $hTimerChange = Null
  Dec Application.Busy
  
Catch
  
  Dec Application.Busy
  Error.Propagate
  
End

Public Sub Clear()
  
  Me.Text = ""
  
End


Private Sub UpdateMargin()

  Dim MW As Integer

  MW = 0
  $iWidthLineNumber = 0
  $iPosIcon = 0
  
  If $bShowLineNumber Then 
    $iWidthLineNumber = (CInt(Log10($hDoc.Count + $iLineNumberOffset)) + 1) * Me.Parent.Font.TextWidth("9") * $LH / Me.Parent.Font.Height + 8
    MW += $iWidthLineNumber
  Endif
  If $bShowIcon Or If $bShowExpand And Len($hDoc.Highlight) > 0 Then 
    $iPosIcon = MW
    MW += $LH
  Endif
  If $bShowModified Then MW += 4
  
  If MW <> $MW Then
    $MW = MW
    If $cLineLayout Then 
      _UpdateAllHeight
      UpdateWidth
    Endif
  Endif

End

Public Sub View_Font()
  
  CalcSizes
  
End


Private Sub HasSelection() As Boolean
  
  If $X <> $SX Or If $Y <> $SY Then Return True
  
End

Private Sub DrawText(sText As String, SX As Integer, X As Integer, Y As Integer)

  Dim iTab, iTab2, iLen As Integer
  Dim YT As Integer
  Dim XX, YY As Float
  
  YT = Y + $iAscent
  
  Do
  
    iTab2 = InStr(sText, "\t", iTab + 1)  
    If iTab2 = 0 Then
      Paint.DrawText(Mid$(sText, iTab + 1), X, YT)
      Return
    Endif
    
    iLen = iTab2 - iTab - 1
    If iLen > 0 Then
      Paint.DrawText(Mid$(sText, iTab + 1, iLen), X, YT)
      X += $hFont.TextWidth(Mid$(sText, iTab + 1, iTab2 - iTab - 1))
    Endif
    
    If Not $hTabImage Then
      
      $hTabImage = New Image($fTabSymbolSize * 2.5, $hFont.Height, Color.Transparent)
      Paint.Begin($hTabImage)
      
      XX = $hTabImage.W / 2
      YY = $hTabImage.H / 2

      Paint.LineWidth = $fTabSymbolSize / 4
      Paint.Background = Color.SetAlpha(Color.TextForeground, 192)
      Paint.MoveTo(XX - $fTabSymbolSize, YY - $fTabSymbolSize)
      Paint.LineTo(XX, YY)
      Paint.LineTo(XX - $fTabSymbolSize, YY + $fTabSymbolSize)
      Paint.MoveTo(XX, YY - $fTabSymbolSize)
      Paint.LineTo(XX + $fTabSymbolSize, YY)
      Paint.LineTo(XX, YY + $fTabSymbolSize)
      Paint.Stroke

      Paint.End
      
    Endif
    
    Paint.DrawImage($hTabImage, X, Y)

    X = SX + (((X - SX) + $iTabWidth) \ $iTabWidth) * $iTabWidth
    iTab = iTab2
    
  Loop

End

Private Sub DrawMatch(X As Integer, Y As Integer, H As Integer, XM As Integer, YM As Integer)

  'Dim sCar As String
  Dim XY As Point
  Dim WW As Integer
  
  XY = LinePos(YM, XM)
  WW = TextWidth(String.Mid$($hDoc.Lines[YM], XM + 1, 1))
  Paint.FillRect(X + XY.X, Y + XY.Y, WW, H, $hStyles[Highlight.Highlight].Color)

End

' Public Sub PrintCache()
' 
'   Dim hImage As Image
'   Dim iSize As Integer
'   Dim cCache As Collection
'   
'   For Each cCache In $cGlobalCacheText
'     For Each hImage In cCache
'       iSize += hImage.W * hImage.H
'       'Debug Mid$($cCacheText.Key, 2)
'     Next
'   Next
'   Debug iSize
'   
' End
' 

Private Sub DrawHighlightedText(Row As Integer, sText As String, aColor As Byte[], X As Integer, Y As Integer, H As Integer, aLayout As Integer[])

  Dim I As Integer
  Dim hStyle As TextEditorStyle
  Dim bAlt As Boolean
  Dim iLen As Integer
  Dim P As Integer
  Dim sStr As String
  Dim X2 As Integer
  Dim iState As Integer
  Dim XMin As Integer
  Dim XMax As Integer
  Dim aStyle As TextEditorStyle[]
  Dim hImage As Image
  
  Dim XX, YY As Integer
  Dim hPos As Point
  Dim iNextBreak As Integer
  Dim iLayout As Integer
  Dim iRest As Integer
  Dim bBreak As Boolean
  Dim sKey As String
  Dim W As Integer
  Dim iLayoutCount As Integer
  Dim iCol As Integer
  
  'Dim hTemp As Image

  XMin = X + $hView.ScrollX
  XMax = XMin + $hView.ClientW
  aStyle = $hStyles._GetStyles()

  XX = X
  YY = Y
  
  If aLayout Then
    iLayoutCount = aLayout.Count
    iNextBreak = aLayout[0]
  Else
    iLayoutCount = 0
    iNextBreak = Len(sText) + 1 ' Always greater than String.Len(), and faster
  Endif

  For I = 0 To aColor.Max Step 2
    
    If Not aLayout Then
      If XX > XMax Then Break
    Endif
    
    iState = aColor[I] And 31
    hStyle = aStyle[iState]
    bAlt = aColor[I] >= 128
    If iRest Then
      iLen = iRest
      iRest = 0
    Else
      iLen = aColor[I + 1]
    Endif
    
    If bBreak Then
      XX = X + LinePos(Row, P).X
      YY += H
      bBreak = False
    Endif
    
    If P + iLen >= iNextBreak Then
      
      bBreak = True
      
      iRest = P + iLen - iNextBreak
      iLen = iNextBreak - P
      
      Inc iLayout
      
      If iLayout < iLayoutCount Then
        iNextBreak += aLayout[iLayout]
      Else
        iNextBreak = Len(sText) + 1
      Endif
      
      If iRest Then I -= 2
      
      If iLen = 0 Then Goto NEXT_PATTERN
      
    Endif
    
    hPos = LinePos(Row, P + iLen)
    X2 = X + hPos.X 'LineWidth(Row, P + iLen)
    
    If Not aLayout Then
      If X2 < XMin Then Goto NEXT_PATTERN
    Endif
     
    If bAlt Then Paint.FillRect(XX, YY, X2 - XX, H, Color.SetAlpha(&HD0D0D0&, 192))
    
    sStr = String.Mid$(sText, P + 1, iLen)
    ' If hStyle.Bold Then
    '   hTemp = New Image(X2 - X, H, Color.Transparent)
    '   Paint.Begin(hTemp)
    '   Paint.Font = $hFont
    '   Paint.Translate(- X, - Y)
    ' Endif
    
    'If hStyle.Bold Then Paint.Font = $hFontBold
    If InStr(sStr, "\t") Then
      iCol = hStyle.Color
      Paint.Background = iCol
      If hStyle.Bold Then
        'Paint.Background = Color.Gradient(iCol, $iBackground)
        DrawText(sStr, X, XX + 1, YY)
      Endif        
      'Paint.Background = iCol
      DrawText(sStr, X, XX, YY)
    Else If Trim(sStr) Then
      If Not $bRemoteDisplay And If iLen <= 16 Then
        sKey = Chr$(iState) & sStr
        hImage = $cCacheText[sKey]
        If Not hImage Then
          
          W = X2 - XX
          If W <= 0 Then W = TextWidth(sStr)
          If hStyle.Bold Then Inc W
          hImage = New Image(W, H, Color.Transparent)
          
          Paint.Begin(hImage)
          Paint.Font = $hFont
          Paint.Translate(- XX, - YY)
          GoSub DRAW_TEXT
          Paint.End
          
          If $cCacheText.Count > 256 Then
            For Each $cCacheText
              $cCacheText.Remove($cCacheText.Key)
              Break
            Next
          Endif
          
        Else
          
          $cCacheText.Remove(sKey)
          
        Endif
        
        $cCacheText[sKey] = hImage
        Paint.DrawImage(hImage, XX, YY)
      Else
        GoSub DRAW_TEXT
      Endif
    Endif
    'If hStyle.Bold Then Paint.Font = $hFont
    
    ' If hStyle.Bold Then
    '   Paint.End
    '   'hTemp.Save("~/temp.png")
    '   Paint.DrawImage(hTemp, X, Y)
    '   Paint.DrawImage(hTemp, X + 1, Y)
    ' Endif
    
    If hStyle.Underline Then Paint.FillRect(XX, YY + H - 1, X2 - XX, 1, Color.SetAlpha(hStyle.Color, 128))
    
    ' If $YM >= 0 Then
    '   If Row = $YMO And If $XMO >= P And If $XMO < (P + iLen) Then DrawMatch(SX, Y, H, $XMO, $YMO)
    '   If Row = $YM And If $XM >= P And If $XM < (P + iLen) Then DrawMatch(SX, Y, H, $XM, $YM)
    ' Endif
    
  NEXT_PATTERN:
  
    P += iLen
    XX = X2
    
  Next
  
  sStr = String.Mid$(sText, P + 1)
  If sStr And If XX <= XMax Then
    
    Paint.Background = $iForeground
    DrawText(sStr, X, XX, YY)
        
  Endif
  
  Return

DRAW_TEXT:  

  iCol = hStyle.Color
  Paint.Background = iCol
  If hStyle.Bold Then
    'Paint.Background = Color.Gradient(iCol, $iBackground)
    Paint.DrawText(sStr, XX + 1, YY + $iAscent) 'DrawText(sStr, SX, X + 1, Y)
  Endif
  'Paint.Background = iCol
  Paint.DrawText(sStr, XX, YY + $iAscent) 'DrawText(sStr, SX, X, Y)
  
  Return

End

Private Sub DrawLine(X As Integer, Y As Integer, Width As Integer, Height As Integer, Row As Integer)
  
  Dim X1 As Integer
  Dim Y1 As Integer
  Dim X2 As Integer
  Dim Y2 As Integer
  Dim iCol As Integer
  Dim hInfo As CLineInfo
  Dim WC As Integer
  Dim sCar As String
  Dim aLayout As Integer[]
  Dim I As Integer
  Dim P As Integer
  Dim sText As String
  Dim YY As Integer
  Dim H As Integer
  Dim XY1X As Integer
  Dim XY2X As Integer
  Dim XY1Y As Integer
  Dim XY2Y As Integer
  Dim XS As Integer
  Dim XX As Integer
  Dim hPos As Point

  'Debug Row
  H = $LH
  
  ' Current line or stop line
  
  If Row = $iStopLine Then
    Paint.FillRect(X, Y, Width, Height, $hStyles[Highlight.Current].Color)
  Else If $bShowCurrent And If Row = $Y Then
    Paint.FillRect(X, Y + $XY.Y, Width, H, $hStyles[Highlight.CurrentLine].Color)
  Endif

  Paint.Rectangle($MW, Y, Width - $MW, Height)
  Paint.Clip
  
  Paint.Translate($MW, 0)
  
  hInfo = $hDoc.Info(Row)
  
  ' Selection
    
  If HasSelection() Then
    
    X1 = $X
    Y1 = $Y
    XY1X = $XY.X
    XY1Y = $XY.Y
    
    X2 = $SX
    Y2 = $SY
    XY2X = $SXY.X
    XY2Y = $SXY.Y
   
    If Y1 > Y2 Or If Y1 = Y2 And X1 > X2 Then
      Swap X1, X2
      Swap Y1, Y2
      Swap XY1X, XY2X
      Swap XY1Y, XY2Y
    Endif
    
    If Row >= Y1 And If Row <= Y2 Then
    
      iCol = Color.SetAlpha($iSelectedBackground, 32)
    
      ' If Y1 = Y2 Then
      '   Paint.FillRect(X + X1X, Y, X2X - X1X, Height, iCol)
      ' Else If Row = Y1 Then
      '   Paint.FillRect(X + X1X, Y, Width - X1X, Height, iCol)
      ' Else If Row = Y2 Then
      '   Paint.FillRect(X, Y, X2X, Height, iCol)
      ' Else
      '   Paint.FillRect(X, Y, Width, Height, iCol)
      ' Endif
      
      If Y1 < Row Then
        XY1X = 0
        XY1Y = 0
      Endif
      
      If Y2 > Row Then
        XY2X = 0
        XY2Y = Height
      Endif
      
      If XY2Y = XY1Y Then
        Paint.FillRect(X + XY1X, Y + XY1Y, XY2X - XY1X, H, iCol)
      Else
        Paint.FillRect(X + XY1X, Y + XY1Y, Width, H, iCol)
        Paint.FillRect(X, Y + XY1Y + H, Width, XY2Y - XY1Y - H, iCol)
        If XY2Y < Height Then Paint.FillRect(X, Y + XY2Y, XY2X, H, iCol)
      Endif
      
    Endif
    
  Endif
  
  ' Matching characters
  
  If $YM >= 0 Then
    If Row = $YMO Then DrawMatch(X, Y, H, $XMO, $YMO)
    If Row = $YM Then DrawMatch(X, Y, H, $XM, $YM)
  Endif
  
  ' ' Tab
  ' 
  ' If Row = $Y Then
  '   XX = LineStartPos(Row)
  '   If XX Then Paint.FillRect(X, Y, XX - X, Height, Color.SetAlpha($iMultiLineColor, 128))
  ' Endif
  
  ' Text
  
  Try aLayout = $cLineLayout[Row]
  sText = $hDoc.Lines[Row]
    
  If hInfo.Colors Then
    
    DrawHighlightedText(Row, sText, hInfo.Colors, X, Y, H, aLayout)
    
  Else
    
    Paint.Background = $iForeground

    If aLayout Then
      
      P = 1
      YY = Y
      XX = X
      XS = X + LineStartPos(Row)
      For I = 0 To aLayout.Max
        DrawText(String.Mid$(sText, P, aLayout[I]), X, XX, YY)
        YY += H
        XX = XS
        P += aLayout[I]
      Next
      DrawText(String.Mid$(sText, P), X, XX, YY)
      
    Else
      
      DrawText(sText, X, X, Y)
      
    Endif
    
  Endif
  
  ' Ending spaces
  
  If $bShowSpaces And If sText Ends " " Then
    
    XX = X + $iSpaceWidth \ 2 - 1
    YY = Y + H \ 2 - 1
    For P = String.Len(sText) DownTo 1
      If String.Mid$(sText, P, 1) <> " " Then Break
      hPos = LinePos(Row, P - 1)
      Paint.FillRect(XX + hPos.X, YY + hPos.Y, 2, 2, $iLimitColor)
    Next
    
  Endif
  
  If Row = $Y And If aLayout Then
    
    Paint.FillRect($iWidth - $MW - 4, Y, 4, Height, $iMultiLineColor)
    
    ' Paint.Background = $iMultiLineColor
    ' 
    ' Paint.AntiAlias = False
    ' Paint.MoveTo($iWidth - $MW - 5, Y + 1)
    ' Paint.RelLineTo(3, 0)
    ' Paint.RelLineTo(0, Height - 3)
    ' Paint.RelLineTo(-3, 0)
    ' Paint.Stroke
    ' Paint.AntiAlias = True
    
  Endif
    
  ' Cursor
  
  If Row = $Y And If $bShowCursor And If Me.HasFocus And If Not $bHideCursor Then
    If $bOverwrite Then
      sCar = String.Mid$($hDoc.Lines[$Y], $X + 1, 1)
      If sCar = "\t" Then
        WC = $iTabWidth
      Else
        WC = Max($iSpaceWidth, $hFont.TextWidth(sCar))
      Endif
    Else
      WC = 2
    Endif
    Paint.FillRect(X + $XY.X, Y + $XY.Y, WC, H, Color.SetAlpha($iForeground, 128))
  Endif
  
End

Private Sub DrawMargin(X As Integer, Y As Integer, Width As Integer, Height As Integer, Row As Integer)
  
  Dim iCol As Integer
  Dim hInfo As CLineInfo
  Dim YL As Integer
  Dim S, SS As Float
  Dim H As Integer
  Dim sStr As String

  hInfo = $hDoc.Info(Row)
  X += $hView.ScrollX
  H = $hRows.H
  
  ' Limit
  
  YL = -1
  
  If $bShowLimit And If Row > 0 Then
    If Not RTrim($hDoc.Lines[Row]) And If Row < $hDoc.Max Then
      If $hDoc.Info(_ViewToReal(_RealToView(Row) + 1)).Limit Then YL = Y + Height \ 2
    Else
      If hInfo.Limit And RTrim($hDoc.Lines[_ViewToReal(_RealToView(Row) - 1)]) Then YL = Y
    Endif
  Endif
  
  ' Margin
  
  'Paint.FillRect(X, Y, $MW, Height, $iBackground)
  
  If $bShowModified Then
    If hInfo.Modified Or If hInfo.Saved Then
      If hInfo.Modified Then
        iCol = Color.Merge($iBackground, Color.Red, 0.2)
      Else If hInfo.Saved Then
        iCol = Color.Merge($iBackground, Color.Green, 0.2)
      Endif
      Paint.FillRect(X + $MW - 5, Y, 4, Height, iCol)
    Endif
  Endif
  
  If YL < 0 Or If YL = Y Then
    If $bShowLineNumber Then
      If (Row + 1) Mod 10 = 0 Then
        iCol = $iForeground
      Else
        iCol = $iLimitColor
      Endif
      Paint.Background = iCol
      sStr = CStr(Row + 1 + $iLineNumberOffset)
      Paint.DrawText(sStr, X, Y, $iWidthLineNumber - 4, H, Align.Right)
      ' If Row = $Y Then 
      '   Paint.Background = Color.SetAlpha(iCol, 128)
      '   Paint.DrawText(sStr, X + 1, Y, $iWidthLineNumber - 4, H, Align.Right)
      ' Endif
    Endif
  Endif
  
  If YL >= 0 Then Paint.FillRect(X, YL, Width, 1, $iLimitColor)
  
  If $bShowIcon Or If $bShowExpand Then

    If hInfo.Breakpoint Or If hInfo.Bookmark Or If hInfo.Limit Then

      Paint.Save
      Paint.Translate(X + $iPosIcon + H / 4, Y + H / 4)
      S = H / 2
      Paint.LineWidth = S / 6
      
      If hInfo.Breakpoint Then
        Paint.Ellipse(0, 0, S, S)
        Paint.Background = Color.SetAlpha($hStyles[Highlight.Breakpoint].Color, 128)
        Paint.Fill(True)
        Paint.Stroke
      Endif
      
      If hInfo.Bookmark Then
        SS = S / 3
        Paint.MoveTo(0, SS)
        Paint.RelLineTo(SS, SS)
        Paint.RelLineTo(2 * SS, - SS * 2)
        Paint.LineWidth = SS / 2
        Paint.Background = $hStyles[Highlight.Current].Color
        Paint.Stroke
      Endif
      
      If $bShowExpand Then
        If hInfo.Limit Then
          SS = S / 2
          Paint.Background = $iForeground
          'Style.PaintArrow(0, 0, S, S, If(_IsRowExpanded(Row), Align.Bottom, Align.Right))
          'Style.PaintArrow(X + $iPosIcon + 3, Y + 3, S, S, If(_IsRowExpanded(Row), Align.Bottom, Align.Right))
          Paint.MoveTo(0, SS)
          Paint.RelLineTo(S, 0)
          If Not _IsRowExpanded(Row) Then
            Paint.MoveTo(SS, 0)
            Paint.RelLineTo(0, S)
          Endif
          Paint.LineCap = Paint.LineCapRound
          Paint.Stroke
        Endif
      Endif
      
      Paint.Restore
      
    Endif
      
  Endif
  
End

Public Sub TextWidth(sText As String) As Integer

  Dim aText As String[]
  Dim I As Integer
  Dim W As Float
  
  If InStr(sText, "\t") = 0 Then
    If $fCharWidth Then
      Return $fCharWidth * String.Len(sText)
    Else
      Return $hFont.TextWidth(sText)
    Endif
  Endif
  
  If Not sText Then Return 0
  aText = Split(sText, "\t")
  
  If $fCharWidth Then
    
    For I = 0 To aText.Max - 1
      W += $fCharWidth * String.Len(aText[I])
      W = (CInt(W + $iTabWidth) \ $iTabWidth) * $iTabWidth
    Next
    W += $fCharWidth * String.Len(aText[aText.Max])
    
  Else
  
    For I = 0 To aText.Max - 1
      W += $hFont.TextWidth(aText[I])
      W = (CInt(W + $iTabWidth) \ $iTabWidth) * $iTabWidth
    Next
    W += $hFont.TextWidth(aText[aText.Max])
      
  Endif
  
  Return CInt(W)
  
End


Private Sub LinePos(Y As Integer, Optional X As Integer = -1) As Point

  Dim aLayout As Integer[]
  Dim I As Integer
  Dim P As Integer
  Dim hPos As Point
  Dim cCache As Collection
  Dim XO As Integer
  Dim XX As Integer
  
  XO = X
  Try hPos = $cCachePos[Y][XO]
  If hPos Then 
    'Debug "cache";; X;; Y;; "->";; hPos;; hPos.X;; hPos.Y
    Return hPos
  Endif
  
  If $cLineLayout Then
    aLayout = $cLineLayout[Y]
    If aLayout Then
      For I = 0 To aLayout.Max
        If X < aLayout[I] Then Break
        P += aLayout[I]
        X -= aLayout[I]
      Next
      XX = TextWidth(String.Mid$($hDoc.Lines[Y], P + 1, X))
      If I Then XX += LineStartPos(Y)
      hPos = Point(XX, I * $LH)
      Goto RETURN_POS
    Endif
  Endif

  hPos = New Point
  If X < 0 Then
    hPos.X = TextWidth($hDoc.Lines[Y])
  Else
    hPos.X = TextWidth(String.Left($hDoc.Lines[Y], X))
  Endif
  
RETURN_POS:
  
  cCache = $cCachePos[Y]
  If Not cCache Then
    If $cCachePos.Count > 80 Then
      For Each $cCachePos
        $cCachePos.Remove($cCachePos.Key)
        Break
      Next
    Endif
    cCache = New Collection
    $cCachePos[Y] = cCache
  Endif
  cCache[XO] = hPos
  
  'Debug "calc";; X;; Y;; "->";; hPos;; hPos.X;; hPos.Y
  Return hPos

End

Private Sub LineStartPos(Y As Integer) As Integer

  Dim S As Integer
  Dim aLayout As Integer[]
  
  S = Len($hDoc.Lines[Y]) - Len(LTrim($hDoc.Lines[Y]))
  Try aLayout = $cLineLayout[Y]
  If aLayout And If S >= aLayout[0] Then S = aLayout[0] - 1
  Return LinePos(Y, S).X
  
End


Private Sub FindLargestLine() As Integer

  Dim I As Integer
  Dim W As Integer
  Dim WM As Integer = -1

  If $hDoc.Count >= 10000 Then Inc Application.Busy

  For I = 0 To $hDoc.Count - 1
    W = LinePos(I).X
    If W > WM Then
      WM = W
      $iLargestLine = I
    Endif
  Next
  
  If $hDoc.Count >= 10000 Then Dec Application.Busy

  Return WM

End

Private Sub UpdateWidth(Optional Y As Integer = -1)

  Dim W As Integer
  
  If $cLineLayout Then
    If $iWidth <> $hView.ClientWidth Then
      $iWidth = $hView.ClientWidth
      _ResizeContents
    Endif
    Return
  Endif
  
  If $iLargestLine < 0 Or If $iLargestLine > $hDoc.Max Then
    FindLargestLine
    Y = -1
  Endif

  If Y < 0 Then
    W = LinePos($iLargestLine).X + $MW + 2
    Goto UPDATE_WIDTH
  Endif

  W = LinePos(Y).X + $MW + 2
  If W > $iWidth Then
    $iLargestLine = Y
    Goto UPDATE_WIDTH
  Else If W < $iWidth And If Y = $iLargestLine Then
    W = FindLargestLine() + $MW + 2
    Goto UPDATE_WIDTH
  Endif
  
  Return
  
UPDATE_WIDTH:

  $iWidth = Max($hView.ClientWidth, W)
  _ResizeContents

End

Public Sub TimerCursor_Timer()
  
  If $bMouseDown Then Return
  $bShowCursor = Not $bShowCursor
  _RefreshLine($Y)
  
End

Public Sub View_KeyPress()
  
  Dim Y As Integer
  Dim sAction As String
  Dim sTab As String
  Dim bCancel As Boolean
  Dim aLayout As Integer[]
  Dim I, P As Integer
  Dim bSaveOverwrite As Boolean = $bOverwrite
  bCancel = Raise KeyPress
  If bCancel Then Goto STOP_EVENT

  Try sAction = $cShortcut[Shortcut.FromKey()]
  If sAction Then
    Select Case sAction
      Case "Copy"
        Copy()
      Case "Paste"
        If $bReadOnly Then Goto STOP_EVENT
        Paste()
      Case "Undo"
        If $bReadOnly Then Goto STOP_EVENT
        Undo()
      Case "Redo"
        If $bReadOnly Then Goto STOP_EVENT
        Redo()
      Case "Cut"
        If $bReadOnly Then Goto STOP_EVENT
        Cut()
      Case "SelectAll"
        SelectAll
    End Select
    Goto STOP_EVENT
  Endif
  
  If Key.Text And If Asc(Key.Text) >= 32 And If Asc(Key.Text) <> 127 Then 
    If Not $bReadOnly Then Insert(Key.Text)
    Goto STOP_EVENT
  Endif
    
  Select Case Key.Code
    
    Case Key.Right
      If Key.Control Then
        If $X >= $hDoc.LineLength[$Y] Then
          Goto(0, _ViewToReal(_RealToView($Y) + 1), Key.Shift)
        Else
          Goto($hDoc.WordRight($X, $Y), $Y, Key.Shift)
        Endif
      Else If Key.Normal Or If Key.Shift Then
        If $X >= $hDoc.LineLength[$Y] Then
          Goto(0, _ViewToReal(_RealToView($Y) + 1), Key.Shift)
        Else
          Goto($X + 1, $Y, Key.Shift)
        Endif
      Endif
    
    Case Key.Left
      '$X = NormalizeColumn($X, $Y)
      If Key.Control Then
        If $X = 0 Then
          Goto(-1, _ViewToReal(_RealToView($Y) - 1), Key.Shift)
        Else
          Goto($hDoc.WordLeft($X, $Y), $Y, Key.Shift)
        Endif
      Else If Key.Normal Or If Key.Shift Then
        If $X = 0 Then
          Goto(-1, _ViewToReal(_RealToView($Y) - 1), Key.Shift)
        Else
          Goto($X - 1, $Y, Key.Shift)
        Endif
      Endif
      
    Case Key.Up
      If Key.Alt Then
        MoveSelection(True)
      Else If Key.Control Then
        Y = FindPreviousLimit($Y)
        If Y >= 0 Then 
          Goto($X, Y, Key.Shift)
        Else
          Goto(0, 0, Key.Shift)
        Endif
      Else
        'Goto($X, ViewToReal(RealToView($Y) - 1), Key.Shift)
        'Y = RealToView($Y)
        GotoXY($X0 + $MW - $hView.ScrollX, $hRows._GetRowY($Y) - $hView.ScrollY + $XY.Y - $hRows.H, Key.Shift)
      Endif
      
    Case Key.Down
      If Key.Alt Then
        MoveSelection(False)
      Else If Key.Control Then
        Y = FindNextLimit($Y)
        If Y >= 0 Then 
          Goto($X, Y, Key.Shift)
        Else
          Goto(-1, $hDoc.Max, Key.Shift)
        Endif
      Else
        'Goto($X, ViewToReal(RealToView($Y) + 1), Key.Shift)
        'Y = RealToView($Y)
        GotoXY($X0 + $MW - $hView.ScrollX, $hRows._GetRowY($Y) - $hView.ScrollY + $XY.Y + $hRows.H, Key.Shift)
      Endif
      
    Case Key.Home
      If Key.Control Then
        Goto(0, 0, Key.Shift)
      Else
        Try aLayout = $cLineLayout[$Y]
        If Not aLayout Or If $X < aLayout[0] Then
          P = GetIndent($Y)
          If P = $X Then P = 0
          Goto(P, $Y, Key.Shift)
        Else
          P = aLayout[0]
          For I = 1 To aLayout.Max
            If $X < P + aLayout[I] Then Break
            P += aLayout[I]
          Next
          If P = $X Then P = GetIndent($Y)
          Goto(P, $Y, Key.Shift)
        Endif
      Endif
      
    Case Key.End
      If Key.Control Then
        Goto(-1, $hDoc.Max, Key.Shift)
      Else
        Try aLayout = $cLineLayout[$Y]
        If Not aLayout Then
          Goto(-1, $Y, Key.Shift)
        Else
          P = 0
          For I = 0 To aLayout.Max
            P += aLayout[I]
            If $X < P Then 
              Dec P
              Break
            Endif
          Next
          If P = $X Or If I = aLayout.Count Then P = -1
          Goto(P, $Y, Key.Shift)
        Endif
      Endif
      
    Case Key.PageUp
      'Y = RealToView($Y)
      'Y = $hRows._FindRowFromPos($hRows._GetRowY($Y) + $hRows._GetRowHeight($Y) - $hView.ClientH)
      'Y = ViewToReal(Y)
      'Goto($X, Max(0, Y), Key.Shift)
      If Not Key.Control And If Not Key.Alt And If Not Key.Meta Then
        If GotoXY($X0 + $MW - $hView.ScrollX, $hRows._GetRowY($Y) + $XY.Y - $hView.ClientH - $hView.ScrollY, Key.Shift) Then
          Goto(0, 0, Key.Shift)
        Endif
      Endif
      
    Case Key.PageDown
      'Y = RealToView($Y)
      'Y = $hRows._FindRowFromPos($hRows._GetRowY($Y) + $hView.ClientH)
      'Y = ViewToReal(Y)
      'If Y >= 0 Then 
        'Goto($X, Y, Key.Shift)
      'Else
        'Goto($X, $hDoc.Max, Key.Shift)
      'Endif
      If Not Key.Control And If Not Key.Alt And If Not Key.Meta Then
        If GotoXY($X0 + $MW - $hView.ScrollX, $hRows._GetRowY($Y) + $XY.Y + $hView.ClientH - $hView.ScrollY, Key.Shift) Then
          Goto(-1, $hDoc.Max, Key.Shift)
        Endif
      Endif
      
      
    Case Key.Enter, Key.Return
      
      If $bShowExpand Then
        If Key.Control Then
          Y = FindPreviousLimit($Y + 1)
          If Y >= 0 Then
            If Key.Alt Then
              If _IsRowExpanded(Y) Then
                CollapseAll
              Else
                ExpandAll
              Endif
            Else
              ToggleRow(Y)
            Endif
          Endif
          Goto STOP_EVENT
        Endif
      Endif
      
      If $bReadOnly Then Goto STOP_EVENT
      
      If Not $bPrint Then $bOverwrite = False
      sTab = GetIndentText($Y)
      Insert("\n" & String.Left(sTab, $X))
      'If Not $bPrint Then $bOverwrite = True
      $bOverwrite = bSaveOverwrite
      
    Case Key.BackSpace
      If Key.Control Then
        If $bReadOnly Then Goto STOP_EVENT
        DeleteWordLeft
      Else If Key.Normal Then
        If $bReadOnly Then Goto STOP_EVENT
        DeleteLeft
      Endif
    
    Case Key.Delete
      If Key.Control Then
        If $bReadOnly Then Goto STOP_EVENT
        DeleteWordRight
      Else If Key.Normal Then
        If $bReadOnly Then Goto STOP_EVENT
        DeleteRight
      Endif
      
    Case Key.Tab
      If Key.Control Then
        If $bReadOnly Then Goto STOP_EVENT
        Insert("\t")
      Else
        DoIndent(Key.Shift)
      Endif
      
    Case Key.BackTab
      DoIndent(True)
      
    Case Key.Insert
      Me.Overwrite = Not $bOverwrite
    
  End Select
  
STOP_EVENT:

  Stop Event
  
End

Public Sub HideSelection()

  If HasSelection() Then Refresh
  $SX = $X
  $SY = $Y
  $SXY = $XY.Copy()

End

Public Sub _RaiseCursor()

  If $iSaveCursor Then Return
  If $X = $LX And If $Y = $LY Then Return
  If $hDoc.IsLocked() Then Return

  $LX = $X
  $LY = $Y
  EnsureVisible
  If $bShowPosition Then UpdatePosition
  Raise Cursor

End

Public Sub Goto(NX As Integer, NY As Integer, Optional Mark As Boolean)

  Dim bRaiseCursor As Boolean
  Dim SX As Integer
  Dim SY As Integer
  Dim SXY As Point
  Dim iLen As Integer
  
  If NY < 0 Then Return
  If NY > $hDoc.Max Then 
    NY = $hDoc.Max
    NX = -1
  Endif
  
  NY = CheckFolded(NY)
  
  If NY <> $Y Then
    SX = $SX
    SY = $SY
    SXY = $SXY
    $hDoc.HighlightFrom($Y)
    If Mark Then
      If $SX <> SX Or If $SY <> SY Then
        $SX = SX
        $SY = SY
        $SXY = LinePos($SY, $SX)
      Endif
    Endif
  Endif
  
  iLen = $hDoc.LineLength[NY]
  If NX < 0 Or If NX > iLen Then NX = iLen
  
  If Not Mark Then HideSelection
  
  _RefreshLine($Y)
  
  If NX <> $X Or If NY <> $Y Then
    
    If Not Mark Then
      _RefreshLine(NY)
    Else
      _RefreshLine(Min(NY, $Y), Max(NY, $Y) - Min(NY, $Y) + 1)
    Endif
    
    $X = NX
    $Y = NY
    $XY = LinePos($Y, $X)
    '$XM = 0
    '$YM = -1
    bRaiseCursor = True
  Endif
  $X0 = $XY.X
  
  If Not Mark Then
    $SX = $X
    $SY = $Y
    $SXY = $XY
  Else
    Clipboard.Current = Clipboard.Selection
    Copy()
    Clipboard.Current = Clipboard.Default
  Endif
  
  $bShowCursor = True
  If Not $bReadOnly Then $hTimerCursor.Start
  
  '$hView.EnsureVisible($XX, $hRows._GetRowY($Y), $MW + 3, $hRows._GetRowHeight($Y))
  
  CheckMatch
  _RaiseCursor
  
End

Private Sub EnsureVisible(Optional bCenter As Boolean)

  Dim Y As Integer
  Dim H As Integer
  
  'Y = RealToView($Y)
  H = $hRows.H '_GetRowHeight(Y)
  Y = $hRows._GetRowY($Y) + $XY.Y
  
  If bCenter Then
    Y = Y - $hView.ClientH \ 2 + H \ 2
    H = $hView.ClientH
  Endif

  If $XY.X > $hView.ClientW Then
    $hView.EnsureVisible($XY.X, Y, $MW + 3, H)
  Else
    $hView.EnsureVisible(0, Y, $hView.ClientW, H)
  Endif
  
End

Public Sub GotoCenter(NX As Integer, NY As Integer)

  Goto(NX, NY)
  If Not $hTimerEnsureVisible Then
    $hTimerEnsureVisible = New Timer As "EnsureVisible"
    $hTimerEnsureVisible.Trigger
  Endif

End

Public Sub EnsureVisible_Timer()
  
  EnsureVisible(True)
  $hTimerEnsureVisible.Stop
  $hTimerEnsureVisible = Null
  
End


Private Sub PosToColumn(Y As Integer, PX As Integer, RY As Integer) As Integer

  Dim I As Integer 
  Dim iLen As Integer
  Dim D As Integer
  Dim F As Integer
  Dim sStr As String
  Dim LP As Point
  Dim J As Integer
  
  sStr = $hDoc.Lines[Y]
  iLen = $hDoc.LineLength[Y]
  
  If PX < $MW Then Return 0
  
'   if (px < margin || px >= visibleWidth())
'     _posOutside = true;
'
  If iLen = 0 Then Return PX \ $hFont.TextWidth("m")

  PX += $hView.ScrollX - $MW
  RY = (RY \ $hRows.H) * $hRows.H

'   px += contentsX();
'   
  D = 0
  F = iLen
  J = -1
  
  Do
    
    I = (D + F) \ 2
    If I = J Then Break
    J = I
    
    LP = LinePos(Y, I)
    
    If RY < LP.Y Or If RY = LP.Y And PX < LP.X Then
      F = I
    Else If RY > LP.Y Or If PX > LP.X Then
      D = I + 1
    Else
      D = I
      Break
    Endif
    
    ' 'LP = LinePos(Y, I + 1)
    ' If RY > LP.Y Or If PX >= LP.X Then
    '   D = I '+ 1
    '   Continue
    ' Endif
    ' 
    ' D = I
    ' Break
    
  Loop

  If LP Then  
    If LP.Y < RY Then
      D = Min(iLen, D + 1)
    Else If LP.Y > RY Then
      D = Max(0, D - 1)
    Endif
  Endif
'   _posOutside = d > len;
  Return D
  
End

Private Sub PosToLine(PY As Integer) As Integer

  Return $hRows._FindRowFromPos(PY + $hView.ScrollY)

End

Public Sub View_MouseDown()

  Dim Y As Integer
  Dim X As Integer
  Dim RY As Integer
  
  $bFirstFocus = True
  
  If Mouse.Right Then Return
  
  Y = PosToLine(Mouse.Y)
  RY = $hRows.RelativeY
  
  If Y >= 0 Then
    If Mouse.X < $MW And If Mouse.X >= $iPosIcon Then
      If Mouse.Left Then
        Goto(0, Y, Mouse.Shift)
        If Mouse.Normal And If $bShowExpand And If $hDoc.Info(Y).Limit Then
          ToggleRow(Y)
        Endif
      Endif
    Else
      'X = NormalizeColumn(PosToColumn(Y, Mouse.X, RY), Y)
      X = PosToColumn(Y, Mouse.X - 4, RY)
      Goto(X, Y, Mouse.Shift)
    Endif
  Endif
  
  $bMouseDown = True

End

Public Sub View_DblClick()
  
  Dim X, Y As Integer
  
  If Mouse.Right Then Return
  
  If $bShowIcon Or If $bShowExpand Then
    Y = PosToLine(Mouse.Y)
    If Mouse.X < $MW And If Mouse.X >= $iPosIcon Then 
      If $bShowExpand And If $hDoc.Info(Y).Limit Then
        If _IsRowExpanded(Y) Then
          ExpandAll
        Else
          CollapseAll
        Endif
      Else
        Goto(0, Y)
        Raise Margin
        Stop Event
      Endif
    Endif
  Endif
  
  If Mouse.X >= $MW Then
    X = $X
    If $X >= 0 Then Goto($hDoc.WordLeft($X, $Y, True), $Y)
    If $X < $hDoc.LineLength[$Y] Then X = $hDoc.WordRight($X, $Y, True)
    Goto(X, $Y, True)
  Endif
  
End

Public Sub View_MouseDrag()
  
  If Mouse.Right Then Return
  
  If Not $hTimerScroll Then
    $hTimerScroll = New Timer As "TimerScroll"
    $hTimerScroll.Delay = 50
    $hTimerScroll.Start
  Endif
  
End


Public Sub View_MouseMove()
  
  Dim Y, RY As Integer
  Dim X As Integer

  If (Mouse.ScreenX - $hView.ScreenX) < $MW Then
    $hView.Mouse = Mouse.Default
  Else
    $hView.Mouse = Mouse.Text
  Endif

  If $bMouseDown Then
  
    Y = PosToLine(Mouse.ScreenY - $hView.ScreenY)
    RY = $hRows.RelativeY
    If Y >= 0 Then
      'X = NormalizeColumn(PosToColumn(Y, Mouse.ScreenX - $hView.ScreenX, RY), Y)
      X = PosToColumn(Y, Mouse.ScreenX - $hView.ScreenX, RY)
      Goto(X, Y, True)
    Endif
    
  Endif
  
End

Public Sub View_MouseUp()
  
  If $hTimerScroll Then
    $hTimerScroll.Stop
    $hTimerScroll = Null
  Endif
  
  If Mouse.Middle Then
    Clipboard.Current = Clipboard.Selection
    Paste
    Clipboard.Current = Clipboard.Default
  Endif
  
  $bMouseDown = False
    
End

Public Sub TimerScroll_Timer()
  
  View_MouseMove
  
End

Private Function Line_Read() As Integer

  Return $Y

End

Private Function Column_Read() As Integer

  Return $X

End

Private Function SelectionLine_Read() As Integer

  Return $SY

End

Private Function SelectionColumn_Read() As Integer

  Return $SX

End

Private Function Selected_Read() As Boolean

  Return HasSelection()

End

Private Sub DeleteSelection() As Boolean

  If HasSelection() Then
    Remove($SX, $SY, $X, $Y)
    Return True
  Endif
  
End

' Private Sub NormalizeColumn(X As Integer, Y As Integer) As Integer
' 
'   Return Min(String.Len($hDoc.Lines[Y]), X)
' 
' End

Public Sub Insert(Text As String)
  
  Dim aText As String[]
  Dim I As Integer
  
  DeleteSelection
  If Not Text Then Return

  '$X = NormalizeColumn($X, $Y)
  
  $hDoc.Begin
  
  If $bOverwrite Then
    
    aText = Split(Text, "\n")
    
    For I = 0 To aText.Max - 1
      Remove($X, $Y, $X + String.Len(aText[I]), $Y)
      If $Y = $hDoc.Max Then 
        $hDoc.Insert(aText[I] & "\n", $X, $Y)
      Else
        $hDoc.Insert(aText[I], $X, $Y)
      Endif
      Goto(0, $Y + 1)
    Next
    
    Remove($X, $Y, $X + String.Len(aText[aText.Max]), $Y)
    $hDoc.Insert(aText[aText.Max], $X, $Y)
    
  Else
    
    $hDoc.Insert(Text, $X, $Y)
    
  Endif

  Goto($hDoc.XAfter, $hDoc.YAfter)
  $hDoc.End
  
End

Public Sub _BeforeInsert(Y1 As Integer, N As Integer)
  
  $hRows._BeforeInsert(Y1, N, $cLineLayout)
  
End

Public Sub _AfterInsert(Y1 As Integer, Y2 As Integer, N As Integer)

  Dim Y As Integer
  
  _ExpandInsert(Y1, N)
  
  If Not $cLineLayout Then
    
    If $iLargestLine >= Y1 Then $iLargestLine += N
  
    For Y = Y1 To Y2
      UpdateWidth(Y)
    Next
    
  Endif
    
  If $cLineLayout Then
    
    'If N > 0 Then _UpdateAllHeight(True)
    
  Endif
  
  UpdateMargin
  UpdateCount

End


Private Function SelectedText_Read() As String

  If Not HasSelection() Then Return  
  Return $hDoc.GetText($X, $Y, $SX, $SY)

End

Public Sub Copy()
  
  If Not HasSelection() Then Return
  Clipboard.Copy(Me.SelectedText)
  
End

Public Sub Paste()

  Dim sText As String
  
  If Clipboard.Type <> Clipboard.Text Then Return
  sText = Clipboard.Paste("text/plain")
  If Not sText Then Return
  
  Insert(sText)
  
End

Public Sub SelectAll()
  
  Goto(0, 0)
  Goto(-1, $hDoc.Max, True)
  
End

Public Sub Remove(X1 As Integer, Y1 As Integer, X2 As Integer, Y2 As Integer)
  
  'Goto(X1, Y1)
  
  $hDoc.Begin
  $hDoc.Remove(X1, Y1, X2, Y2)
  
  Goto($hDoc.XAfter, $hDoc.YAfter)
  $hDoc.End
  
End

Public Sub _AfterRemove(Y1 As Integer, Y2 As Integer)
  
  Dim X As Integer
  Dim Y As Integer
  
  If Y1 > Y2 Then Swap Y1, Y2
  
  _ClearCachePos
  
  If Y2 > Y1 Then
    $hRows._AfterRemove(Y1, Y2, $cLineLayout)
  Endif
  
  _ExpandRemove(Y1, Y2)
  
  Y = Min($Y, $hDoc.Max)
  X = Min($X, $hDoc.LineLength[Y])
  If X <> $X Or If Y <> $Y Then Goto(X, Y)
  
  $SX = $X
  $SY = $Y

  If Not $cLineLayout Then  
    
    If $iLargestLine >= Y1 Then
      If $iLargestLine <= Y2 Then
        $iLargestLine = -1
        UpdateWidth
      Else
        $iLargestLine -= Y2 - Y1
      Endif
    Endif
  
  Else
  
    'If Y2 > Y1 Then _UpdateAllHeight(True)
    
  Endif
  
  UpdateMargin
  UpdateCount
  
End


Private Sub DeleteLeft()

  Dim sTab As String
  
  If DeleteSelection() Then Return

  '$X = NormalizeColumn($X, $Y)
  
  If $X = 0 Then
    If $Y > 0 Then
      Remove($hDoc.LineLength[$Y - 1], $Y - 1, 0, $Y)
    Endif
  Else
    sTab = GetIndentText($Y)
    If Len(sTab) = Len($hDoc.Lines[$Y]) Then
      If Right(sTab) = "\t" Then
        Remove($X - 1, $Y, $X, $Y)
      Else
        Remove((($X - 1) \ $iTabSize) * $iTabSize, $Y, $X, $Y)
      Endif
    Else
      Remove($X - 1, $Y, $X, $Y)
    Endif
  Endif

End

Private Sub DeleteWordLeft()
  
  Dim X As Integer
  
  If DeleteSelection() Then Return

  If $X = 0 Then
    DeleteLeft
    Return
  Endif
  
  X = $hDoc.WordLeft($X, $Y)
  If X = $X Then Return
  
  Begin()
  Goto(X, $Y, True)
  DeleteSelection()
  End()
  
End

Private Sub DeleteWordRight()
  
  Dim X As Integer
  
  If DeleteSelection() Then Return

  If $X >= $hDoc.LineLength[$Y] Then
    DeleteRight
    Return
  Endif
  
  X = $hDoc.WordRight($X, $Y)
  If X = $X Then Return
  
  Begin()
  Goto(X, $Y, True)
  DeleteSelection()
  End()
  
End


Private Sub DeleteRight()

  If DeleteSelection() Then Return

  If $X >= $hDoc.LineLength[$Y] Then
    If $Y < $hDoc.Max Then
      Remove($X, $Y, 0, $Y + 1)
    Endif
  Else
    Remove($X, $Y, $X + 1, $Y)
  Endif

End

Private Sub GetIndent(Y As Integer, Optional bIgnoreEmpty As Boolean) As Integer

  Dim sText As String
  Dim I As Integer
  Dim sCar As String

  sText = $hDoc.Lines[Y]
  For I = 1 To Len(sText)
    sCar = Mid$(sText, I, 1)
    If sCar <> " " And If sCar <> "\t" Then Break
  Next
  
  If bIgnoreEmpty And If I > Len(sText) Then Return -1
  Return I - 1

End

Private Sub GetIndentText(Y As Integer) As String
  
  Return String.Left($hDoc.Lines[Y], GetIndent(Y))
  
End


' Private Sub IsVisible(Y As Integer) As Boolean
' 
'   If Y < $hView.RowAt(0) Then Return
'   If Y > $hView.RowAt($hView.ClientH - 1) Then Return
'   Return True
'   
' End

Private Sub CheckMatch()
  
  Dim sCar As String
  Dim X, Y As Integer
  Dim iMatch As Integer
  Dim N, L As Integer
  Dim sOther As String
  Dim sLine As String
  Dim iLen As Integer
  Dim iOldXM, iOldYM As Integer
  
  iOldXM = $XM
  iOldYM = $YM
  
  $XM = 0
  $YM = -1

  If $bShowBraces Then 
  
    Y = $Y
    X = Min($hDoc.LineLength[Y], $X)
    
    If X > 0 Then 
      sCar = String.Mid$($hDoc.Lines[Y], X, 1)
      iMatch = InStr(MATCH_STRING, sCar)
      If iMatch Then Goto FIND_MATCH
    Endif
    
    Inc X
    sCar = String.Mid$($hDoc.Lines[Y], X, 1)
    iMatch = InStr(MATCH_STRING, sCar)
    If iMatch Then Goto FIND_MATCH
    
  Endif
  
  Goto FOUND
  
FIND_MATCH:

  If Odd(iMatch) Then
    sOther = Mid$(MATCH_STRING, iMatch + 1, 1)
  Else
    sOther = Mid$(MATCH_STRING, iMatch - 1, 1)
  Endif

  L = 1  
  Dec X
  $XMO = X
  $YMO = Y
  
  sLine = $hDoc.Lines[Y]
  iLen = $hDoc.LineLength[Y]

  Do
    
    If Odd(iMatch) Then
      
      Inc X
      
      While X >= iLen
        
        X = 0
        Inc Y
        If Y > $hDoc.Max Then Goto FOUND
        Inc N
        If N > 1000 Then Goto FOUND
        
        sLine = $hDoc.Lines[Y]
        iLen = $hDoc.LineLength[Y]
        
      Wend
      
    Else
      
      Dec X
      
      While X < 0
        
        Dec Y
        If Y < 0 Then Goto FOUND
        Inc N
        If N > 1000 Then Goto FOUND
        
        sLine = $hDoc.Lines[Y]
        X = $hDoc.LineLength[Y] - 1
        
      Wend
      
    Endif
    
    Select Case String.Mid$(sLine, X + 1, 1)
      
      Case sOther 
        Dec L
        If L = 0 Then
          $XM = X
          $YM = Y
          Goto FOUND
        Endif
        
      Case sCar
        Inc L
        
    End Select
    
  Loop
  
FOUND:

  If $XM <> iOldXM Or If $YM <> iOldYM Then 
    _RefreshLine(iOldYM)
    _RefreshLine($Y)
    _RefreshLine($YM)
  Endif
  
End

Public Sub _RefreshLine(Y As Integer, Optional N As Integer = 1)

  Dim I As Integer
  Dim hPict As Picture
  
  If Y < 0 Or If Y > $hDoc.Max Or If N <= 0 Then Return
  
  N = Min(N, $hDoc.Count - Y)
  
  If Not $bRemoteDisplay Then
    For I = Y To Y + N - 1
      hPict = $cCacheLine[I]
      If hPict Then
        $iCacheLineH -= hPict.H
        $cCacheLine.Remove(I)
      Endif
    Next
  Endif
  
  If N = 1 Then
    $hView.RefreshRect(0, $hRows._GetRowY(Y), $hView.ScrollW, $hRows._GetRowHeight(Y))
  Else
    $hView.RefreshRect(0, $hRows._GetRowY(Y), $hView.ScrollW, $hRows._GetRowY(Y + N) - $hRows._GetRowY(Y))
  Endif

End

Private Function ReadOnly_Read() As Boolean

  Return $bReadOnly

End

Private Sub ReadOnly_Write(Value As Boolean)

  $bReadOnly = Value
  $hTimerCursor.Enabled = Not Value
  $hView.Mouse = If($bReadOnly, Mouse.Default, Mouse.Text)

End


Private Function Highlight_Read() As String

  Return $hDoc.Highlight

End

Private Sub Highlight_Write(Value As String)

  $hDoc.Highlight = Value

End

Private Function LineNumberOffset_Read() As Integer

  Return $iLineNumberOffset

End

Private Sub LineNumberOffset_Write(Value As Integer)

  $iLineNumberOffset = Value
  UpdateMargin
  Refresh

End

Private Function TabSize_Read() As Integer

  Return $iTabSize

End

Private Sub TabSize_Write(Value As Integer)

  $iTabSize = Max(2, Value)
  CalcSizes

End

Private Sub GetSelection(ByRef X1 As Integer, ByRef Y1 As Integer, ByRef X2 As Integer, ByRef Y2 As Integer)

  X1 = $X
  Y1 = $Y
  X2 = $SX
  Y2 = $SY
  
  If Y1 > Y2 Then
    Swap X1, X2
    Swap Y1, Y2
  Endif
  
  If X1 > X2 Then
    Swap X1, X2
  Endif

End

Private Sub DoIndent(bBack As Boolean)

  Dim X1, Y1, X2, Y2 As Integer
  Dim Y As Integer
  Dim iInd As Integer
  Dim sTab As String
  Dim I As Integer

  If Not HasSelection() Then
    
    If Not bBack Then
      Insert(Space$($iTabSize - $X Mod $iTabSize))
      Return
    Endif
    
    Goto(0, $Y)
    Goto(-1, $Y, True)
    
  Endif

  GetSelection(ByRef X1, ByRef Y1, ByRef X2, ByRef Y2)
  If X2 = 0 Then Dec Y2
  
  iInd = 1024
  For Y = Y1 To Y2
    I = GetIndent(Y, True)
    If I >= 0 Then iInd = Min(iInd, I)
    If iInd = 0 Then Break
  Next
  
  If bBack And iInd = 0 Then Return
  
  $hDoc.Begin
  
  If Not bBack Then
    
    sTab = Space$($iTabSize - (iInd Mod $iTabSize))
    
    For Y = Y1 To Y2
      Goto(0, Y)
      Insert(sTab)
    Next
    
  Else
    
    sTab = Space$(Min(iInd, $iTabSize))
    
    For Y = Y1 To Y2
      If $hDoc.Lines[Y] Begins sTab Then Remove(0, Y, Len(sTab), Y)
    Next
    
  Endif
  
  Goto(0, Y1)
  Goto(0, Y2 + 1, True)
  
  $hDoc.End
  
End

Public Sub Begin()
  
  $hDoc.Begin
  
End

Public Sub End()
  
  $hDoc.End
  
End


Private Function Length_Read() As Integer

  Return $hDoc.Length

End

Private Function Border_Read() As Boolean

  Return $hPanel.Border <> Border.None

End

Private Sub Border_Write(Value As Boolean)

  $hPanel.Border = If(Value, Border.Plain, Border.None)

End

Private Function ScrollBar_Read() As Integer

  Return $hView.ScrollBar

End

Private Sub ScrollBar_Write(Value As Integer)

  $hView.ScrollBar = Value

End

Public Sub _ClearCachePos(Optional Y As Integer = -1)
  
  If Y >= 0 Then
    Try $cCachePos.Remove(Y)
  Else
    $cCachePos.Clear
  Endif
  
End

Public Sub _ResizeContents()
  
  If $bNoResizeContents Then Return

  If $iWidth < $hView.ScrollWidth Then
    _UpdateAllHeight
  Else If $iWidth > $hView.ScrollWidth And If $cLineLayout And If $cLineLayout.Count Then
    _UpdateAllHeight
  Endif
  
  ClearCacheLine
  $hView.ResizeContents($iWidth, $hRows._GetHeight())
  
End

Public Sub View_Draw()
  
  Dim I As Integer
  Dim XO, YO, XX, YY, X, Y, H As Integer
  Dim iRow, iRow2 As Integer
  Dim hClip As Rect
  Dim hRect As Rect
  Dim aRow As Integer[]
  Dim iMaxRow As Integer
  Dim W, NL As Integer
  'Dim hImage As Image
  Dim hPict As Picture
  
  If Not $bUpdateHeightAllowed Then
    $bUpdateHeightAllowed = True
    _UpdateAllHeight(True)
  Endif
  
  If $bStyleChanged Then
    $iBackground = $hStyles[Highlight.Background].Color
    $iForeground = $hStyles[Highlight.Normal].Color
    $iSelectedBackground = $hStyles[Highlight.Selection].Color
    $iLimitColor = Color.Gradient($iBackground, $hStyles[Highlight.Comment].Color)
    $iMultiLineColor = Color.Gradient($iBackground, $iLimitColor)
    $bStyleChanged = False
  Endif

  'Debug Me.Font.ToString();; Draw.Font.ToString()
  
  NL = $hView.ClientH \ $hRows.H + 1
  
  hClip = Paint.ClipRect
  If $hDoc.Count < NL Then Paint.FillRect(hClip.X, hClip.Y, hClip.W, hClip.H, $iBackground)
  
  iRow = $hRows._FindRowFromPos($hView.ScrollY + hClip.Y)
  If iRow < 0 Then Return
  iRow2 = $hRows._FindRowFromPos($hView.ScrollY + hClip.Y + hClip.H - 1)
  If iRow2 < 0 Then iRow2 = $hRows.Count - 1
  
  XO = - $hView.ScrollX
  XX = XO
  YO = - $hView.ScrollY
  YY = YO + $hRows._GetRowY(iRow)
  
  hClip = Paint.ClipRect
  
  Y = YY
  If System.RightToLeft Then
    X = $hView.ClientW
  Else
    X = 0
  Endif
  
  ' Cells
  
  hRect = New Rect($hView.ClientX - $hView.Proxy.X, $hView.ClientY, $hView.ClientW, $hView.ClientH)
  hClip = hClip.Intersection(hRect)
  If Not hClip Then Return
  
  iRow = _RealToView(iRow)
  iRow2 = _RealToView(iRow2)
  
  iMaxRow = iRow2 - iRow
  aRow = New Integer[iMaxRow + 1]
  For I = 0 To iMaxRow
    aRow[I] = _ViewToReal(iRow + I)
  Next
  
  Y = YY
  For I = 0 To iMaxRow
    iRow = aRow[I]
    H = $hRows._GetRowHeight(iRow)
    
    If H >= $hView.ClientH Or If $bRemoteDisplay Then
      Paint.Save
      DrawLine(XX, Y, $iWidth, H, iRow)
      Paint.Restore
    Else
      hPict = $cCacheLine[iRow]
      If Not hPict Then
        hPict = New Picture($iWidth, H)
        hPict.Fill($iBackground)
        Paint.Begin(hPict)
        Paint.Font = $hFont
        DrawLine(0, 0, $iWidth, H, iRow)
        Paint.End
        $cCacheLine[iRow] = hPict
        $iCacheLineH += H
        Paint.DrawPicture(hPict, XX, Y)
        
        While $iCacheLineH > $hView.ClientH 
          For Each hPict In $cCacheLine
            $iCacheLineH -= hPict.H
            $cCacheLine.Remove($cCacheLine.Key)
            Break
          Next
        Wend
        
      Else
        Paint.DrawPicture(hPict, XX, Y)
      Endif
    Endif
    Y += H
  Next
  
  W = $MW
  If $bShowModified Then W -= 4
  If W > 0 Then Paint.FillRect(XX + $hView.ScrollX, hClip.Y, W, hClip.H, Color.Merge($iLimitColor, $iBackground, 0.8))
  
  If $MW Then
    
    Paint.Font = $hFontNumber
    
    Y = YY
    For I = 0 To iMaxRow
      Paint.Save
      H = $hRows._GetRowHeight(aRow[I])
      DrawMargin(XX, Y, $iWidth, H, aRow[I])
      Paint.Restore
      Y += H
    Next
    
  Endif
  
  $hTimerCacheLine.Stop
  $hTimerCacheLine.Start
  
  'PrintCache
  
End

Public Sub View_Resize()
  
  UpdateWidth
  
End

Private Function ShowLimit_Read() As Boolean

  Return $bShowLimit

End

Private Sub ShowLimit_Write(Value As Boolean)

  $bShowLimit = Value
  Refresh

End

Private Function ShowCurrent_Read() As Boolean

  Return $bShowCurrent

End

Private Sub ShowCurrent_Write(Value As Boolean)

  $bShowCurrent = Value
  Refresh

End

Private Function ShowLineNumber_Read() As Boolean

  Return $bShowLineNumber

End

Private Sub ShowLineNumber_Write(Value As Boolean)

  $bShowLineNumber = Value
  UpdateMargin
  Refresh

End

Private Function ShowModified_Read() As Boolean

  Return $bShowModified

End

Private Sub ShowModified_Write(Value As Boolean)

  $bShowModified = Value
  Refresh

End

Public Sub _get(({Line}) As Integer) As _TextEditor_Line
  
  Dim hLine As _TextEditor_Line 
  
  hLine = New _TextEditor_Line
  Object.Attach(hLine, Me, "Line")
  hLine._Line = {Line}
  Return hLine
  
End

Private Function Count_Read() As Integer

  Return $hDoc.Count

End

Public Sub View_Scroll()
  
  If $hView.ScrollX <> $iLastScrollX Then
    ClearCacheLine
    $iLastScrollX = $hView.ScrollX
  Endif
  
  Raise Scroll
  
End

Public Sub _RaiseChange()
  
  If $hTimerChange Then Return
  $hTimerChange = New Timer As "TimerChange"
  $hTimerChange.Trigger
  
End

Public Sub TimerChange_Timer()
  
  If Not $hTimerChange Then Return
  $hTimerChange = Null
  Raise Change
  
End


Private Function ShowPosition_Read() As Boolean

  Return $bShowPosition

End

Private Sub UpdatePosition()

  Dim sText As String
  
  If Not $hLabel Or If Not $hLabel.Visible Then Return
  sText = " " & CStr($X + 1) & ":" & CStr($Y + 1) & If($bOverwrite, "  " & ("Overwrite"), "") & " "
  $hLabel.Text = sText
  $hLabelFrame.Move($hView.ClientW - $hLabel.W - 6, 5, $hLabel.W + 2, $hLabel.H + 2)
  $hLabel.Move(0, 0, $hLabelFrame.ClientW, $hLabelFrame.ClientH)

End

Private Sub ShowPosition_Write(Value As Boolean)

  $bShowPosition = Value
  If $bShowPosition Then
    If Not $hLabel Then
      $hLabelFrame = New Panel(Me)
      $hLabelFrame.Border = Border.Plain
      $hLabelFrame.Background = Color.Background
      $hLabelFrame.Ignore = True
      $hLabel = New Label($hLabelFrame) ' TODO: NULL + gb.gtk => crash!
      $hLabel.AutoResize = True
      '$hLabel.Padding = 0
      $hLabel.Font = Me.Parent.Font
      $hLabel.Show
    Endif
    UpdatePosition
  Else
    If $hLabel Then 
      $hLabelFrame.Delete
      $hLabel = Null
      $hLabelFrame = Null      
    Endif
  Endif

End

Public Sub View_Arrange()
  
  UpdatePosition
  If $cLineLayout Then UpdateWidth
  
End

Private Function Overwrite_Read() As Boolean

  Return $bOverwrite

End

Private Sub Overwrite_Write(Value As Boolean)

  $bOverwrite = Value
  UpdatePosition
  _RefreshLine($Y)

End

Private Function ShowIcon_Read() As Boolean

  Return $bShowIcon

End

Private Sub ShowIcon_Write(Value As Boolean)

  $bShowIcon = Value
  UpdateMargin
  Refresh

End

Private Function LineHeight_Read() As Integer

  Return $LH

End

Private Function Font_Read() As Font

  Return $hView.Font

End

Private Sub Font_Write(Value As Font)

  $hView.Font = Value

End

Private Function Current_Read() As _TextEditor_Line

  Return _get($Y)

End

Private Function StopLine_Read() As Integer

  Return $iStopLine

End

Private Sub StopLine_Write(Value As Integer)

  $iStopLine = Value
  Refresh

End


Private Function EndOfLine_Read() As Integer

  Return $hDoc.EndOfLine

End

Private Sub EndOfLine_Write(Value As Integer)

  $hDoc.EndOfLine = Value

End

Private Function Breakpoints_Read() As Integer[]

  Return $hDoc.Breakpoints

End

Private Sub Breakpoints_Write(Value As Integer[])

  $hDoc.Breakpoints = Value

End

Private Function Bookmarks_Read() As Integer[]

  Return $hDoc.Bookmarks

End

Private Sub Bookmarks_Write(Value As Integer[])

  $hDoc.Bookmarks = Value

End

Public Sub Select(Column As Integer, ({Line}) As Integer, Column2 As Integer, Line2 As Integer)
  
  Goto(Column, {Line})
  Goto(Column2, {Line2}, True)
  
End

Private Function ShowBraces_Read() As Boolean

  Return $bShowBraces

End

Private Sub ShowBraces_Write(Value As Boolean)

  $bShowBraces = Value
  CheckMatch
  Refresh

End

Private Function Styles_Read() As _TextEditor_Styles

  Return $hStyles

End

Public Sub FindPreviousLimit(Y As Integer) As Integer
  
  Do
    Dec Y
    If Y < 0 Then Return -1
    If $hDoc.Info(Y).Limit Then Return Y
  Loop
  
End

Public Sub FindNextLimit(Y As Integer) As Integer
  
  Do
    Inc Y
    If Y > $hDoc.Max Then Return -1
    If $hDoc.Info(Y).Limit Then Return Y
  Loop
  
End

Private Function View_Read() As TextEditor

  Return Object.Parent($hDoc)

End

Private Sub View_Write(Value As TextEditor)

  Me.View._RemoveView(Me)
  Value._AddView(Me)
  GotoCenter(Value.Column, Value.Line)

End

Public Sub _GetDocument() As CDocument
  
  Return $hDoc
  
End


Public Sub _SetDocument(hDoc As CDocument)

  If hDoc Then
    If hDoc = $hDoc Then Return
    $hDoc = hDoc
  Else
    $hDoc = New CDocument
    Object.Attach($hDoc, Me, "Document")
  Endif
  Init
  
End

Public Sub _AddView(hOther As TextEditor)
  
  If hOther = Me Then Return
  
  If Not _Views Then _Views = New TextEditor[]
  _Views.Add(hOther)
  
  hOther._SetDocument($hDoc)
  
End

Public Sub _RemoveView(hOther As TextEditor)
  
  If Not _Views Then Return
  Try _Views.Remove(_Views.FindByRef(hOther))
  If _Views.Count = 0 Then _Views = Null
  
End


Public Sub View_GotFocus()
  
  $hTimerCursor.Start
  
  If Not $bFirstFocus Then
    $bFirstFocus = True
    EnsureVisible(True)
  Endif
  
  If Object.Parent($hDoc) <> Me Then 
  
    _Views = Me.View._Views
    _RemoveView(Me)
    _AddView(Me.View)
    Me.View._Views = Null
    Object.Attach($hDoc, Me, "Document")
    
  Endif
  
End

Public Sub View_LostFocus()
  
  $hTimerCursor.Stop
  $hDoc.HighlightFrom($Y)
  $hTimerCacheLine.Trigger
  
End


Public Sub _GetViews() As TextEditor[]
  
  Dim aView As New TextEditor[]
  
  aView.Add(Me)
  If _Views Then aView.Insert(_Views)
  Return aView
  
End

Public Sub ToPosX(Optional Column As Integer = $X, ({Line}) As Integer = $Y) As Integer
  
  Return LinePos({Line}, Column).X - $hView.ScrollX + $MW
  
End

Public Sub ToPosY(Optional ({Line}) As Integer = $Y) As Integer
  
  Return $hRows._GetRowY({Line}) - $hView.ScrollY
  
End

Public Sub ToPos(Optional ({Line}) As Integer, Column As Integer) As Point

  Dim hPoint As Point
  
  If IsMissing({Line}) Then
    {Line} = $Y
    If IsMissing(Column) Then Column = $X
  Endif
  
  hPoint = LinePos({Line}, Column).Copy()
  hPoint.X += $MW - $hView.ScrollX
  hPoint.Y += $hRows._GetRowY({Line}) - $hView.ScrollY
  Return hPoint
  
End


Public Sub ToColumn(X As Integer, Y As Integer) As Integer

  Dim L As Integer
  Dim RY As Integer
  
  L = PosToLine(Y)
  RY = $hRows.RelativeY
  
  If L < 0 Then Return L
  Return PosToColumn(L, X, RY)
  
End

Public Sub ToLine(Y As Integer) As Integer
  
  Return PosToLine(Y)
  
End

Private Sub GotoXY(X As Integer, Y As Integer, bMark As Boolean) As Boolean
  
  Dim L As Integer
  Dim RY As Integer
  Dim X0 As Integer
  
  L = PosToLine(Y)
  If L < 0 Then Return True
  
  RY = $hRows.RelativeY
  X0 = $X0
  Goto(PosToColumn(L, X, RY), L, bMark)
  $X0 = X0
  
End


Public Sub Indent()
  
  DoIndent(False)
  
End

Public Sub Unindent()
  
  DoIndent(True)
  
End

Private Function Keywords_Read() As String[]

  Return $hDoc.Keywords

End

Public Sub Undo()
  
  $hDoc.Undo
  
End

Public Sub Redo()
  
  $hDoc.Redo
  
End

Public Sub UpperCase()
  
  Dim X As Integer
  Dim Y As Integer
  
  If Not HasSelection() Then Return
  
  X = $SX
  Y = $SY
  Insert(String.UCase($hDoc.GetText($X, $Y, $SX, $SY)))
  Goto($SX, $SY)
  Goto(X, Y, True)
  
End

Public Sub LowerCase()
  
  Dim X As Integer
  Dim Y As Integer
  
  If Not HasSelection() Then Return
  
  X = $SX
  Y = $SY
  Insert(String.LCase($hDoc.GetText($X, $Y, $SX, $SY)))
  Goto($SX, $SY)
  Goto(X, Y, True)
  
End

Private Sub PrintNewLine()

  Dim X As Integer

  X = $X
  Goto(-1, $Y)
  Insert("\n")
  If $bTerminal Then Goto(X, $Y)

End

' static void print_text(void *_object, const char *str, int lstr, bool esc = false)
' {
'   QString s = QString::fromUtf8(str, lstr);
'   int line, col;
'   uint i, len;
'   
'   //fprintf(stderr, "-> %.*s\n", lstr, str);
' 
'   WIDGET->getCursor(&line, &col);
'   /*if (col == 0)
'   {
'     DOC->remove(line, 0, line, DOC->lineLength(line));
'     WIDGET->cursorGoto(line, 0, false);
'   }*/
' 
' //   if (col < DOC->lineLength(line))
' //   {
' //     end = col + s.length();
' //     if (end > DOC->lineLength(line))
' //       end = DOC->lineLength(line);
' //     DOC->remove(line, col, line, end);
' //   }
'   
'   if (!esc)
'   {
'     i = 0;
'     for (;;)
'     {
'       if (col == MAX_CONSOLE_WIDTH)
'       {
'         print_newline(THIS);
'         col = 0;
'       }
'       len = s.length() - i;
'       if ((col + len) >= MAX_CONSOLE_WIDTH)
'         len = MAX_CONSOLE_WIDTH - col;
'       DOC->remove(WIDGET->getLine(), col, WIDGET->getLine(), col + len);
'       WIDGET->insert(s.mid(i, len));
'       i += len;  
'       if (i >= (uint)s.length())
'         break;
'       col += len;
'     }
'   }
'   else
'   {
'     if (col >= MAX_CONSOLE_WIDTH)
'       print_newline(THIS);
'     DOC->remove(WIDGET->getLine(), col, WIDGET->getLine(), col + s.length());
'     WIDGET->insert(s);
'   }
' 
'   //qApp->processEvents(QEventLoop::ExcludeUserInputEvents, 0);
'   //BREAKPOINT();
' }
' 
' static int ansi_read_integer(const char *str, int len, int def, int *pos)
' {
'   int value = 0;
'   int n = 0;
'   uchar c;
' 
'   str += *pos;
'   len -= *pos;
' 
'   while (len > 0)
'   {
'     c = str[n];
'     if (c < '0' || c > '9')
'       break;
'     value = value * 10 + c - '0';
'     len--;
'     n++;
'     if (n > 6)
'     {
'       value = -1;
'       break;
'     }
'   }
' 
'   if (n == 0)
'     value = def;
' 
'   while (len > 0)
'   {
'     c = str[n];
'     len--;
'     n++;
'     if (c == ';' || c < '0' || c > '9')
'       break;
'   }
' 
'   *pos += n;
'   return value;
' }
' 

' Private Sub PrintAnsi(Text As String, I As Integer) As Integer
' 
'   Dim C As String
'   Dim L As Integer
'   
'   If I > Len(Text) Then Return 0
'   
'   C = Mid$(Text, I, 1)
'   If InStr("[]()", C) Then
'     For L = I + 1 To Len(Text)
'       If IsLetter(Mid$(Text, L, 1)) Then Break
'     Next
'     L -= I
'   Endif
' 
' End

' static int ansi_process(void *_object, const char *str, int len)
' {
'   uchar c;
'   int n, m, l, pos;
'   bool print;
' 
'   if (len == 0)
'     return 0;
' 
'   c = *str;
'   if (c == '[' || c == ']' || c == '(' || c == ')')
'   {
'     for (l = 0; l < len; l++)
'     {
'       c = str[l];
'       if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))
'         break;
'     }
'   }
'   else
'     l = 0;
' 
'   if (l >= len)
'     return 0;
' 
'   print = false;
' 
'   if (*str == '[')
'   {
'     pos = 1;
' 
'     switch(str[l])
'     {
'       case 'A':
'         n = ansi_read_integer(str, l, 1, &pos);
'         if (n > 0) WIDGET->cursorRelGoto(-n, 0, false);
'         break;
' 
'       case 'B':
'         n = ansi_read_integer(str, l, 1, &pos);
'         if (n > 0) WIDGET->cursorRelGoto(n, 0, false);
'         break;
' 
'       case 'C':
'         n = ansi_read_integer(str, l, 1, &pos);
'         if (n > 0) WIDGET->cursorRelGoto(0, n, false);
'         break;
' 
'       case 'D':
'         n = ansi_read_integer(str, l, 1, &pos);
'         if (n > 0) WIDGET->cursorRelGoto(0, -n, false);
'         break;
' 
'       case 'G':
'         n = ansi_read_integer(str, l, 1, &pos);
'         if (n > 0) WIDGET->cursorGoto(WIDGET->getLine(), n - 1, false);
'         break;
' 
'       case 'd':
'         n = ansi_read_integer(str, l, 1, &pos);
'         if (n > 0) WIDGET->cursorGoto(n - 1, WIDGET->getColumn(), false);
'         break;
' 
'       case 'H': case 'f':
'         n = ansi_read_integer(str, l, 1, &pos);
'         m = ansi_read_integer(str, l, 1, &pos);
' 
'         while (DOC->numLines() < n)
'           DOC->insertLine(DOC->numLines());
' 
'         WIDGET->cursorGoto(n - 1, m - 1, false);
'         THIS->terminal = TRUE;
'         //qApp->processEvents(QEventLoop::ExcludeUserInputEvents, 0);
'         break;
' 
'       case 'J':
'         n = ansi_read_integer(str, l, 1, &pos);
'         switch(n)
'         {
'           case 0: WIDGET->clearDocument(false, true); break;
'           case 1: WIDGET->clearDocument(true, false); break;
'           case 2: WIDGET->clearDocument(true, true); break;
'         }
' 
'       case 'K':
'         n = ansi_read_integer(str, l, 0, &pos);
'         switch (n)
'         {
'           case 0: WIDGET->clearLine(false, true); break;
'           case 1: WIDGET->clearLine(true, false); break;
'           case 2: WIDGET->clearLine(true, true); break;
'         }
'         break;
' 
'       case 's':
'         WIDGET->saveCursor();
'         break;
' 
'       case 'u':
'         WIDGET->restoreCursor();
'         break;
' 
'       case 'X':
'         n = ansi_read_integer(str, l, 1, &pos);
'         WIDGET->clearAfter(n);
'         break;
' 
'       default:
'         print = FALSE;
'     }
'   }
' 
'   if (print)
'   {
'     fprintf(stderr, "ESC ");
'     for (n = 0; n <= l; n++)
'     {
'       uchar c = str[n];
' 
'       if (c < 32)
'         fprintf(stderr, "\\x%02X", c);
'       else
'         fputc(c, stderr);
'     }
'     fputc('\n', stderr);
' 
'     //qApp->processEvents(QEventLoop::ExcludeUserInputEvents, 0);
'     //BREAKPOINT();
'   }
' 
'   return l;
' }
' 

Private Sub PrintAnsi(Text As String, I As Integer) As Integer

  Dim C As String
  Dim N As Integer
  Dim aParam As New Integer[]
  Dim bDigit As Boolean

  C = Mid$(Text, I, 1)
  
  If C = "[" Then ' [
      
    N = 1
    Inc I
    While I <= Len(Text)
      Inc N
      C = Mid$(Text, I, 1)
      If IsDigit(C) Then
        If Not bDigit Then
          aParam.Add(0)
          bDigit = True
        Endif
        aParam[aParam.Max] = aParam[aParam.Max] * 10 + Asc(C) - 48
      Else If C = ";" Then
        bDigit = False
      Else
        Break
      Endif
      Inc I
    Wend
    
    If I > Len(Text) Then 
      $sPrintBuffer = Chr$(27) & Mid$(Text, I, N)
      Return N
    Endif
    
    Select Case C
      
      Case "A"
        If aParam.Count Then
          RelGoto(0, - aParam[0])
        Else
          RelGoto(0, -1)
        Endif
        
      Case "B"
        If aParam.Count Then
          RelGoto(0, aParam[0])
        Else
          RelGoto(0, 1)
        Endif
        
      Case "C"
        If aParam.Count Then
          RelGoto(aParam[0], 0)
        Else
          RelGoto(1, 0)
        Endif
        
      Case "D"
        If aParam.Count Then
          RelGoto(- aParam[0], 0)
        Else
          RelGoto(-1, 0)
        Endif
        
      
      Case "K"
        aParam.Resize(1)
        Select Case aParam[0]
          Case 0
            ClearLine(False, True)
          Case 1
            ClearLine(True, False)
          Case 2
            ClearLine(True, True)
        End Select
    
    End Select
    
  Endif

  Return N
    
End

Public Sub Print(Text As String)
  
  Dim I, J, C As Integer
  Dim bSaveOverwrite As Boolean
  
  $hDoc.DisableUndo
  bSaveOverwrite = $bOverwrite
  $bOverwrite = True
  $bPrint = True
  
  If $sPrintBuffer Then
    Text = $sPrintBuffer & Text
    $sPrintBuffer = ""
  Endif
  
  J = 1
  For I = 1 To Len(Text)
    
    C = Asc(Text, I)
    
    If C < 32 Then
      
      If I > J Then Insert(Mid$(Text, J, I - J))
      
      J = I + 1
      
      If C = 9 Then
        Insert("\t")
      Else If C = 13 Then
        Goto(0, $Y)
      Else If C = 10 Then
        PrintNewLine 
      Else If C = 12 Then
        Clear
      Else If C = 7 Then
        ' Flash
      Else If C = 8 Then
        If $X > 0 Then Goto($X - 1, $Y)
      Else If C = 27 Then
        I += PrintAnsi(Text, I + 1)
        J = I + 1
      Else
        Insert("^" & Chr$(64 + C))
      Endif
      
    Endif
    
  Next

  If I > J Then Insert(Mid$(Text, J, I - J))
  
  $bOverwrite = bSaveOverwrite  
  $bPrint = False
  $hDoc.EnableUndo
  
End


'       else if (c == 27)
'       {
'         i++;
'         i += ansi_process(THIS, &str[i], len - i);
'         j = i + 1;
'         i--;
'       }
'       else
'       {
'         QString tmp;
'         tmp.sprintf("^%c", c + 64);
'         print_text(THIS, tmp, 2, true);
'       }
'     }
'   }
' 
'   if (i > j)
'     print_text(THIS, &str[j], i - j);
' 
'   DOC->end();
'     
' END_METHOD
' 

Public Sub FindNextString(Search As String, Start As Integer) As Integer
  
  Do
    If Start >= $hDoc.Count Then Return -1
    If String.InStr($hDoc.Lines[Start], Search, 1, gb.IgnoreCase) Then Return Start
    Inc Start
  Loop
  
End

Private Function ScrollX_Read() As Integer

  Return $hView.ScrollX

End

Private Sub ScrollX_Write(Value As Integer)

  $hView.ScrollX = Value

End

Private Function ScrollY_Read() As Integer

  Return $hView.ScrollY

End

Private Sub ScrollY_Write(Value As Integer)

  $hView.ScrollY = Value

End

Private Function ScrollWidth_Read() As Integer

  Return $hView.ScrollWidth

End

Private Function ScrollHeight_Read() As Integer

  Return $hView.ScrollHeight

End

Public Sub Scroll(X As Integer, Y As Integer)
  
  $hView.Scroll(X, Y)
  
End

Private Function ShowCursor_Read() As Boolean

  Return Not $bHideCursor

End

Private Sub ShowCursor_Write(Value As Boolean)

  $bHideCursor = Not Value
  Refresh

End

Public Sub Cut()
  
  If Not HasSelection() Then
    Goto(0, $Y)
    If $Y < $hDoc.Max Then
      Goto(0, $Y + 1, True)
    Else
      Goto(-1, $Y, True)
    Endif
  Endif
  Copy()
  DeleteSelection()
  
End

Public Sub Refresh()
  
  ClearCacheLine
  $hView.Refresh
  
End

Public Sub Reset()
  
  $hTimerChange = Null
  $hDoc.Reset
  
End

Public Sub _RaiseHighlight(sText As String)
  
  Raise Highlight(sText)
  
End

Public Sub _ViewToReal(Y As Integer) As Integer

  Dim I As Integer
  Dim M As Integer
  Dim J As Integer
  Dim YO As Integer
  
  If $aFold Then 
  
    Try Return $cCacheView[Y]
  
    M = $hDoc.Max
    YO = Y
    
    For I = 0 To $aFold.Max Step 2
      If Y <= $aFold[I] Then Break
      J = I + 1
      If $aFold[J] < M Then
        Y += $aFold[J] - $aFold[I]
      Else
        Y = M + 1
      Endif
    Next
    
    $cCacheView[YO] = Y
    
  Endif
  
  Return Y
  
End


Public Sub _RealToView(Y As Integer) As Integer

  Dim I As Integer
  Dim YY As Integer
  Dim J As Integer
  Dim YO As Integer
  
  If $aFold Then 
    
    Try Return $cCacheView[- Y]
  
    YO = Y
    YY = Y
  
    For I = 0 To $aFold.Max Step 2
      If Y < $aFold[I] Then Continue
      J = I + 1
      If Y <= $aFold[J] Then
        YY -= Y - $aFold[I]
      Else
        YY -= $aFold[J] - $aFold[I]
      Endif
    Next
    
    Y = YY
    $cCacheView[- YO] = Y
    
  Endif
  
  Return Y
  
End



' int GEditor::realToView(int row) const
' {
'   uint i;
'   GFoldedProc *fp;
'   int y;
'   
'   //fprintf(stderr, "realToView: %d -> ", row);
'   
'   y = row;
'   
'   for (i = 0; i < fold.count(); i++)
'   {
'     fp = fold.at(i);
'     if (row < fp->start)
'       continue;
'     if (row <= fp->end)
'       y -= row - fp->start;
'     else
'       y -= fp->end - fp->start;
'   }
'   
'   //fprintf(stderr, "%d\n", y);
'   
'   return y;
' }
' 

Private Sub UpdateCount()

  Dim Y As Integer
  'Dim X As Integer
  
  _ClearCachePos
  $hRows.Count = _RealToView($hDoc.Max) + 1
  
  Y = _ViewToReal(_RealToView($Y))
  'X = NormalizeColumn($X, Y)
  Goto($X, Y)
  
  $hView.Refresh

End

Public Sub _CheckRowWithFolding(Y As Integer) As Integer

  Dim NY As Integer
  Dim I As Integer

  If Not $aFold Then Return Y

  NY = Y
  For I = 0 To $aFold.Max Step 2
    If Y > $aFold[I] And If Y <= $aFold[I + 1] Then
      NY = $aFold[I]
      Break
    Endif
  Next
  
  Return NY

  ' int GEditor::checkCursor(int y)
  ' {
  '   uint i;
  '   GFoldedProc *fp;
  '   int ny;
  '   
  '   ny = y;
  '   for (i = 0; i < fold.count(); i++)
  '   {
  '     fp = fold.at(i);
  '     if (y > fp->start && y <= fp->end)
  '     {
  '       ny = fp->start;
  '       break;
  '     }
  '   }
  '   
  '   return ny;
  ' }
  ' 
  

End

Public Sub _CollapseRow(Y As Integer, Optional bNoRefresh As Boolean)

  Dim iStart As Integer
  Dim iEnd As Integer
  Dim iPos As Integer
  Dim I As Integer
  Dim NY As Integer
  
  If Not $hDoc.Info(Y).Limit Then
    Y = FindPreviousLimit(Y)
  Endif

' void GEditor::foldLine(int row, bool no_refresh)
' {
'   uint i;
'   int pos;
'   int start, end;
'   GFoldedProc *fp;
'   int ny;
'   
'   if (getFlag(NoFolding))
'     return;
'   
'   if (!doc->hasLimit(row))
'     row = doc->getPreviousLimit(row);
'   
  If Y < 0 Or If Y >= $hDoc.Count Then Return

'   if (row < 0 || row >= numLines())
'     return;
'   
'   //fprintf(stderr, "foldLine %d\n", row);
'   

  iStart = Y
  iEnd = FindNextLimit(iStart)
  If iEnd < 0 Then
    iEnd = $hDoc.Max
  Else
    Dec iEnd
  Endif

'   start = row;
'   end = doc->getNextLimit(row);
'   if (end < 0)
'     end = numLines() - 1;
'   else
'     end--;
'   /*else
'   {
'     while (end > start)
'     {
'       end--;
'       l = doc->lines.at(end);
'       //qDebug("[%d] state = %d %d", end, l->highlight ? l->highlight[0].state : -1, l->highlight ? l->highlight[0].len : -1);
'       if (!l->highlight || (l->highlight[0].state != GLine::Comment && l->highlight[0].state != GLine::Help))
'         break;
'     }
'   }*/
'   
  iPos = -1
  
  If Not $aFold Then $aFold = New Integer[]
  
  For I = 0 To $aFold.Max Step 2
    If iEnd >= $aFold[I] And If iStart <= $aFold[I + 1] Then Return
    If iPos < 0 And If iStart < $aFold[I] Then
      iPos = I
    Endif
  Next

'   pos = -1;
'   for (i = 0; i < fold.count(); i++)
'   {
'     fp = fold.at(i);
'     if (end >= fp->start && start <= fp->end)
'       return;
'     if (pos < 0 && start < fp->start)
'       pos = i;
'   }
'   

  If iPos < 0 Then
    $aFold.Add(iStart)
    $aFold.Add(iEnd)
  Else
    $aFold.Add(iStart, iPos)
    $aFold.Add(iEnd, iPos + 1)
  Endif

'   fp = new GFoldedProc;
'   fp->start = start;
'   fp->end = end;
'   
'   if (pos < 0)
'     fold.append(fp);
'   else
'     fold.insert(pos, fp);
'   
'   //dump_fold(fold);
'   

  NY = _CheckRowWithFolding(Y)
  If NY <> Y Then Goto($X, NY)

'   ny = checkCursor(y);
'   if (ny != y)
'     cursorGoto(ny, x, false);
'   

  If Not bNoRefresh Then 
    $cCacheView.Clear
    UpdateCount
  Endif

'   if (!no_refresh)
'   {
'     setNumRows(numLines());  
'     //redrawContents();
'   }
' }

End

Public Sub _ExpandRow(Y As Integer)

' 
' void GEditor::unfoldLine(int row)
' {
'   uint i;
'   GFoldedProc *fp;
' 
'   //fprintf(stderr, "unfoldLine %d\n", row);
'  
  Dim I As Integer

  For I = 0 To $aFold.Max Step 2
    If Y >= $aFold[I] And If Y <= $aFold[I + 1] Then
      $aFold.Remove(I, 2)
      $cCacheView.Clear
      UpdateCount
      Break
    Endif
  Next
  
 
'   for (i = 0; i < fold.count(); i++)
'   {
'     fp = fold.at(i);
'     if (row >= fp->start && row <= fp->end)
'     {
'       fold.remove(i);
'       //dump_fold(fold);
'       setNumRows(numLines());  
'       //redrawContents();
'       return;
'     }
'   }
'   
' }
' 
' 

End

Private Function ShowExpand_Read() As Boolean

  Return $bShowExpand

End

Private Sub ShowExpand_Write(Value As Boolean)

  If Not Value Then ExpandAll
  $bShowExpand = Value
  UpdateMargin

End

Public Sub _IsRowExpanded(Y As Integer) As Boolean

  Dim D As Integer
  Dim F As Integer
  Dim I As Integer

  If Not $aFold Then Return True

  D = 0
  F = $aFold.Count
  
  While F > D
    
    I = ((F + D) \ 4) * 2
    If $aFold[I] = Y Then Return 
    If $aFold[I] < Y Then
      D = I + 2
    Else
      F = I
    Endif
    
  Wend
  
  Return True

End

Fast Public Sub _IsRowVisible(Y As Integer) As Boolean
  
  Dim D As Integer
  Dim F As Integer
  Dim I As Integer

  If Not $aFold Then Return True

  D = 0
  F = $aFold.Count
  
  While F > D
    
    I = ((F + D) \ 4) * 2
    If $aFold[I] = Y Then Return True
    If $aFold[I] < Y Then
      If Y <= $aFold[I + 1] Then Return False
      D = I + 2
    Else
      F = I
    Endif
    
  Wend
  
  Return True

End

Public Sub _GetLastVisibleRow() As Integer

  Dim N As Integer
  
  N = $hDoc.Max
  If _IsRowVisible(N) Then Return N
  Return $aFold[$aFold.Max - 1]
  
End


Private Sub ToggleRow(Y As Integer)

  If _IsRowExpanded(Y) Then
    _CollapseRow(Y)
  Else
    _ExpandRow(Y)
  Endif

End

' bool GEditor::isFolded(int row)
' {
'   uint i;
'   GFoldedProc *fp;
'   int d, f;
'   
'   d = 0;
'   f = fold.count();
'   
'   while (f > d)
'   {
'     i = (f + d) / 2;
'     fp = fold.at(i);
'     if (fp->start == row)
'       return true;
'     else if (fp->start < row)
'       d = i + 1;
'     else
'       f = i;
'   }
'   
'   return false;
' }
' 
' 

Private Sub CheckFolded(Y As Integer) As Integer

  Dim I As Integer
  
  If Not $aFold Then Return Y

  For I = 0 To $aFold.Max Step 2
    If Y <= $aFold[I + 1] Then
      If Y > $aFold[I] Then Return $aFold[I]
      Break
    Endif
  Next
  
  Return Y

End

' int GEditor::checkFolded(int row)
' {
'   uint i;
'   GFoldedProc *fp;
'   
'   for (i = 0; i < fold.count(); i++)
'   {
'     fp = fold.at(i);
'     if (row <= fp->end)
'     {
'       if (row > fp->start)
'         return fp->start;
'       else
'         break;
'     }
'   }
'   
'   return row;
' }
' 

Public Sub CollapseAll()

  Dim Y As Integer
  
  Y = 0
  Do
    _CollapseRow(Y, True)
    Y = FindNextLimit(Y)
    If Y < 0 Then Break
  Loop

  $cCacheView.Clear
  UpdateCount
  EnsureVisible(True)
  
End


' void GEditor::foldAll()
' {
'   int row;
'   
'   if (getFlag(NoFolding))
'     return;
'   
'   row = 0;
'   for(;;)
'   {
'     foldLine(row, true);
'     row = doc->getNextLimit(row);
'     if (row < 0)
'       break;
'   }
'   
'   setNumRows(numLines());
'   //updateContents();
' }
' 

Public Sub ExpandAll()
  
  $aFold = Null
  UpdateCount
  $cCacheView.Clear
  EnsureVisible(True)
 
End


' void GEditor::unfoldAll()
' {
'   foldClear();
'   setNumRows(numLines());  
'   ensureCursorVisible();
'   //redrawContents();
' }
' 
' 

Private Sub _ExpandRemove(Y1 As Integer, Y2 As Integer)

  Dim N As Integer
  Dim I As Integer
  
  If Not $aFold Then Return
  
  If Y2 <= Y1 Then
    _ExpandRow(Y1)
    Return
  Endif

  N = Y2 - Y1

  While I < $aFold.Count
    If Y2 < $aFold[I] Then
      $aFold[I] -= N
      $aFold[I + 1] -= N
      I += 2
    Else If Y1 > $aFold[I + 1] Then
      I += 2
    Else
      $aFold.Remove(I, 2)
    Endif
  Wend
  
  $cCacheView.Clear

End

' void GEditor::foldRemove(int y1, int y2)
' {
'   uint i;
'   GFoldedProc *fp;
'   int n;
'   
'   if (getFlag(NoFolding))
'     return;
'   
'   if (y2 < 0)
'   {
'     unfoldLine(y1);
'     return;
'   }
'   
'   n = y2 - y1 + 1;
'   
'   for (i = 0; i < fold.count(); i++)
'   {
'     fp = fold.at(i);
'     if (y2 < fp->start)
'     {
'       fp->start -= n;
'       fp->end -= n;
'     }
'     else if (y1 > fp->end)
'       continue;
'     else
'     {
'       fold.remove(i);
'       i--;
'     }
'   }
' }
' 

Private Sub _ExpandInsert(Y As Integer, N As Integer)

  Dim I As Integer
  
  If Not $aFold Then Return

  If N = 0 Then
    _ExpandRow(Y)
    Return
  Endif
  
  While I < $aFold.Count
    If $aFold[I] > Y Then
      $aFold[I] += N
      $aFold[I + 1] += N
      I += 2
    Else If $aFold[I + 1] >= Y Then
      '$aFold[I + 1] += N
      $aFold.Remove(I, 2)
    Else
      I += 2
    Endif
  Wend
  
  $cCacheView.Clear

End
' 
' void GEditor::foldInsert(int y, int n)
' {
'   uint i;
'   GFoldedProc *fp;
'   
'   if (getFlag(NoFolding))
'     return;
'   
'   if (n == 0)
'   {
'     unfoldLine(y);
'     return;
'   }
'   
'   for (i = 0; i < fold.count(); i++)
'   {
'     fp = fold.at(i);
'     if (fp->start > y)
'     {
'       fp->start += n;
'       fp->end += n;
'     }
'     else if (fp->end >= y)
'     {
'       fp->end += n;
'       fold.remove(i); //unfoldLine(fp->start);
'       i--;
'     }
'   }
' }
' 
Private Sub MoveSelection(bUp As Boolean)

  Dim X, Y As Integer
  Dim X1, Y1, X2, Y2 As Integer
  Dim sText As String
  Dim bSelect As Boolean

  X = $X
  Y = $Y

  If Not HasSelection() Then
    X1 = 0
    Y1 = $Y
    If $Y < $hDoc.Max Then
      X2 = 0
      Y2 = $Y + 1
    Else
      X2 = $hDoc.LineLength[$Y]
      Y2 = $Y
    Endif
  Else
    bSelect = True
    GetSelection(ByRef X1, ByRef Y1, ByRef X2, ByRef Y2)
    X1 = 0
    If X2 > 0 And If Y2 < $hDoc.Max Then 
      Inc Y2
      X2 = 0
    Endif
  Endif
  
  If bUp Then
    If Y1 = 0 Then Return
  Else
    If Y2 = $hDoc.Max Then Return
  Endif
  
  Goto(X1, Y1)
  Goto(X2, Y2, True)

  $hDoc.Begin
  
  sText = $hDoc.GetText(X1, Y1, X2, Y2)
  Remove(X1, Y1, X2, Y2)
  If bUp Then
    Dec Y1
    Dec Y2
  Else
    Inc Y1
    Inc Y2
  Endif
  Goto(X1, Y1)
  Insert(sText)
  
  If bSelect Then
    Goto(X1, Y1)
    Goto(X2, Y2, True)
  Else  
    If bUp Then
      Goto(X, Y - 1)
    Else
      Goto(X, Y + 1)
    Endif
  Endif
  
  $hDoc.HighlightFrom($Y)
    
  $hDoc.End

End

Public Sub _SaveCursor()
  
  If $iSaveCursor = 0 Then $aSaveCursor = [$X, $Y, $SX, $SY]
  Inc $iSaveCursor
  
End

Public Sub _RestoreCursor()
  
  Dim X, Y, SX, SY As Integer
  
  Dec $iSaveCursor
  If $iSaveCursor Then Return
  
  X = $aSaveCursor[0]
  Y = $aSaveCursor[1]
  SX = $aSaveCursor[2]
  SY = $aSaveCursor[3]
  
  Goto(SX, SY)
  If X <> SX Or If Y <> SY Then Goto(X, Y, True)
  
End

Public Sub _UpdateLineHeight(Y As Integer)
  
  Dim sText As String
  Dim WMax As Integer
  Dim D, F, P As Integer
  Dim aLayout As Integer[]
  Dim W As Integer
  Dim L As Integer
  Dim S As Integer
  
  If Not $cLineLayout Then Return
  
  sText = $hDoc.Lines[Y]
  WMax = $hView.ClientW - $MW - 8
  
  'Print Y;
  
  aLayout = New Integer[]
  
  S = 1
  L = String.Len(sText)
  
  Do
    
    D = S
    F = L + 1
    
    While F > D + 1
      
      P = (D + F) \ 2
      W = TextWidth(String.Mid(sText, S, P - S + 1))
      If W > WMax Then
        F = P
      Else
        D = P
      Endif
    
    Wend
    
    If D >= L Then Break
    
    If String.Code(sText, D) > 32 Then
      ' For P = D - 1 DownTo S
      '   If InStr(" ,.;:-([])", String.Mid$(sText, P, 1)) Then 
      '     Inc P
      '     Break
      '   Endif
      ' Next
      P = String.RInStr(sText, " ", D - 1)
      If P >= S And If Trim(String.Mid(sText, S, P - S + 1)) Then D = P
    Endif
    
    If aLayout.Count = 0 Then WMax -= LineStartPos(Y)
    aLayout.Add(D - S + 1)
    S = D + 1
    
    'sText = String.Mid$(sText, D + 1)
    'If Not sText Then Break
    
  Loop
  
  If aLayout.Count >= 1 Then
    $cLineLayout[Y] = aLayout
    $hRows._SetRowHeight(Y, aLayout.Count + 1)
    ' Print " -> [ "; 
    ' For D = 0 To aLayout.Max
    '   Print aLayout[D];;
    ' Next
    ' Print "]"
  Else
    $cLineLayout[Y] = Null
    $hRows._SetRowHeight(Y, 1)
    'Print
  Endif
  
  If Y = $Y Then $XY = LinePos($Y, $X)
  If Y = $SY Then $SXY = LinePos($Y, $X)
  
  Try $cCachePos.Remove(Y)
  
End

Public Sub _UpdateAllHeight(Optional bNow As Boolean)

  Dim TY As Integer
  
  If Not $bUpdateHeightAllowed Then Return
  
  If Not $cLineLayout Then 

    TY = $hRows._GetRowY($Y) - $hView.ScrollY
    $hRows.Clear
    _ClearCachePos
    $XY = LinePos($Y, $X)
    $SXY = LinePos($SY, $SX)
    $hView.ScrollY = $hRows._GetRowY($Y) - TY
    Return
    
  Endif
  
  If Not $hTimerHeight Then
    $hTimerHeight = New Timer As "TimerHeight"
    $hTimerHeight.Delay = 50
  Endif
  
  If bNow Then
    '$hTimerHeight.Trigger
    TimerHeight_Timer
  Else
    $hTimerHeight.Start
  Endif
  
End

Public Sub TimerHeight_Timer()
  
  Dim Y As Integer
  Dim CY, TY As Integer

  'Debug Me.Window.Title;; $iWidth;; $hView.ClientW
  
  Y = $hRows._GetRowY($Y)
  If Y < $hView.ScrollY Then
    TY = 0
    CY = PosToLine(TY)
  Else If Y + $LH >= $hView.ScrollY + $hView.ClientH Then
    TY = $hView.ClientH
    CY = PosToLine(TY)
  Else
    TY = Y - $hView.ScrollY
    CY = $Y
  Endif
  
  If $hDoc.Count >= 10000 Then Inc Application.Busy
  
  $bNoResizeContents = True
  For Y = 0 To $hDoc.Max
    _UpdateLineHeight(Y)
  Next
  $bNoResizeContents = False
  _ClearCachePos
  _ResizeContents
  
  $hView.ScrollY = $hRows._GetRowY(CY) - TY
  
  'EnsureVisible
  $hView.Refresh
  
  $XY = LinePos($Y, $X)
  $SXY = LinePos($SY, $SX)
    
  If $hTimerHeight Then
    $hTimerHeight.Stop
    $hTimerHeight = Null
  Endif
  
  If $hDoc.Count >= 10000 Then Dec Application.Busy
  
End

Private Function Wrap_Read() As Boolean

  Return $cLineLayout

End

Private Sub Wrap_Write(Value As Boolean)

  If Value Then
    If $cLineLayout Then Return
    $cLineLayout = New Collection
  Else
    If Not $cLineLayout Then Return
    $cLineLayout = Null
  Endif

  _UpdateAllHeight(True)
  CalcSizes
  EnsureVisible

End

' Public Sub Test()
' 
'   Dim Y As Integer
'   Dim RY As Integer
'   Dim ORY As Integer = -1
'   
'   For Y = 0 To 2500
'     RY = $hRows._GetRowY(Y)
'     If _IsRowVisible(Y) Then
'       Print Y; ": "; RY / $LH
'       'ORY = RY
'     Endif
'   Next
'   
' End

Public Sub _GetRowHeight(Y As Integer) As Integer
  
  Return $hRows._GetRowHeight(Y)
  
End

' Public Sub _Lock()
'   
'   Inc $iLock
'   
' End
' 
' Public Sub _Unlock()
'   
'   Dec $iLock
'   If $iLock = 0 Then
'     
'   Endif
'   
' End
' 
Public Sub Styles_Change()
  
  $bStyleChanged = True
  ClearCacheText
  
End

Private Function ShowSpaces_Read() As Boolean

  Return $bShowSpaces

End

Private Sub ShowSpaces_Write(Value As Boolean)

  $bShowSpaces = Value
  $hView.Refresh

End

' void GEditor::clearLine(bool before, bool after)
' {
'   int ox = x;
' 
'   doc->begin();
' 
'   if (before)
'   {
'     QString ins;
' 
'     doc->remove(y, 0, y, x + 1);
'     ins.fill(' ', ox + 1);
'     doc->insert(y, 0, ins);
'     x = ox;
'   }
' 
'   if (after)
'   {
'     doc->remove(y, x, y, doc->lineLength(y) -1);
'   }
' 
'   doc->end();
' }
' 
' 

Private Sub ClearLine(bBefore As Boolean, bAfter As Boolean)

  Dim OX As Integer

  OX = $X

  $hDoc.Begin()
  
  If bBefore Then
    $hDoc.Remove(0, $Y, $X + 1, 0)
    $hDoc.Insert(Space$(OX + 1), 0, $Y)
    $X = OX
  Endif
  
  If bAfter Then
    $hDoc.Remove($X, $Y, $hDoc.LineLength[$Y], $Y)
  Endif
  
  $hDoc.End()

End

Private Sub RelGoto(DX As Integer, DY As Integer)
  
  Goto(Max(0, $X + DX), Max(0, $Y + DY))
  
End

Public Sub TimerCacheLine_Timer()
  
  ClearCacheLine
  $hTimerCacheLine.Stop
  
End

Private Sub ClearCacheLine()

  If $bRemoteDisplay Then Return
  $cCacheLine.Clear
  $iCacheLineH = 0

End

Private Sub ClearCacheText()

  If $bRemoteDisplay Then Return
  $cCacheText.Clear

End
