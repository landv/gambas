' Gambas class file

Export

Inherits UserControl

Public Const _Properties As String = "*,Border=True,ShowPreview,ScrollBar{Scroll.*}=Both,Highlight{None;Custom;Gambas;HTML;CSS;WebPage;Diff;JavaScript;SQL}=None,Mode{None;Gambas;HTML;CSS;WebPage;JavaScript;SQL}=None,ReadOnly,TabSize{Range:2;64}=2,TabIndent,Wrap,ShowPosition,ShowLimit,ShowCurrent,ShowLineNumber,ShowModified,ShowBraces,ShowIcon,ShowExpand,ShowCursor=True,ShowSpaces,ShowIndent,CloseBraces,CloseStrings"
Public Const _DrawWith As String = "-"
Public Const _DefaultEvent As String = "Change"
Public Const _Similar As String = "TextArea"

Event Cursor
Event Scroll
Event Change
Event Margin
Event KeyPress
Event Highlight(Text As String)

Property Text As String
Property Read Count As Integer
Property Read Line As Integer
Property Read Column As Integer
Property Read SelectionLine As Integer
Property Read SelectionColumn As Integer
Property Read LastLine As Integer
Property Read LastColumn As Integer
Property Read Selected As Boolean
Property Read SelectedText As String
Property ReadOnly As Boolean
Property ShowPreview As Boolean
Property Mode As String
Property Highlight As String
Property LineNumberOffset As Integer
Property TabSize As Integer
Property TabIndent As Boolean
Property Read Length As Integer
Property Border As Boolean
Property ScrollBar As Integer
Property Overwrite As Boolean
Property Read LineHeight As Integer
Property Read Current As _TextEditor_Line
Property Font As Font
Property StopLine As Integer
Property EndOfLine As Integer
Property Breakpoints As Integer[]
Property DisabledBreakpoints As Integer[]
Property Bookmarks As Integer[]
Property Read Styles As _TextEditor_Styles
Property View As TextEditor
Property Read Keywords As String[]
Property Wrap As Boolean

Property ScrollX As Integer
Property ScrollY As Integer
Property Read ScrollWidth, ScrollW As Integer
Property Read ScrollHeight, ScrollH As Integer

Property ShowLimit As Boolean
Property ShowCurrent As Boolean
Property ShowLineNumber As Boolean
Property ShowModified As Boolean
Property ShowPosition As Boolean
Property ShowIcon As Boolean
Property ShowBraces As Boolean
Property ShowCursor As Boolean
Property ShowExpand As Boolean
Property ShowSpaces As Boolean
Property ShowIndent As Boolean
Property CloseBraces As Boolean
Property CloseStrings As Boolean

Private Const MATCH_STRING As String = "()[]{}"

Static Private $cShortcut As Collection
Static Private $bRemoteDisplayChecked As Boolean
Static Private $bRemoteDisplay As Boolean

Public _Views As TextEditor[]

Private $hPanel As Panel
Private $hView As ScrollArea
Private $hSideBar As DrawingArea
Private $hImageSideBar As Image
Private $hLabelFrame As Panel
Private $hLabel As Label

Private $hDoc As CDocument
Private $hRows As _TextEditor_Rows

Private $hStyles As _TextEditor_Styles
Private $bStyleChanged As Boolean

Private $iLargestLine As Integer
Private $iWidth As Integer
Private $LH As Integer
Private $BW As Integer ' bold width
Private $MW As Integer
Private $iWidthLineNumber As Integer
Private $iWidthModified As Integer
Private $iPosIcon As Integer

Private $iTabSize As Integer = 2
Private $iTabWidth As Integer
Private $fTabSymbolSize As Float
Private $iSpaceWidth As Integer
Private $bTabIndent As Boolean

Private $X As Integer
Private $X0 As Integer
Private $Y As Integer
Private $XY As Point
Private $bShowCursor As Boolean
Private $bHideCursor As Boolean
Private $LX As Integer
Private $LY As Integer

Private $hTimerCursor As Timer
Private $hTimerChange As Timer
Private $hTimerEnsureVisible As Timer

Private $SX As Integer
Private $SY As Integer
Private $SXY As Point
Private $bMouseDown As Boolean

Private $hTimerScroll As Timer

Private $XM As Integer
Private $YM As Integer = -1
Private $XMO As Integer
Private $YMO As Integer

Private $IY1 As Integer
Private $IY2 As Integer
Private $IP As Integer

Private $bReadOnly As Boolean
Private $bOverwrite As Boolean
'Private $bTerminal As Boolean

Private $iBackground As Integer
Private $iForeground As Integer
Private $iSelectedBackground As Integer
Private $iLimitColor As Integer
Private $iIndentColor As Integer
Private $iMatchColor As Integer

Private $iLineNumberOffset As Integer
Private $hTabImage As Image
Private $hFont As Font
'Private $hFontBold As Font
Private $iAscent As Integer

Private $fCharWidth As Float
Private $cCachePos As New Collection
Private $cCacheView As New Collection

Private $iStopLine As Integer = -1

Private $bShowLimit As Boolean
Private $bShowCurrent As Boolean
Private $bShowLineNumber As Boolean
Private $bShowModified As Boolean
Private $bShowPosition As Boolean
Private $bShowIcon As Boolean
Private $bShowBraces As Boolean
Private $bShowExpand As Boolean
Private $bShowSpaces As Boolean
Private $bShowIndent As Boolean

Private $bFirstFocus As Boolean

Private $aFold As Integer[]

Private $iSaveCursor As Integer
Private $aSaveCursor As Integer[]
Private $hFontNumber As Font

Private $cLineLayout As Collection
Private $hTimerHeight As Timer
Private $bNoResizeContents As Boolean

Static Private $cGlobalCacheText As New Collection
Private $cCacheText As Collection
Private $sCacheTextKey As String

Private $cCacheLine As New Collection
Private $iLastScrollX As Integer
Private $hTimerCacheLine As Timer
Private $iCacheLineH As Integer

Private $bUpdateHeightAllowed As Boolean

Private $bPrint As Boolean
Private $sPrintBuffer As String
Private $iMarginColor As Integer

Private $hTimerSideBarMouse As Timer
Private $hTimerSideBarRefresh As Timer
Private $rectSideBar As Rect
Private $fBarLineHeight As Float
Private $bShowPreview As Float
Private $hSideBarViewer As TextEditor

'Private $hTimerSideBarViewer As Timer
Private $iScrollBar As Integer
Private $iMD As Integer
Private $iMY As Integer = -1
Private $bSideBarLockViewer As Boolean
Private $iSideBarWhere As Integer
Private $iSideBarClick As Integer
Private Enum SIDEBAR_NONE, SIDEBAR_VIEW, SIDEBAR_UP, SIDEBAR_DOWN

Private $sHighlightString As String
Private $iHighlightStringMode As Integer
Private $iHighlightStringLen As Integer
Private $bHighlightWordOnly As Boolean

Public Sub _new()
  
  Dim sDisplay As String
  
  If Not $cShortcut Then
    $cShortcut = [
      "CTRL+A": "SelectAll",
      "CTRL+C": "Copy",
      "CTRL+INS": "Copy",
      "CTRL+V": "Paste",
      "SHIFT+INS": "Paste",
      "CTRL+X": "Cut",
      "SHIFT+DEL": "Cut",
      "CTRL+Y": "Redo",
      "CTRL+Z": "Undo"]
  Endif
  
  If Not $bRemoteDisplayChecked Then
    If Env["XDG_SESSION_TYPE"] <> "wayland" Then
      sDisplay = Env["DISPLAY"]
      If sDisplay And If Left(sDisplay) <> ":" Then $bRemoteDisplay = True
    Endif
    $bRemoteDisplayChecked = True
  Endif
  
  $hPanel = New Panel(Me) As "ViewPanel"
  $hPanel.Arrangement = Arrange.Horizontal
  $hPanel.Border = Border.Plain
  
  $hView = New ScrollArea($hPanel) As "View"
  $hView.Border = False
  $hView.Focus = True
  $hView.Tracking = True
  $hView.Mouse = Mouse.Text
  $hView.Expand = True
  
  Me.Proxy = $hView
  $iScrollBar = $hView.ScrollBar
  $hTimerCursor = New Timer As "TimerCursor"
  $hTimerCursor.Delay = 500
  
  $hTimerCacheLine = New Timer As "TimerCacheLine"
  $hTimerCacheLine.Delay = 5000
  
  $hRows = New _TextEditor_Rows As "Rows"
  $hStyles = New _TextEditor_Styles As "Styles"
  
  '$hPanel.Background = $hStyles[Highlight.Background].Color
  
  _SetDocument(Null)
  
End

Private Function Text_Read() As String
  
  Return $hDoc.Text
  
End

Private Sub CalcSizes()
  
  Dim hParent As Control
  
  $hFont = $hView.Font
  
  '$hFontBold = $hView.Font.Copy()
  '$hFontBold.Bold = True
  
  $LH = $hFont.Height + 1
  $BW = 1 + $LH \ 6
  $hRows.Height = $LH
  
  hParent = Me
  Do
    hParent = hParent.Parent
    If Not hParent Is TextEditor Then 
      $hFontNumber = hParent.Font.Copy()
      Break
    Endif
  Loop
  
  $hFontNumber.Size *= $LH / $hFontNumber.Height
  
  $iAscent = $hFont.Ascent
  $iLargestLine = -1
  $iSpaceWidth = $hFont.TextWidth(" ")
  $iTabWidth = $hFont.TextWidth("m") * $iTabSize
  $fTabSymbolSize = Max(1, $hRows.H / 5)
  $hTabImage = Null
  
  $fCharWidth = Paint._EstimateFixedFontCharWidth($hFont)
  ' $fCharWidth = $iSpaceWidth
  ' For I = 33 To 255
  '   If I > 126 And If I < 160 Then Continue
  '   If I = 173 Then Continue
  '   If $hFont.TextWidth(String.Chr$(I)) <> $iSpaceWidth Then
  '     $fCharWidth = 0
  '     Break
  '   Endif
  ' Next
  ' 
  ' If $fCharWidth Then
  '   sText = String$(4, "AbCdEfGh01#@WwmM")
  '   $fCharWidth = $hFont.TextWidth(sText) / Len(sText)
  ' Endif
  
  If Not $bRemoteDisplay Then
    $sCacheTextKey = $hFont.ToString()
    $cCacheText = $cGlobalCacheText[$sCacheTextKey]
    If Not $cCacheText Then
      $cCacheText = New Collection
      $cGlobalCacheText[$sCacheTextKey] = $cCacheText
    Endif
  Endif
  
  _ClearCachePos
  UpdateMargin
  UpdateWidth
  
  Refresh
  
End

Private Sub Init()
  
  $bStyleChanged = True
  $X = 0
  $Y = 0
  $XY = New Point
  $X0 = 0
  $SX = 0
  $SY = 0
  $SXY = New Point
  $YM = -1
  
  $hRows.Clear
  $hRows.Count = $hDoc.Count
  
  CalcSizes
  
  $cCachePos.Clear
  $cCacheView.Clear
  
  If Not $bRemoteDisplay Then
    ClearCacheText
    ClearCacheLine
  Endif
  
  $bShowCursor = True
  GotoCenter(0, 0)
  
  Refresh
  
End

Private Sub Text_Write(Value As String)
  
  $hDoc.Text = Value
  Init
  If $bShowPreview Then $hTimerSideBarRefresh.Trigger
  
End

Public Sub Load(Path As String, Optional AddNewLine As Boolean)
  
  Inc Application.Busy
  Goto(0, 0)
  $hDoc.Load(Path, AddNewLine)
  Init
  If $bShowPreview Then $hTimerSideBarRefresh.Trigger
  Dec Application.Busy

Catch
  
  Dec Application.Busy
  Error.Propagate
  
End

Public Sub Save(Path As String)
  
  Inc Application.Busy
  $hDoc.HighlightFrom($Y)
  $hDoc.Save(Path)
  $hTimerChange = Null
  Dec Application.Busy
  
Catch
  
  Dec Application.Busy
  Error.Propagate
  
End

Public Sub Clear()
  
  Me.Text = ""
  
End

Private Sub UpdateMargin()
  
  Dim MW As Integer
  
  MW = 0
  $iWidthLineNumber = 0
  $iPosIcon = 0
  
  If $bShowLineNumber Then
    $iWidthLineNumber = (CInt(Log10($hDoc.Count + $iLineNumberOffset)) + 1) * Me.Parent.Font.TextWidth("9") * $LH / Me.Parent.Font.Height + 8
    MW += $iWidthLineNumber
  Endif
  If $bShowIcon Or If $bShowExpand And Len($hDoc.Highlight) > 0 Then
    $iPosIcon = MW
    MW += $LH
  Endif
  If $bShowModified Then
    $iWidthModified = $hFont.H \ 2
    MW += $iWidthModified
  Endif
  
  If MW <> $MW Then
    $MW = MW
    '$hView._SetShadowOffset(0, 0, $MW - $iWidthModified, 0)
    If $cLineLayout Then
      _UpdateAllHeight
      UpdateWidth
    Endif
  Endif
  
End

Public Sub View_Font()
  
  CalcSizes
  UpdateSideBarFont
  
End

Private Sub HasSelection() As Boolean
  
  If $X <> $SX Or If $Y <> $SY Then Return True
  
End

Private Sub DrawText(sText As String, SX As Integer, X As Integer, Y As Integer)
  
  Dim iTab, iTab2, iLen As Integer
  Dim YT As Integer
  Dim XX, YY As Float
  
  YT = Y + $iAscent
  
  Do
    
    iTab2 = InStr(sText, "\t", iTab + 1)
    If iTab2 = 0 Then
      Paint.DrawText(Mid$(sText, iTab + 1), X, YT)
      Return
    Endif
    
    iLen = iTab2 - iTab - 1
    If iLen > 0 Then
      Paint.DrawText(Mid$(sText, iTab + 1, iLen), X, YT)
      X += $hFont.TextWidth(Mid$(sText, iTab + 1, iTab2 - iTab - 1))
    Endif
    
    If Not $hTabImage Then
      
      $hTabImage = New Image($fTabSymbolSize * 2.5, $hFont.Height, Color.Transparent)
      Paint.Begin($hTabImage)
      
      XX = $hTabImage.W / 2
      YY = $hTabImage.H / 2
      
      Paint.LineWidth = $fTabSymbolSize / 4
      Paint.Background = Color.SetAlpha(Color.TextForeground, 192)
      Paint.MoveTo(XX - $fTabSymbolSize, YY - $fTabSymbolSize)
      Paint.LineTo(XX, YY)
      Paint.LineTo(XX - $fTabSymbolSize, YY + $fTabSymbolSize)
      Paint.MoveTo(XX, YY - $fTabSymbolSize)
      Paint.LineTo(XX + $fTabSymbolSize, YY)
      Paint.LineTo(XX, YY + $fTabSymbolSize)
      Paint.Stroke
      
      Paint.End
      
    Endif
    
    Paint.DrawImage($hTabImage, X, Y)
    
    X = SX + (((X - SX) + $iTabWidth) \ $iTabWidth) * $iTabWidth
    iTab = iTab2
    
  Loop
  
End

Private Sub DrawMatch(X As Integer, Y As Integer, H As Integer, XM As Integer, YM As Integer)
  
  'Dim sCar As String
  Dim XY As Point
  Dim WW As Integer
  
  XY = LinePos(YM, XM)
  WW = TextWidth($hDoc.Lines[YM], XM + 1, 1)
  Paint.FillRect(X + XY.X, Y + XY.Y + H - 1, WW, 1, $iForeground)
  
End

' Public Sub PrintCache()
'
'   Dim hImage As Image
'   Dim iSize As Integer
'   Dim cCache As Collection
'
'   For Each cCache In $cGlobalCacheText
'     For Each hImage In cCache
'       iSize += hImage.W * hImage.H
'       'Debug Mid$($cCacheText.Key, 2)
'     Next
'   Next
'   Debug iSize
'
' End
'

Private Sub DrawHighlightedText(Row As Integer, sText As String, aColor As Byte[], X As Integer, Y As Integer, H As Integer, aLayout As Integer[], iNextState As Integer)
  
  Dim I As Integer
  Dim hStyle As TextEditorStyle
  Dim bAlt As Boolean
  Dim iLen As Integer
  Dim P As Integer
  Dim sStr As String
  Dim X2 As Integer
  Dim iState As Integer
  Dim XMin As Integer
  Dim XMax As Integer
  Dim aStyle As TextEditorStyle[]
  Dim hImage As Image
  
  Dim XX, YY, XB, LB As Integer
  Dim hPos As Point
  Dim iNextBreak As Integer
  Dim iLayout As Integer
  Dim iRest As Integer
  Dim bBreak As Boolean
  Dim sKey As String
  Dim W As Integer
  Dim iLayoutCount As Integer
  Dim iCol As Integer
  Dim iBg As Integer
  
  'Dim hTemp As Image
  
  XMin = X + $hView.ScrollX
  XMax = XMin + $hView.ClientW
  aStyle = $hStyles._GetStyles()
  iBg = aStyle[iNextState].Background
  
  XX = X
  YY = Y
  
  If aLayout Then
    iLayoutCount = aLayout.Count
    iNextBreak = aLayout[0]
  Else
    iLayoutCount = 0
     ' Always greater than String.Len(), and faster
     ' Add a big number in the case of an incorrect highlighting
    iNextBreak = Len(sText) + 1000000
  Endif
  
  For I = 0 To aColor.Max Step 2
    
    If Not aLayout Then
      If XX > XMax Then Break
    Endif
    
    iState = aColor[I] And 31
    hStyle = aStyle[iState]
    bAlt = aColor[I] >= 128
    If iRest Then
      iLen = iRest
      iRest = 0
    Else
      iLen = aColor[I + 1]
    Endif
    
    If bBreak Then
      If iBg <> Color.Default Then Paint.FillRect(XX, YY, Paint.W, H, iBg)
      XX = X + LinePos(Row, P).X
      YY += H
      bBreak = False
    Endif
    
    If P + iLen >= iNextBreak Then
      
      bBreak = True
      
      iRest = P + iLen - iNextBreak
      iLen = iNextBreak - P
      
      Inc iLayout
      
      If iLayout < iLayoutCount Then
        iNextBreak += aLayout[iLayout]
      Else
        iNextBreak = Len(sText) + 1
      Endif
      
      If iRest Then I -= 2
      
      If iLen = 0 Then Goto NEXT_PATTERN
      
    Endif
    
    hPos = LinePos(Row, P + iLen)
    X2 = X + hPos.X 'LineWidth(Row, P + iLen)
    
    If Not aLayout Then
      If X2 < XMin Then Goto NEXT_PATTERN
    Endif
    
    iBg = hStyle.Background
    If iBg <> Color.Default Then Paint.FillRect(XX, YY, X2 - XX, H, iBg)
    If bAlt Then Paint.FillRect(XX, YY, X2 - XX, H, Color.SetAlpha(&HD0D0D0&, 192))
    
    sStr = String.Mid$(sText, P + 1, iLen)
    ' If hStyle.Bold Then
    '   hTemp = New Image(X2 - X, H, Color.Transparent)
    '   Paint.Begin(hTemp)
    '   Paint.Font = $hFont
    '   Paint.Translate(- X, - Y)
    ' Endif
    
    'If hStyle.Bold Then Paint.Font = $hFontBold
    If InStr(sStr, "\t") Then
      GoSub DRAW_TEXT_WITH_TAB
    Else If Trim(sStr) Then
      If Not $bRemoteDisplay And If iLen <= 16 Then
        sKey = Chr$(iState) & sStr
        hImage = $cCacheText[sKey]
        If Not hImage Then
          
          W = X2 - XX
          If W <= 0 Then W = TextWidth(sStr, 1, iLen)
          If hStyle.Bold Then W += ($BW + 1) \ 2
          hImage = New Image(W, H, Color.Transparent)
          
          Paint.Begin(hImage)
          Paint.Font = $hFont
          Paint.Translate(- XX, - YY)
          GoSub DRAW_TEXT
          Paint.End
          
          If $cCacheText.Count > 256 Then
            For Each $cCacheText
              $cCacheText.Remove($cCacheText.Key)
              Break
            Next
          Endif
          
        Else
          
          $cCacheText.Remove(sKey)
          
        Endif
        
        $cCacheText[sKey] = hImage
        Paint.DrawImage(hImage, XX, YY)
      Else
        GoSub DRAW_TEXT
      Endif
    Endif
    'If hStyle.Bold Then Paint.Font = $hFont
    
    ' If hStyle.Bold Then
    '   Paint.End
    '   'hTemp.Save("~/temp.png")
    '   Paint.DrawImage(hTemp, X, Y)
    '   Paint.DrawImage(hTemp, X + 1, Y)
    ' Endif
    
    If hStyle.Underline Then 
      Paint.FillRect(XX, YY + H - 1, X2 - XX, 1, Color.SetAlpha(hStyle.Color, 128))
    Else If hStyle.Dotted Then
      Paint.Background = Color.SetAlpha(hStyle.Color, 128)
      Paint.LineWidth = 1
      Paint.Dash = [1]
      Paint.MoveTo(XX, YY + H - 0.5)
      Paint.RelLineTo(X2 - XX, 0)
      Paint.Stroke
    Endif
    
    ' If $YM >= 0 Then
    '   If Row = $YMO And If $XMO >= P And If $XMO < (P + iLen) Then DrawMatch(SX, Y, H, $XMO, $YMO)
    '   If Row = $YM And If $XM >= P And If $XM < (P + iLen) Then DrawMatch(SX, Y, H, $XM, $YM)
    ' Endif
    
  NEXT_PATTERN:
    
    P += iLen
    XX = X2
    
  Next
  
  sStr = String.Mid$(sText, P + 1)
  If sStr And If XX <= XMax Then
    
    Paint.Background = $iForeground
    DrawText(sStr, X, XX, YY)
    
  Endif
  
  If iBg <> Color.Default Then Paint.FillRect(XX, YY, Paint.W, H, iBg)
  
  Return
  
DRAW_TEXT:
  
  iCol = hStyle.Color
  Paint.Background = iCol
  If hStyle.Bold Then
    LB = $BW
    XB = XX
    While LB >= 2
      Paint.DrawText(sStr, XB, YY + $iAscent) 'DrawText(sStr, SX, X + 1, Y)
      Inc XB
      LB -= 2
    Wend
    If LB Then
      Paint.Background = Color.SetAlpha(iCol, 128)
      Paint.DrawText(sStr, XB, YY + $iAscent) 'DrawText(sStr, SX, X + 1, Y)
    Endif
  Else
    Paint.DrawText(sStr, XX, YY + $iAscent) 'DrawText(sStr, SX, X, Y)
  Endif
  
  Return
  
DRAW_TEXT_WITH_TAB:

  iCol = hStyle.Color
  Paint.Background = iCol
  If hStyle.Bold Then
    LB = $BW
    XB = 0
    While LB >= 2
      'Paint.DrawText(sStr, XB, YY + $iAscent) 'DrawText(sStr, SX, X + 1, Y)
      DrawText(sStr, X + XB, XX + XB, YY)
      Inc XB
      LB -= 2
    Wend
    If LB Then
      Paint.Background = Color.SetAlpha(iCol, 128)
      'Paint.DrawText(sStr, XB, YY + $iAscent) 'DrawText(sStr, SX, X + 1, Y)
      DrawText(sStr, X + XB, XX + XB, YY)
    Endif
  Else
    'Paint.DrawText(sStr, XX, YY + $iAscent) 'DrawText(sStr, SX, X, Y)
    DrawText(sStr, X, XX, YY)
  Endif

  ' If hStyle.Bold Then
  '   'Paint.Background = Color.Gradient(iCol, $iBackground)
  '   DrawText(sStr, X, XX + 1, YY)
  ' Endif
  ' 'Paint.Background = iCol
  ' DrawText(sStr, X, XX, YY)
  Return
  
End

Private Sub GetTabSizeAround(Row As Integer) As Integer
  
  Dim iBefore As Integer
  Dim Y As Integer
  Dim iAfter As Integer
  
  Y = Row
  While Y > 0
    Dec Y
    iBefore = GetLineIndent(Y, True)
    If iBefore >= 0 Then Break
  Wend
  
  Y = Row
  Do
    Inc Y
    If Y >= $hDoc.Count Then Break
    iAfter = GetLineIndent(Y, True)
    If iAfter >= 0 Then Break
  Loop
  
  If iBefore = iAfter Then Return iAfter - 1
  Return Min(iBefore, iAfter)
  
End

Private Sub DrawLine(X As Integer, Y As Integer, Width As Integer, Height As Integer, Row As Integer)
  
  Dim X1 As Integer
  Dim Y1 As Integer
  Dim X2 As Integer
  Dim Y2 As Integer
  Dim iCol As Integer
  Dim hInfo As CLineInfo
  Dim WC As Integer
  Dim sCar As String
  Dim aLayout As Integer[]
  Dim I As Integer
  Dim P, L As Integer
  Dim D As Float
  Dim sText As String
  Dim YY As Integer
  Dim H As Integer
  Dim XY1X As Integer
  Dim XY2X As Integer
  Dim XY1Y As Integer
  Dim XY2Y As Integer
  Dim XS As Integer
  Dim XX As Integer
  Dim hPos As Point
  Dim iEndingSpaceLimit As Integer
  Dim XP, IP As Integer
  Dim XY As Point
  
  'Debug Row
  H = $LH
  
  ' Current line or stop line
  
  Try aLayout = $cLineLayout[Row]
  If Row = $Y And If aLayout Then
    Paint.FillRect(X, Y, Width, Height, $iMarginColor)
  Endif
  
  If Row = $iStopLine Then
    Paint.FillRect(X, Y, Width, Height, $hStyles[Highlight.Current].Color)
  Else If $bShowCurrent And If Row = $Y Then
    Paint.FillRect(X, Y + $XY.Y, Width, H, $hStyles[Highlight.CurrentLine].Color)
  Endif
  
  hInfo = $hDoc.Info(Row)
  
  Paint.Rectangle($MW, Y, Width - $MW, Height)
  Paint.Clip
  
  Paint.Translate($MW, 0)
  
  sText = $hDoc.Lines[Row]
  
  ' Highlighted string
  
  If $sHighlightString Then
    
    P = 0
    L = $hDoc.LineLength[Row]
    
    Do
      
      P = String.InStr(sText, $sHighlightString, P + 1, $iHighlightStringMode)
      If P = 0 Then Break
      
      If $bHighlightWordOnly Then
        If P > 1 And If Not IsWordLimit(String.Mid$(sText, P - 1, 1)) Then Goto NEXT_SEARCH
        If (P + $iHighlightStringLen) < L And If Not IsWordLimit(String.Mid$(sText, P + $iHighlightStringLen, 1)) Then Goto NEXT_SEARCH
      Endif
      
      XY = LinePos(Row, P - 1)
      Paint.FillRect(X + XY.X, Y + XY.Y, TextWidth(sText, P, $iHighlightStringLen), H, $iMatchColor)
      
    NEXT_SEARCH:
    
      P += $iHighlightStringLen
      
    Loop
    
  Endif
  
  ' Selection
  
  If HasSelection() Then
    
    X1 = $X
    Y1 = $Y
    XY1X = $XY.X
    XY1Y = $XY.Y
    
    X2 = $SX
    Y2 = $SY
    XY2X = $SXY.X
    XY2Y = $SXY.Y
    
    If Y1 > Y2 Or If Y1 = Y2 And X1 > X2 Then
      Swap X1, X2
      Swap Y1, Y2
      Swap XY1X, XY2X
      Swap XY1Y, XY2Y
    Endif
    
    If Row >= Y1 And If Row <= Y2 Then
      
      iCol = Color.SetAlpha($iSelectedBackground, 32)
      
      ' If Y1 = Y2 Then
      '   Paint.FillRect(X + X1X, Y, X2X - X1X, Height, iCol)
      ' Else If Row = Y1 Then
      '   Paint.FillRect(X + X1X, Y, Width - X1X, Height, iCol)
      ' Else If Row = Y2 Then
      '   Paint.FillRect(X, Y, X2X, Height, iCol)
      ' Else
      '   Paint.FillRect(X, Y, Width, Height, iCol)
      ' Endif
      
      If Y1 < Row Then
        XY1X = 0
        XY1Y = 0
      Endif
      
      If Y2 > Row Then
        XY2X = 0
        XY2Y = Height
      Endif
      
      If XY2Y = XY1Y Then
        Paint.FillRect(X + XY1X, Y + XY1Y, XY2X - XY1X, H, iCol)
      Else
        Paint.FillRect(X + XY1X, Y + XY1Y, Width, H, iCol)
        Paint.FillRect(X, Y + XY1Y + H, Width, XY2Y - XY1Y - H, iCol)
        If XY2Y < Height Then Paint.FillRect(X, Y + XY2Y, XY2X, H, iCol)
      Endif
      
    Endif
    
  Endif
  
  ' Matching characters
  
  If $YM >= 0 Then
    If Row = $YMO Then DrawMatch(X, Y, H, $XMO, $YMO)
    If Row = $YM Then DrawMatch(X, Y, H, $XM, $YM)
  Endif
  
  ' Text
  
  If hInfo.Colors Then
    
    DrawHighlightedText(Row, sText, hInfo.Colors, X, Y, H, aLayout, hInfo.State)
    
  Else
    
    Paint.Background = $iForeground
    
    If aLayout Then
      
      P = 1
      YY = Y
      XX = X
      XS = X + LineStartPos(Row)
      For I = 0 To aLayout.Max
        DrawText(String.Mid$(sText, P, aLayout[I]), X, XX, YY)
        YY += H
        XX = XS
        P += aLayout[I]
      Next
      DrawText(String.Mid$(sText, P), X, XX, YY)
      
    Else
      
      DrawText(sText, X, X, Y)
      
    Endif
    
  Endif
  
  ' Indent vertical lines
  
  If $bShowIndent Then
    
    P = GetLineIndentMark(Row, sText)
    D = $iSpaceWidth / 4
    If $IP And If Row >= $IY1 And If Row <= $IY2 Then IP = X + $IP
    
    Paint.Translate($iSpaceWidth \ 2, 0)
    
    XP = 0
    Do
      
      If $bTabIndent Then
        Inc XP
        XX = X + XP * $iTabWidth
      Else
        XP += $iTabSize
        If $fCharWidth Then
          XX = X + CInt($fCharWidth * XP)
        Else
          XX = X + $hFont.TextWidth(String$(XP, " "))
        Endif
      Endif
      
      If XX >= P Then Break
      
      If IP And If XX = IP Then
        IP = 0
        Paint.Rectangle(XX, Y, D, Height)
        Paint.Background = Color.SetAlpha($iMatchColor, 64)
        Paint.Fill
        'Paint.FillRect(XX + D, Y, D, Height, $iMatchColor)
      Else
        Paint.Rectangle(XX, Y, D / 2, Height)
        Paint.Background = $iIndentColor
        Paint.Fill
      Endif
      iEndingSpaceLimit = XX
      
    Loop
    
    Paint.Translate(- $iSpaceWidth \ 2, 0)
    
    ' If IP Then
    '   If Row = $IY1 Then
    '     Paint.FillRect(IP - D * 3, Y + H \ 2, D, Height - H \ 2, $iMatchColor)
    '     Paint.FillRect(IP - D * 3, Y + H \ 2, D * 2, D, $iMatchColor)
    '   Else If Row = $IY2 Then
    '     Paint.FillRect(IP - D * 3, Y, D, Height - H \ 2, $iMatchColor)
    '     Paint.FillRect(IP - D * 3, Y + Height - H \ 2 - D, D * 2, D, $iMatchColor)
    '   Endif
    ' Endif
    
  Endif
  
  ' Ending spaces
  
  If $bShowSpaces And If sText Ends " " Then
    
    XX = X + $iSpaceWidth \ 2 - 1
    YY = Y + H \ 2 - 1
    For P = String.Len(sText) DownTo 1
      If String.Mid$(sText, P, 1) <> " " Then Break
      hPos = LinePos(Row, P - 1)
      If (XX + hPos.X) <= iEndingSpaceLimit Then Break
      Paint.FillRect(XX + hPos.X, YY + hPos.Y, 2, 2, $iLimitColor)
    Next
    
  Endif
  
  ' Cursor
  
  If Row = $Y And If $bShowCursor And If Me.HasFocus And If Not $bHideCursor Then
    If $bOverwrite Then
      sCar = String.Mid$($hDoc.Lines[$Y], $X + 1, 1)
      If sCar = "\t" Then
        WC = $iTabWidth
      Else
        WC = Max($iSpaceWidth, $hFont.TextWidth(sCar))
      Endif
    Else
      WC = 2
    Endif
    Paint.FillRect(X + $XY.X, Y + $XY.Y, WC, H, Color.SetAlpha($iForeground, 128))
  Endif
  
End

Private Sub DrawMargin(X As Integer, Y As Integer, Width As Integer, Height As Integer, Row As Integer)
  
  Dim iCol As Integer
  Dim hInfo As CLineInfo
  Dim YL As Integer
  Dim S, SS As Float
  Dim H As Integer
  Dim sStr As String
  Dim bLimit As Boolean
  Dim X1 As Float
  Dim X2 As Integer
  
  hInfo = $hDoc.Info(Row)
  bLimit = $hDoc.HasLimit(Row)
  X += $hView.ScrollX
  H = $hRows.H
  
  ' Limit
  
  YL = -1
  
  If $bShowLimit And If Row > 0 Then
    If Not RTrim($hDoc.Lines[Row]) And If Row < $hDoc.Max Then
      If $hDoc.HasLimit(_ViewToReal(_RealToView(Row) + 1)) Then YL = Y + Height \ 2
    Else
      If bLimit And If RTrim($hDoc.Lines[_ViewToReal(_RealToView(Row) - 1)]) Then YL = Y
    Endif
  Endif
  
  ' Margin
  
  'Paint.FillRect(X, Y, $MW, Height, $iBackground)
  
  If $bShowIcon Or If $bShowExpand Then
    
    If $hDoc.HasBreakpoint(Row) Or If $hDoc.HasBookmark(Row) Or If hInfo.Limit Then
      
      If $hDoc.HasBookmark(Row) Then
        ' SS = S / 3
        ' Paint.MoveTo(0, SS)
        ' Paint.RelLineTo(SS, SS)
        ' Paint.RelLineTo(2 * SS, - SS * 2)
        ' Paint.LineWidth = SS / 2
        ' Paint.Background = $hStyles[Highlight.Current].Color
        ' Paint.Stroke
        X1 = X + $MW - $LH / 2 - $iWidthModified
        X2 = X + $MW - $iWidthModified
        Paint.MoveTo(X, Y)
        Paint.LineTo(X1, Y)
        Paint.LineTo(X2, Y + Height / 2)
        Paint.LineTo(X1, Y + Height)
        Paint.LineTo(X, Y + Height)
        Paint.LineTo(X, Y)
        Paint.Background = $hStyles[Highlight.Selection].Color
        Paint.Fill
      Endif
      
      Paint.Save
      Paint.Translate(X + $iPosIcon + H / 4, Y + H / 4)
      S = H / 2
      Paint.LineWidth = S / 6
      
      If $hDoc.HasBreakpoint(Row) Then
        Paint.Ellipse(0, 0, S, S)
        If $hDoc.IsBreakpointDisabled(Row) Then
          Paint.Background = Color.SetAlpha($hStyles[Highlight.Normal].Color, 228)
        Else
          Paint.Background = Color.SetAlpha($hStyles[Highlight.Breakpoint].Color, 128)
        Endif
        Paint.Fill(True)
        Paint.Stroke
      Endif
      
      If $bShowExpand Then
        If hInfo.Limit Then
          SS = S / 2
          Paint.Background = $iForeground
          'Style.PaintArrow(0, 0, S, S, If(_IsRowExpanded(Row), Align.Bottom, Align.Right))
          'Style.PaintArrow(X + $iPosIcon + 3, Y + 3, S, S, If(_IsRowExpanded(Row), Align.Bottom, Align.Right))
          Paint.MoveTo(0, SS)
          Paint.RelLineTo(S, 0)
          If Not _IsRowExpanded(Row) Then
            Paint.MoveTo(SS, 0)
            Paint.RelLineTo(0, S)
          Endif
          Paint.LineCap = Paint.LineCapRound
          Paint.Stroke
        Endif
      Endif
      
      Paint.Restore
      
    Endif
    
  Endif
  
  If $bShowModified Then
    If hInfo.Modified Or If hInfo.Saved Then
      If hInfo.Modified Then
        iCol = Color.Merge($iBackground, Color.Red, 0.2)
      Else If hInfo.Saved Then
        iCol = Color.Merge($iBackground, Color.Green, 0.2)
      Endif
      Paint.FillRect(X + $MW - $iWidthModified, Y, $iWidthModified - 1, Height, iCol)
    Endif
  Endif
  
  If YL >= 0 Then Paint.FillRect(X, YL, Width, 1, $iLimitColor)
  
  If YL < 0 Or If YL = Y Then
    If $bShowLineNumber Then
      If (Row + 1) Mod 10 = 0 Then
        iCol = $iForeground
      Else
        iCol = $iLimitColor
      Endif
      Paint.Background = iCol
      sStr = CStr(Row + 1 + $iLineNumberOffset)
      Paint.DrawText(sStr, X, Y, $iWidthLineNumber - 4, H, Align.Right)
      ' If Row = $Y Then
      '   Paint.Background = Color.SetAlpha(iCol, 128)
      '   Paint.DrawText(sStr, X + 1, Y, $iWidthLineNumber - 4, H, Align.Right)
      ' Endif
    Endif
  Endif
  
End

Fast Private Sub TextWidth(sText As String, iStart As Integer, iLength As Integer) As Integer
  
  Dim aText As String[]
  Dim I As Integer
  Dim W As Float
  
  I = InStr(sText, "\t", iStart) - iStart
  
  If I < 0 Or If I >= iLength Then
    If $fCharWidth Then
      Return $fCharWidth * iLength
    Else
      Return $hFont.TextWidth(String.Mid$(sText, iStart, iLength))
    Endif
  Endif
  
  If iLength <= 0 Then Return 0
  aText = Split(String.Mid$(sText, iStart, iLength), "\t")
  
  If $fCharWidth Then
    
    For I = 0 To aText.Max - 1
      W += $fCharWidth * String.Len(aText[I])
      W = (CInt(W + $iTabWidth) \ $iTabWidth) * $iTabWidth
    Next
    W += $fCharWidth * String.Len(aText[aText.Max])
    
  Else
    
    For I = 0 To aText.Max - 1
      W += $hFont.TextWidth(aText[I])
      W = (CInt(W + $iTabWidth) \ $iTabWidth) * $iTabWidth
    Next
    W += $hFont.TextWidth(aText[aText.Max])
    
  Endif
  
  Return Ceil(W)
  
End

Private Sub LinePos(Y As Integer, Optional X As Integer = -1) As Point
  
  Dim aLayout As Integer[]
  Dim I As Integer
  Dim P As Integer
  Dim hPos As Point
  Dim cCache As Collection
  Dim XO As Integer
  Dim XX As Integer
  
  XO = X
  Try hPos = $cCachePos[Y][XO]
  If hPos Then Goto RETURN_POS
  
  If $cLineLayout Then
    aLayout = $cLineLayout[Y]
    If aLayout Then
      For I = 0 To aLayout.Max
        If X < aLayout[I] Then Break
        P += aLayout[I]
        X -= aLayout[I]
      Next
      XX = TextWidth($hDoc.Lines[Y], P + 1, X)
      If I Then XX += LineStartPos(Y)
      hPos = Point(XX, I * $LH)
      Goto CACHE_POS
    Endif
  Endif
  
  hPos = New Point
  If X < 0 Then
    hPos.X = TextWidth($hDoc.Lines[Y], 1, $hDoc.LineLength[Y])
  Else
    hPos.X = TextWidth($hDoc.Lines[Y], 1, X)
  Endif
  
CACHE_POS:
  
  cCache = $cCachePos[Y]
  If Not cCache Then
    If $cCachePos.Count > 80 Then
      For Each $cCachePos
        $cCachePos.Remove($cCachePos.Key)
        Break
      Next
    Endif
    cCache = New Collection
    $cCachePos[Y] = cCache
  Endif
  cCache[XO] = hPos
  
  'If Y = 28 Then Debug "calc";; X;; Y;; "->";; hPos;; hPos.X;; hPos.Y
  
RETURN_POS:
  
  Return hPos
  
End

Private Sub LineStartPos(Y As Integer) As Integer
  
  Dim S As Integer
  Dim aLayout As Integer[]
  
  S = Len($hDoc.Lines[Y]) - Len(LTrim($hDoc.Lines[Y]))
  Try aLayout = $cLineLayout[Y]
  If aLayout And If S >= aLayout[0] Then S = aLayout[0] - 1
  Return LinePos(Y, S).X
  
End

Private Sub FindLargestLine() As Integer
  
  Dim I As Integer
  Dim W As Integer
  Dim WM As Integer = -1
  
  If $hDoc.Count >= 10000 Then Inc Application.Busy
  
  For I = 0 To $hDoc.Count - 1
    W = LinePos(I).X
    If W > WM Then
      WM = W
      $iLargestLine = I
    Endif
  Next
  
  If $hDoc.Count >= 10000 Then Dec Application.Busy
  
  Return WM
  
End

Private Sub UpdateWidth(Optional Y As Integer = -1)
  
  Dim W As Integer
  
  If $cLineLayout Then
    If $iWidth <> $hView.ClientWidth Then
      $iWidth = $hView.ClientWidth
      _ResizeContents
    Endif
    Return
  Endif
  
  If $iLargestLine < 0 Or If $iLargestLine > $hDoc.Max Then
    FindLargestLine
    Y = -1
  Endif
  
  If Y < 0 Then
    W = LinePos($iLargestLine).X + $MW + 2
    Goto UPDATE_WIDTH
  Endif
  
  W = LinePos(Y).X + $MW + 2
  If W > $iWidth Then
    $iLargestLine = Y
    Goto UPDATE_WIDTH
  Else If W < $iWidth And If Y = $iLargestLine Then
    W = FindLargestLine() + $MW + 2
    Goto UPDATE_WIDTH
  Endif
  
  Return
  
UPDATE_WIDTH:
  
  $iWidth = Max($hView.ClientWidth, W)
  _ResizeContents
  
End

Public Sub TimerCursor_Timer()
  
  If $bMouseDown Then Return
  $bShowCursor = Not $bShowCursor
  _RefreshLine($Y)
  
End

Public Sub View_KeyPress()
  
  Dim Y As Integer
  Dim sAction As String
  Dim sTab As String
  Dim bCancel As Boolean
  Dim aLayout As Integer[]
  Dim I, P As Integer
  Dim bSaveOverwrite As Boolean = $bOverwrite
  
  bCancel = Raise KeyPress
  If bCancel Then Goto STOP_EVENT
  
  Try sAction = $cShortcut[String.UCase(Shortcut.FromKey())]
  If sAction Then 
    Select Case sAction
      Case "Copy"
        Copy()
      Case "Paste"
        If $bReadOnly Then Goto STOP_EVENT
        Paste()
      Case "Undo"
        If $bReadOnly Then Goto STOP_EVENT
        Undo()
      Case "Redo"
        If $bReadOnly Then Goto STOP_EVENT
        Redo()
      Case "Cut"
        If $bReadOnly Then Goto STOP_EVENT
        Cut()
      Case "SelectAll"
        SelectAll
    End Select
    Goto STOP_EVENT
  Endif
  
  If Key.Text And If Asc(Key.Text) >= 32 And If Asc(Key.Text) <> 127 Then
    If $bReadOnly Then Goto STOP_EVENT
    If $hDoc._Mode And If $hDoc._Mode.OnKeyPress(Me) Then Goto STOP_EVENT
    Insert(Key.Text)
    Goto STOP_EVENT
  Endif
  
  Select Case Key.Code
      
    Case Key.Right
      If Key.Control Then
        If $X >= $hDoc.LineLength[$Y] Then
          Goto(0, _ViewToReal(_RealToView($Y) + 1), Key.Shift)
        Else
          Goto($hDoc.WordRight($X, $Y), $Y, Key.Shift)
        Endif
      Else If Key.Normal Or If Key.Shift Then
        If $X >= $hDoc.LineLength[$Y] Then
          Goto(0, _ViewToReal(_RealToView($Y) + 1), Key.Shift)
        Else
          Goto($X + 1, $Y, Key.Shift)
        Endif
      Endif
      
    Case Key.Left
      '$X = NormalizeColumn($X, $Y)
      If Key.Control Then
        If $X = 0 Then
          Goto(-1, _ViewToReal(_RealToView($Y) - 1), Key.Shift)
        Else
          Goto($hDoc.WordLeft($X, $Y), $Y, Key.Shift)
        Endif
      Else If Key.Normal Or If Key.Shift Then
        If $X = 0 Then
          Goto(-1, _ViewToReal(_RealToView($Y) - 1), Key.Shift)
        Else
          Goto($X - 1, $Y, Key.Shift)
        Endif
      Endif
      
    Case Key.Up
      If Key.Alt Then
        MoveSelection(True)
      Else If Key.Control Then
        Y = FindPreviousLimit($Y)
        If Y >= 0 Then
          Goto($X, Y, Key.Shift)
        Else
          Goto(0, 0, Key.Shift)
        Endif
      Else
        'Goto($X, ViewToReal(RealToView($Y) - 1), Key.Shift)
        'Y = RealToView($Y)
        GotoXY($X0 + $MW - $hView.ScrollX, $hRows._GetRowY($Y) - $hView.ScrollY + $XY.Y - $hRows.H, Key.Shift)
      Endif
      
    Case Key.Down
      If Key.Alt Then
        MoveSelection(False)
      Else If Key.Control Then
        Y = FindNextLimit($Y)
        If Y >= 0 Then
          Goto($X, Y, Key.Shift)
        Else
          Goto(-1, $hDoc.Max, Key.Shift)
        Endif
      Else
        'Goto($X, ViewToReal(RealToView($Y) + 1), Key.Shift)
        'Y = RealToView($Y)
        GotoXY($X0 + $MW - $hView.ScrollX, $hRows._GetRowY($Y) - $hView.ScrollY + $XY.Y + $hRows.H, Key.Shift)
      Endif
      
    Case Key.Home
      If Key.Control Then
        Goto(0, 0, Key.Shift)
      Else
        Try aLayout = $cLineLayout[$Y]
        If Not aLayout Or If $X < aLayout[0] Then
          P = GetLineIndent($Y)
          If P = $X Then P = 0
          Goto(P, $Y, Key.Shift)
        Else
          P = aLayout[0]
          For I = 1 To aLayout.Max
            If $X < P + aLayout[I] Then Break
            P += aLayout[I]
          Next
          If P = $X Then P = GetLineIndent($Y)
          Goto(P, $Y, Key.Shift)
        Endif
      Endif
      
    Case Key.End
      If Key.Control Then
        Goto(-1, $hDoc.Max, Key.Shift)
      Else
        Try aLayout = $cLineLayout[$Y]
        If Not aLayout Then
          Goto(-1, $Y, Key.Shift)
        Else
          P = 0
          For I = 0 To aLayout.Max
            P += aLayout[I]
            If $X < P Then
              Dec P
              Break
            Endif
          Next
          If P = $X Or If I = aLayout.Count Then P = -1
          Goto(P, $Y, Key.Shift)
        Endif
      Endif
      
    Case Key.PageUp
      'Y = RealToView($Y)
      'Y = $hRows._FindRowFromPos($hRows._GetRowY($Y) + $hRows._GetRowHeight($Y) - $hView.ClientH)
      'Y = ViewToReal(Y)
      'Goto($X, Max(0, Y), Key.Shift)
      If Not Key.Control And If Not Key.Alt And If Not Key.Meta Then
        If GotoXY($X0 + $MW - $hView.ScrollX, $hRows._GetRowY($Y) + $XY.Y - $hView.ClientH - $hView.ScrollY, Key.Shift) Then
          Goto(0, 0, Key.Shift)
        Endif
      Endif
      
    Case Key.PageDown
      'Y = RealToView($Y)
      'Y = $hRows._FindRowFromPos($hRows._GetRowY($Y) + $hView.ClientH)
      'Y = ViewToReal(Y)
      'If Y >= 0 Then
      'Goto($X, Y, Key.Shift)
      'Else
      'Goto($X, $hDoc.Max, Key.Shift)
      'Endif
      If Not Key.Control And If Not Key.Alt And If Not Key.Meta Then
        If GotoXY($X0 + $MW - $hView.ScrollX, $hRows._GetRowY($Y) + $XY.Y + $hView.ClientH - $hView.ScrollY, Key.Shift) Then
          Goto(-1, $hDoc.Max, Key.Shift)
        Endif
      Endif
      
    Case Key.Enter, Key.Return
      
      If $bShowExpand Then
        If Key.Control Then
          Y = FindPreviousLimit($Y + 1)
          If Y >= 0 Then
            If Key.Alt Then
              If _IsRowExpanded(Y) Then
                CollapseAll
              Else
                ExpandAll
              Endif
            Else
              ToggleRow(Y)
            Endif
          Endif
          Goto STOP_EVENT
        Endif
      Endif
      
      If $bReadOnly Then Goto STOP_EVENT
      
      If Not $bPrint Then $bOverwrite = False
      sTab = GetLineIndentText($Y)
      If $hDoc._Mode.BetweenBraces(Me) Then
        Insert("\n" & String.Left(sTab, $X) & GetTab() & "\n" & String.Left(sTab, $X))
        Goto(-1, $Y - 1)
      Else
        Insert("\n" & String.Left(sTab, $X))
      Endif
      'If Not $bPrint Then $bOverwrite = True
      $bOverwrite = bSaveOverwrite
      
    Case Key.BackSpace
      If Key.Control Then
        If $bReadOnly Then Goto STOP_EVENT
        DeleteWordLeft
      Else If Key.Normal Then
        If $bReadOnly Then Goto STOP_EVENT
        If $hDoc._Mode And If $hDoc._Mode.OnKeyPress(Me) Then Goto STOP_EVENT
        DeleteLeft
      Endif
      
    Case Key.Delete
      If Key.Control Then
        If $bReadOnly Then Goto STOP_EVENT
        DeleteWordRight
      Else If Key.Normal Then
        If $bReadOnly Then Goto STOP_EVENT
        DeleteRight
      Endif
      
    Case Key.Tab
      If Key.Control Then
        If $bReadOnly Then Goto STOP_EVENT
        Insert("\t")
      Else
        DoIndent(Key.Shift)
      Endif
      
    Case Key.BackTab
      DoIndent(True)
      
    Case Key.Insert
      Me.Overwrite = Not $bOverwrite
      
  End Select
  
STOP_EVENT:
  
  Stop Event
  
End

Public Sub HideSelection()
  
  If HasSelection() Then Refresh
  $SX = $X
  $SY = $Y
  $SXY = $XY.Copy()
  
End

Public Sub _RaiseCursor()
  
  If $iSaveCursor Then Return
  If $X = $LX And If $Y = $LY Then Return
  If $hDoc.IsLocked() Then Return
  
  EnsureVisible
  If $bShowPosition Then UpdatePosition
  
  TimerChange_Timer
  Raise Cursor
  $LX = $X
  $LY = $Y
  
End

Public Sub Goto(NX As Integer, NY As Integer, Optional Mark As Boolean)
  
  Dim SX As Integer
  Dim SY As Integer
  Dim SXY As Point
  Dim iLen As Integer
  
  If NY < 0 Then Return
  If NY > $hDoc.Max Then
    NY = $hDoc.Max
    NX = -1
  Endif
  
  NY = CheckFolded(NY)
  
  If NY <> $Y Then
    SX = $SX
    SY = $SY
    SXY = $SXY
    $hDoc.HighlightFrom($Y)
    If Mark Then
      If $SX <> SX Or If $SY <> SY Then
        $SX = SX
        $SY = SY
        $SXY = LinePos($SY, $SX)
      Endif
    Endif
  Endif
  
  iLen = $hDoc.LineLength[NY]
  If NX < 0 Or If NX > iLen Then NX = iLen
  
  If Not Mark Then HideSelection
  
  _RefreshLine($Y)
  
  'Debug "$XY.X =";; $XY.X
  If NX <> $X Or If NY <> $Y Then
    
    If Not Mark Then
      _RefreshLine(NY)
    Else
      _RefreshLine(Min(NY, $Y), Max(NY, $Y) - Min(NY, $Y) + 1)
    Endif
    
    $X = NX
    $Y = NY
    $XY = LinePos($Y, $X)
    '$XM = 0
    '$YM = -1
  Endif
  
  $X0 = $XY.X
  
  If Not Mark Then
    $SX = $X
    $SY = $Y
    $SXY = $XY
  Else
    Clipboard.Current = Clipboard.Selection
    Copy()
    Clipboard.Current = Clipboard.Default
  Endif
  
  $bShowCursor = True
  If Not $bReadOnly Then $hTimerCursor.Start
  
  CheckMatch
  CheckIndentMark
  _RaiseCursor
  
End

Private Sub EnsureVisible(Optional bCenter As Boolean)
  
  Dim Y As Integer
  Dim H As Integer
  
  'Y = RealToView($Y)
  H = $hRows.H '_GetRowHeight(Y)
  Y = $hRows._GetRowY($Y) + $XY.Y
  
  If bCenter Then
    Y = Y - $hView.ClientH \ 2 + H \ 2
    H = $hView.ClientH
  Endif
  
  If $bMouseDown Or If $XY.X > ($hView.ClientW - $MW) Then
    $hView.EnsureVisible($XY.X, Y, $iSpaceWidth + $MW, H)
  Else
    $hView.EnsureVisible(0, Y, $hView.ClientW, H)
  Endif
  
End

Public Sub GotoCenter(NX As Integer, NY As Integer)
  
  Goto(NX, NY)
  EnsureVisible(True)
  ' If Not $hTimerEnsureVisible Then
  '   $hTimerEnsureVisible = New Timer As "EnsureVisible"
  '   $hTimerEnsureVisible.Trigger
  ' Endif
  
End

Public Sub EnsureVisible_Timer()
  
  EnsureVisible(True)
  $hTimerEnsureVisible.Stop
  $hTimerEnsureVisible = Null
  
End

Private Sub PosToColumn(Y As Integer, PX As Integer, RY As Integer, Optional bIgnoreMargin As Boolean) As Integer
  
  Dim I As Integer
  Dim iLen As Integer
  Dim D As Integer
  Dim F As Integer
  Dim sStr As String
  Dim LP As Point
  Dim J As Integer
  
  sStr = $hDoc.Lines[Y]
  iLen = $hDoc.LineLength[Y]
  
  If Not bIgnoreMargin Then
    If PX < $MW Then Return 0
  Endif
  
  '   if (px < margin || px >= visibleWidth())
  '     _posOutside = true;
  '
  If iLen = 0 Then Return PX \ $hFont.TextWidth("m")
  
  PX += $hView.ScrollX - $MW
  RY = (RY \ $hRows.H) * $hRows.H
  
  '   px += contentsX();
  '
  D = 0
  F = iLen
  J = -1
  
  Do
    
    I = (D + F) \ 2
    If I = J Then Break
    J = I
    
    LP = LinePos(Y, I)
    
    If RY < LP.Y Or If RY = LP.Y And PX < LP.X Then
      F = I
    Else If RY > LP.Y Or If PX > LP.X Then
      D = I + 1
    Else
      D = I
      Break
    Endif
    
    ' 'LP = LinePos(Y, I + 1)
    ' If RY > LP.Y Or If PX >= LP.X Then
    '   D = I '+ 1
    '   Continue
    ' Endif
    '
    ' D = I
    ' Break
    
  Loop
  
  If LP Then
    If LP.Y < RY Then
      D = Min(iLen, D + 1)
    Else If LP.Y > RY Then
      D = Max(0, D - 1)
    Endif
  Endif
  '   _posOutside = d > len;
  Return D
  
End

Private Sub PosToLine(PY As Integer) As Integer
  
  Return $hRows._FindRowFromPos(PY + $hView.ScrollY)
  
End

Public Sub View_MouseDown()
  
  Dim Y As Integer
  Dim X As Integer
  Dim RY As Integer
  Dim MW As Integer
  
  $bFirstFocus = True
  
  If Mouse.Right Then Return
  
  Y = PosToLine(Mouse.Y)
  RY = $hRows.RelativeY
  
  If Y >= 0 Then
    MW = $MW
    If $bShowModified Then MW -= $iWidthModified
    If Mouse.X < MW And If Mouse.X >= $iPosIcon Then
      If Mouse.Left Then
        Goto(0, Y, Mouse.Shift)
        If Mouse.Normal And If $bShowExpand And If $hDoc.Info(Y).Limit Then
          ToggleRow(Y)
        Endif
      Endif
    Else
      'X = NormalizeColumn(PosToColumn(Y, Mouse.X, RY), Y)
      X = PosToColumn(Y, Mouse.X - $iSpaceWidth \ 2, RY)
      Goto(X, Y, Mouse.Shift)
    Endif
  Endif
  
  $bMouseDown = True
  
End

Public Sub View_DblClick()
  
  Dim X, Y As Integer
  
  If Mouse.Right Then Return
  
  If $bShowIcon Or If $bShowExpand Then
    Y = PosToLine(Mouse.Y)
    If Mouse.X < $MW And If Mouse.X >= $iPosIcon Then
      If $bShowExpand And If $hDoc.Info(Y).Limit Then
        If _IsRowExpanded(Y) Then
          ExpandAll
        Else
          CollapseAll
        Endif
      Else
        Goto(0, Y)
        Raise Margin
        Stop Event
      Endif
    Endif
  Endif
  
  If Mouse.X >= $MW Then
    X = $X
    If $X >= 0 Then Goto($hDoc.WordLeft($X, $Y, True), $Y)
    If $X < $hDoc.LineLength[$Y] Then X = $hDoc.WordRight($X, $Y, True)
    Goto(X, $Y, True)
  Endif
  
End

Public Sub View_MouseDrag()
  
  If Mouse.Right Then Return
  
  If Not $hTimerScroll Then
    $hTimerScroll = New Timer As "TimerScroll"
    $hTimerScroll.Delay = 50
    $hTimerScroll.Start
  Endif
  
End

Public Sub View_MouseMove()
  
  Dim Y, RY As Integer
  Dim X As Integer
  Dim PX As Integer
  
  PX = Mouse.ScreenX - $hView.ScreenX
  
  If PX < $MW Then
    $hView.Mouse = Mouse.Default
  Else
    $hView.Mouse = Mouse.Text
  Endif
  
  If $bMouseDown Then
    
    Y = PosToLine(Mouse.ScreenY - $hView.ScreenY)
    RY = $hRows.RelativeY
    If Y >= 0 Then
      'X = NormalizeColumn(PosToColumn(Y, Mouse.ScreenX - $hView.ScreenX, RY), Y)
      X = PosToColumn(Y, PX, RY, True)
      Goto(X, Y, True)
    Endif
    
  Endif
  
End

Public Sub View_MouseUp()
  
  If $hTimerScroll Then
    $hTimerScroll.Stop
    $hTimerScroll = Null
  Endif
  
  If Mouse.Middle Then
    Clipboard.Current = Clipboard.Selection
    Paste
    Clipboard.Current = Clipboard.Default
  Endif
  
  $bMouseDown = False
  
End

Public Sub TimerScroll_Timer()
  
  View_MouseMove
  
End

Private Function Line_Read() As Integer
  
  Return $Y
  
End

Private Function Column_Read() As Integer
  
  Return $X
  
End

Private Function SelectionLine_Read() As Integer
  
  Return $SY
  
End

Private Function SelectionColumn_Read() As Integer
  
  Return $SX
  
End

Private Function Selected_Read() As Boolean
  
  Return HasSelection()
  
End

Private Sub DeleteSelection() As Boolean
  
  If HasSelection() Then
    Remove($SX, $SY, $X, $Y)
    Return True
  Endif
  
End

' Private Sub NormalizeColumn(X As Integer, Y As Integer) As Integer
'
'   Return Min(String.Len($hDoc.Lines[Y]), X)
'
' End

Public Sub Insert(Text As String)
  
  Dim aText As String[]
  Dim I As Integer
  
  $hDoc.Begin
  
  DeleteSelection
  If Text Then 
  
    '$X = NormalizeColumn($X, $Y)
    
    If $bOverwrite Then
      
      aText = Split(Text, "\n")
      
      For I = 0 To aText.Max - 1
        Remove($X, $Y, $X + String.Len(aText[I]), $Y)
        If $Y = $hDoc.Max Then
          $hDoc.Insert(aText[I] & "\n", $X, $Y)
        Else
          $hDoc.Insert(aText[I], $X, $Y)
        Endif
        Goto(0, $Y + 1)
      Next
      
      Remove($X, $Y, $X + String.Len(aText[aText.Max]), $Y)
      $hDoc.Insert(aText[aText.Max], $X, $Y)
      
    Else
      
      $hDoc.Insert(Text, $X, $Y)
      
    Endif
    
    Goto($hDoc.XAfter, $hDoc.YAfter)
    
  Endif
  
  $hDoc.End
  
End

Public Sub _BeforeInsert(Y1 As Integer, N As Integer)
  
  $hRows._BeforeInsert(Y1, N, $cLineLayout)
  
End

Public Sub _AfterInsert(Y1 As Integer, Y2 As Integer, N As Integer)
  
  Dim Y As Integer
  
  _ExpandInsert(Y1, N)
  
  If Not $cLineLayout Then
    
    If $iLargestLine >= Y1 Then $iLargestLine += N
    
    For Y = Y1 To Y2
      UpdateWidth(Y)
    Next
    
  Endif
  
  If $cLineLayout Then
    
    'If N > 0 Then _UpdateAllHeight(True)
    
  Endif
  
  UpdateMargin
  UpdateCount
  
End

Private Function SelectedText_Read() As String
  
  If Not HasSelection() Then Return
  Return $hDoc.GetText($X, $Y, $SX, $SY)
  
End

Public Sub Copy()
  
  If Not HasSelection() Then Return
  Clipboard.Copy(Me.SelectedText)
  
End

Public Sub Paste()
  
  Dim sText As String
  
  If Clipboard.Type <> Clipboard.Text Then Return
  sText = Clipboard.Paste("text/plain")
  If Not sText Then Return
  
  Insert(sText)
  
End

Public Sub SelectAll()
  
  Goto(0, 0)
  Goto(-1, $hDoc.Max, True)
  
End

Public Sub Remove(X1 As Integer, Y1 As Integer, X2 As Integer, Y2 As Integer)
  
  'Goto(X1, Y1)
  
  $hDoc.Begin
  $hDoc.Remove(X1, Y1, X2, Y2)
  
  Goto($hDoc.XAfter, $hDoc.YAfter)
  $hDoc.End
  
End

Public Sub _AfterRemove(Y1 As Integer, Y2 As Integer)
  
  Dim X As Integer
  Dim Y As Integer
  
  If Y1 > Y2 Then Swap Y1, Y2
  
  _ClearCachePos
  
  If Y2 > Y1 Then
    $hRows._AfterRemove(Y1, Y2, $cLineLayout)
  Endif
  
  _ExpandRemove(Y1, Y2)
  
  Y = Min($Y, $hDoc.Max)
  X = Min($X, $hDoc.LineLength[Y])
  If X <> $X Or If Y <> $Y Then Goto(X, Y)
  
  $SX = $X
  $SY = $Y
  
  If Not $cLineLayout Then
    
    If $iLargestLine >= Y1 Then
      If $iLargestLine <= Y2 Then
        $iLargestLine = -1
        UpdateWidth
      Else
        $iLargestLine -= Y2 - Y1
      Endif
    Endif
    
  Else
    
    'If Y2 > Y1 Then _UpdateAllHeight(True)
    
  Endif
  
  UpdateMargin
  UpdateCount
  
End

Private Sub DeleteLeft()
  
  Dim sTab As String
  
  If DeleteSelection() Then Return
  
  '$X = NormalizeColumn($X, $Y)
  
  If $X = 0 Then
    If $Y > 0 Then
      Remove($hDoc.LineLength[$Y - 1], $Y - 1, 0, $Y)
    Endif
  Else
    sTab = GetLineIndentText($Y)
    If Len(sTab) = Len($hDoc.Lines[$Y]) Then
      If Right(sTab) = "\t" Then
        Remove($X - 1, $Y, $X, $Y)
      Else If Not $bTabIndent Then
        Remove((($X - 1) \ $iTabSize) * $iTabSize, $Y, $X, $Y)
      Else
        Remove($X - 1, $Y, $X, $Y)
      Endif
    Else
      Remove($X - 1, $Y, $X, $Y)
    Endif
  Endif
  
End

Private Sub DeleteWordLeft()
  
  Dim X As Integer
  
  If DeleteSelection() Then Return
  
  If $X = 0 Then
    DeleteLeft
    Return
  Endif
  
  X = $hDoc.WordLeft($X, $Y)
  If X = $X Then Return
  
  Begin()
  Goto(X, $Y, True)
  DeleteSelection()
  End()
  
End

Private Sub DeleteWordRight()
  
  Dim X As Integer
  
  If DeleteSelection() Then Return
  
  If $X >= $hDoc.LineLength[$Y] Then
    DeleteRight
    Return
  Endif
  
  X = $hDoc.WordRight($X, $Y)
  If X = $X Then Return
  
  Begin()
  Goto(X, $Y, True)
  DeleteSelection()
  End()
  
End

Private Sub DeleteRight()
  
  If DeleteSelection() Then Return
  
  If $X >= $hDoc.LineLength[$Y] Then
    If $Y < $hDoc.Max Then
      Remove($X, $Y, 0, $Y + 1)
    Endif
  Else
    Remove($X, $Y, $X + 1, $Y)
  Endif
  
End

Private Sub GetLineIndent(Y As Integer, Optional bIgnoreEmpty As Boolean) As Integer
  
  Dim sText As String
  Dim I As Integer
  Dim sCar As String
  
  sText = $hDoc.Lines[Y]
  For I = 1 To Len(sText)
    sCar = Mid$(sText, I, 1)
    If sCar <> " " And If sCar <> "\t" Then Break
  Next
  
  If bIgnoreEmpty And If I > Len(sText) Then Return -1
  Return I - 1
  
End

Private Sub GetLineIndentText(Y As Integer) As String
  
  Return String.Left($hDoc.Lines[Y], GetLineIndent(Y))
  
End

' Private Sub IsVisible(Y As Integer) As Boolean
'
'   If Y < $hView.RowAt(0) Then Return
'   If Y > $hView.RowAt($hView.ClientH - 1) Then Return
'   Return True
'
' End

Private Sub CheckMatch()
  
  Dim sCar As String
  Dim X, Y As Integer
  Dim iMatch As Integer
  Dim N, L As Integer
  Dim sOther As String
  Dim sLine As String
  Dim iLen As Integer
  Dim iOldXM, iOldYM As Integer
  
  iOldXM = $XM
  iOldYM = $YM
  
  $XM = 0
  $YM = -1
  
  If $bShowBraces Then
    
    Y = $Y
    X = Min($hDoc.LineLength[Y], $X)
    
    If X > 0 Then
      sCar = String.Mid$($hDoc.Lines[Y], X, 1)
      iMatch = InStr(MATCH_STRING, sCar)
      If iMatch Then Goto FIND_MATCH
    Endif
    
    Inc X
    sCar = String.Mid$($hDoc.Lines[Y], X, 1)
    iMatch = InStr(MATCH_STRING, sCar)
    If iMatch Then Goto FIND_MATCH
    
  Endif
  
  Goto FOUND
  
FIND_MATCH:
  
  If Odd(iMatch) Then
    sOther = Mid$(MATCH_STRING, iMatch + 1, 1)
  Else
    sOther = Mid$(MATCH_STRING, iMatch - 1, 1)
  Endif
  
  L = 1
  Dec X
  $XMO = X
  $YMO = Y
  
  sLine = $hDoc.Lines[Y]
  iLen = $hDoc.LineLength[Y]
  
  Do
    
    If Odd(iMatch) Then
      
      Inc X
      
      While X >= iLen
        
        X = 0
        Inc Y
        If Y > $hDoc.Max Then Goto FOUND
        Inc N
        If N > 1000 Then Goto FOUND
        
        sLine = $hDoc.Lines[Y]
        iLen = $hDoc.LineLength[Y]
        
      Wend
      
    Else
      
      Dec X
      
      While X < 0
        
        Dec Y
        If Y < 0 Then Goto FOUND
        Inc N
        If N > 1000 Then Goto FOUND
        
        sLine = $hDoc.Lines[Y]
        X = $hDoc.LineLength[Y] - 1
        
      Wend
      
    Endif
    
    Select Case String.Mid$(sLine, X + 1, 1)
        
      Case sOther
        Dec L
        If L = 0 Then
          $XM = X
          $YM = Y
          Goto FOUND
        Endif
        
      Case sCar
        Inc L
        
    End Select
    
  Loop
  
FOUND:
  
  If $XM <> iOldXM Or If $YM <> iOldYM Then
    _RefreshLine(iOldYM)
    _RefreshLine($Y)
    _RefreshLine($YM)
  Endif
  
End

Private Sub GetLineIndentMark(Y As Integer, Optional sText As String) As Integer
  
  Dim P As Integer
  
  If IsMissing(sText) Then sText = $hDoc.Lines[Y]
  
  P = Len(LTrim(sText))
  
  If P = 0 Then

    P = GetTabSizeAround(Y) + 1
    P = LinePos(Y, String.Len(sText)).X + (P - String.Len(sText)) * $iSpaceWidth

  Else

    P = Len(sText) - P
    P = LinePos(Y, P).X

  Endif
  
  Return P
  
End

Private Sub CheckIndentMark()

  Dim Y1, Y2 As Integer
  Dim IM1, IM2 As Integer
  Dim IY1 As Integer
  Dim IY2 As Integer
  Dim IP As Integer
  Dim IM0 As Integer
  Dim bStop As Boolean
  Dim bLimit1 As Boolean
  Dim bLimit2 As Boolean
  Dim bEqual2 As Boolean
  Dim bEqual1 As Boolean
  
  'If $Y = 501 Then Stop
  
  IM0 = GetLineIndentMark($Y)
  If IM0 = 0 Then Goto SET_RESULT
  
  bStop = False
  Y1 = $Y
  While Y1 > 0
    Dec Y1
    If Not Trim($hDoc.Lines[Y1]) Then Continue
    IM1 = GetLineIndentMark(Y1)
    If IM1 < IM0 Then 
      bLimit1 = True
      Break
    Else If IM1 > IM0 Then
      If Not bEqual1 Then bStop = True
    Else
      If bStop Then 
        bLimit1 = True
        Break
      Endif
      bEqual1 = True
    Endif
  Wend
  
  bStop = False
  Y2 = $Y
  While Y2 < $hDoc.Max
    Inc Y2
    If Not Trim($hDoc.Lines[Y2]) Then Continue
    IM2 = GetLineIndentMark(Y2)
    If IM2 < IM0 Then 
      bLimit2 = True
      Break
    Else If IM2 > IM0 Then
      If Not bEqual2 Then bStop = True
    Else
      If bStop Then 
        bLimit2 = True
        Break
      Endif
      bEqual2 = True
    Endif
  Wend
  
  'Debug "----"
  'Debug "Y1=";; Y1 + 1;; "Y2=";; Y2 + 1;; "bLimit1=";; bLimit1;; "bLimit2=";; bLimit2;; "bEqual1=";; bEqual1;; "bEqual2=";; bEqual2
  
  If bLimit1 And If bLimit2 Then
    IM1 = GetLineIndentMark(Y1)
    IM2 = GetLineIndentMark(Y2)
    If IM1 < IM2 Then
      If IM2 = IM0 Then Y1 = $Y
    Else If IM1 > IM2 Then
      If IM1 = IM0 Then Y2 = $Y
    Endif
  Else If bLimit1 Then
    Y2 = $Y
  Else If bLimit2 Then
    Y1 = $Y
  Endif
  
  'If bEqual1 Or If bEqual2 Then
    IP = Max(GetLineIndentMark(Y1), GetLineIndentMark(Y2))
  'Else
    'IP = Min(GetLineIndentMark(Y1), GetLineIndentMark(Y2))
  'Endif
  
  If IP = 0 Then
    IY1 = 0
    IY2 = 0
  Else
    IY1 = Y1
    IY2 = Y2
  Endif
  
  'Debug "=> "; IY1 + 1;; IY2 + 1;; IP
  
SET_RESULT:
  
  If IP <> $IP Or If IY1 <> $IY1 Or If IY2 <> $IY2 Then
    If $IP Then _RefreshLine($IY1, $IY2 - $IY1 + 1)
    $IP = IP
    $IY1 = IY1
    $IY2 = IY2
    If $IP Then _RefreshLine($IY1, $IY2 - $IY1 + 1)
  Endif
    
End


Public Sub _RefreshLine(Y As Integer, Optional N As Integer = 1)
  
  Dim I As Integer
  Dim hPict As Picture
  
  If Y < 0 Or If Y > $hDoc.Max Or If N <= 0 Then Return
  
  N = Min(N, $hDoc.Count - Y)
  
  If Not $bRemoteDisplay Then
    For I = Y To Y + N - 1
      hPict = $cCacheLine[I]
      If hPict Then
        $iCacheLineH -= hPict.H
        $cCacheLine.Remove(I)
      Endif
    Next
  Endif
  
  If N = 1 Then
    $hView.RefreshRect(0, $hRows._GetRowY(Y), $hView.ScrollW, $hRows._GetRowHeight(Y))
  Else
    $hView.RefreshRect(0, $hRows._GetRowY(Y), $hView.ScrollW, $hRows._GetRowY(Y + N) - $hRows._GetRowY(Y))
  Endif
  
End

Private Function ReadOnly_Read() As Boolean
  
  Return $bReadOnly
  
End

Private Sub ReadOnly_Write(Value As Boolean)
  
  $bReadOnly = Value
  $hTimerCursor.Enabled = Not Value
  $hView.Mouse = If($bReadOnly, Mouse.Default, Mouse.Text)
  
End

Private Function Highlight_Read() As String
  
  Return $hDoc.Highlight
  
End

Private Sub Highlight_Write(Value As String)
  
  $hDoc.Highlight = Value
  If $bShowPreview Then $hSideBarViewer.Highlight = Value
  
End

Private Function LineNumberOffset_Read() As Integer
  
  Return $iLineNumberOffset
  
End

Private Sub LineNumberOffset_Write(Value As Integer)
  
  $iLineNumberOffset = Value
  UpdateMargin
  Refresh
  
End

Private Function TabSize_Read() As Integer
  
  Return $iTabSize
  
End

Private Sub TabSize_Write(Value As Integer)
  
  $iTabSize = Max(1, Value)
  CalcSizes
  
End

Private Sub GetSelection(ByRef X1 As Integer, ByRef Y1 As Integer, ByRef X2 As Integer, ByRef Y2 As Integer)
  
  X1 = $X
  Y1 = $Y
  X2 = $SX
  Y2 = $SY
  
  If Y1 > Y2 Then
    Swap X1, X2
    Swap Y1, Y2
  Endif
  
  If X1 > X2 Then
    Swap X1, X2
  Endif
  
End

Private Sub GetTab(Optional X As Integer) As String
  
  If $bTabIndent Then 
    Return "\t"
  Else
    Return Space$($iTabSize - X Mod $iTabSize)
  Endif
  
End



Private Sub DoIndent(bBack As Boolean)
  
  Dim X1, Y1, X2, Y2 As Integer
  Dim Y As Integer
  Dim iInd As Integer
  Dim sTab As String
  Dim I As Integer
  
  If Not HasSelection() Then
    
    If Not bBack Then
      Insert(GetTab($X))
      Return
    Endif
    
    Goto(0, $Y)
    Goto(-1, $Y, True)
    
  Endif
  
  GetSelection(ByRef X1, ByRef Y1, ByRef X2, ByRef Y2)
  If X2 = 0 Then Dec Y2
  
  iInd = 1024
  For Y = Y1 To Y2
    I = GetLineIndent(Y, True)
    If I >= 0 Then iInd = Min(iInd, I)
    If iInd = 0 Then Break
  Next
  
  If bBack And iInd = 0 Then Return
  
  $hDoc.Begin
  
  If Not bBack Then
    
    sTab = GetTab(iInd)
    
    For Y = Y1 To Y2
      Goto(0, Y)
      Insert(sTab)
    Next
    
  Else
    
    If $bTabIndent Then
      sTab = "\t"
    Else
      sTab = Space$(Min(iInd, $iTabSize))
    Endif
    
    For Y = Y1 To Y2
      If $hDoc.Lines[Y] Begins sTab Then Remove(0, Y, Len(sTab), Y)
    Next
    
  Endif
  
  Goto(0, Y1)
  Goto(0, Y2 + 1, True)
  
  $hDoc.End
  
End

Public Sub Begin()
  
  $hDoc.Begin
  
End

Public Sub End()
  
  $hDoc.End
  
End

Private Function Length_Read() As Integer
  
  Return $hDoc.Length
  
End

Private Function Border_Read() As Boolean
  
  Return $hPanel.Border <> Border.None
  
End

Private Sub Border_Write(Value As Boolean)
  
  $hPanel.Border = If(Value, Border.Plain, Border.None)
  
End

Private Function ScrollBar_Read() As Integer
  
  Return $iScrollBar '$hView.ScrollBar
  
End

Private Sub ScrollBar_Write(Value As Integer)
  
  $iScrollBar = Value
  Select Case $iScrollBar
      
    Case Scroll.None, Scroll.Horizontal
      $hView.ScrollBar = $iScrollBar
      If $bShowPreview Then $hSideBar.Hide
    Case Scroll.Vertical
      If $bShowPreview Then
        $hView.ScrollBar = Scroll.None
        $hSideBar.Show
      Else
        $hView.ScrollBar = $iScrollBar
      Endif
    Case Scroll.Both
      If $bShowPreview Then
        $hView.ScrollBar = Scroll.Horizontal
        $hSideBar.Show
      Else
        $hView.ScrollBar = $iScrollBar
      Endif
      
  End Select
  
End

Public Sub _ClearCachePos(Optional Y As Integer = -1)
  
  If Y >= 0 Then
    Try $cCachePos.Remove(Y)
  Else
    $cCachePos.Clear
  Endif
  
End

Public Sub _ResizeContents()
  
  If $bNoResizeContents Then Return
  
  If $iWidth < $hView.ScrollWidth Then
    _UpdateAllHeight
  Else If $iWidth > $hView.ScrollWidth And If $cLineLayout And If $cLineLayout.Count Then
    _UpdateAllHeight
  Endif
  
  ClearCacheLine
  $hView.ResizeContents($iWidth, $hRows._GetHeight())
  
End

Public Sub View_Draw()
  
  Dim I As Integer
  Dim XO, YO, XX, YY, X, Y, H As Integer
  Dim iRow, iRow2 As Integer
  Dim hClip As Rect
  Dim hRect As Rect
  Dim aRow As Integer[]
  Dim iMaxRow As Integer
  Dim W, NL As Integer
  'Dim hImage As Image
  Dim hPict As Picture
  Dim iCount As Integer
  
  If Not $bUpdateHeightAllowed Then
    $bUpdateHeightAllowed = True
    _UpdateAllHeight(True)
  Endif
  
  If $bStyleChanged Then
    $iBackground = $hStyles[Highlight.Background].Color
    $iForeground = $hStyles[Highlight.Normal].Color
    $iSelectedBackground = $hStyles[Highlight.Selection].Color
    $iLimitColor = Color.Gradient($iBackground, $hStyles[Highlight.Comment].Color)
    $iIndentColor = Color.SetAlpha($iLimitColor, 160)
    $iMatchColor = $hStyles[Highlight.Highlight].Color
    '$iIndentColor = Color.Gradient($iBackground, $iForeground)
    $iMarginColor = Color.Merge($iLimitColor, $iBackground, 0.8)
    $bStyleChanged = False
  Endif
  
  'Debug Me.Font.ToString();; Draw.Font.ToString()
  
  iCount = $hDoc.Count
  NL = $hView.ClientH \ $hRows.H + 1
  
  hClip = Paint.ClipRect
  If iCount < NL Then Paint.FillRect(hClip.X, hClip.Y, hClip.W, hClip.H, $iBackground)
  
  iRow = $hRows._FindRowFromPos($hView.ScrollY + hClip.Y)
  If iRow < 0 Then Return
  iRow2 = $hRows._FindRowFromPos($hView.ScrollY + hClip.Y + hClip.H - 1)
  If iRow2 < 0 Then iRow2 = $hRows.Count - 1
  
  XO = - $hView.ScrollX
  XX = XO
  YO = - $hView.ScrollY
  YY = YO + $hRows._GetRowY(iRow)
  
  hClip = Paint.ClipRect
  
  Y = YY
  If System.RightToLeft Then
    X = $hView.ClientW
  Else
    X = 0
  Endif
  
  ' Cells
  
  hRect = New Rect($hView.ClientX - $hView.Proxy.X, $hView.ClientY, $hView.ClientW, $hView.ClientH)
  hClip = hClip.Intersection(hRect)
  If Not hClip Then Return
  
  iRow = _RealToView(iRow)
  iRow2 = _RealToView(iRow2)
  
  iMaxRow = iRow2 - iRow
  aRow = New Integer[iMaxRow + 1]
  For I = 0 To iMaxRow
    aRow[I] = _ViewToReal(iRow + I)
  Next
  
  Y = YY
  For I = 0 To iMaxRow
    iRow = aRow[I]
    If iRow >= iCount Then Break
    
    H = $hRows._GetRowHeight(iRow)
  
    If H >= $hView.ClientH Or If $bRemoteDisplay Then
      Paint.Save
      DrawLine(XX, Y, $iWidth, H, iRow) ',Y)
      Paint.Restore
    Else
      hPict = $cCacheLine[iRow]
      If Not hPict Then
        hPict = New Picture($iWidth, H)
        hPict.Fill($iBackground)
        Paint.Begin(hPict)
        Paint.Font = $hFont
        DrawLine(0, 0, $iWidth, H, iRow) ', Y)
        Paint.End
        $cCacheLine[iRow] = hPict
        $iCacheLineH += H
        Paint.DrawPicture(hPict, XX, Y)
        
        While $iCacheLineH > $hView.ClientH
          For Each hPict In $cCacheLine
            $iCacheLineH -= hPict.H
            $cCacheLine.Remove($cCacheLine.Key)
            Break
          Next
        Wend
        
      Else
        Paint.DrawPicture(hPict, XX, Y)
      Endif
    Endif
    Y += H
  Next
  
  W = $MW
  If $bShowModified Then W -= $iWidthModified
  If W > 0 Then Paint.FillRect(XX + $hView.ScrollX, hClip.Y, W, hClip.H, $iMarginColor)
  
  If $MW Then
    
    Paint.Font = $hFontNumber
    
    Y = YY
    For I = 0 To iMaxRow
      iRow = aRow[I]
      If iRow >= iCount Then Break
      Paint.Save
      H = $hRows._GetRowHeight(iRow)
      DrawMargin(XX, Y, $iWidth, H, iRow)
      Paint.Restore
      Y += H
    Next
    
  Endif
  
  $hTimerCacheLine.Stop
  $hTimerCacheLine.Start
  
  'PrintCache
  
End

Public Sub View_Resize()
  
  UpdateWidth
  
End

Private Function ShowLimit_Read() As Boolean
  
  Return $bShowLimit
  
End

Private Sub ShowLimit_Write(Value As Boolean)
  
  $bShowLimit = Value
  Refresh
  
End

Private Function ShowCurrent_Read() As Boolean
  
  Return $bShowCurrent
  
End

Private Sub ShowCurrent_Write(Value As Boolean)
  
  $bShowCurrent = Value
  Refresh
  
End

Private Function ShowLineNumber_Read() As Boolean
  
  Return $bShowLineNumber
  
End

Private Sub ShowLineNumber_Write(Value As Boolean)
  
  $bShowLineNumber = Value
  UpdateMargin
  Refresh
  
End

Private Function ShowModified_Read() As Boolean
  
  Return $bShowModified
  
End

Private Sub ShowModified_Write(Value As Boolean)
  
  $bShowModified = Value
  Refresh
  
End

Public Sub _get(({Line}) As Integer) As _TextEditor_Line
  
  Dim hLine As _TextEditor_Line
  
  hLine = New _TextEditor_Line
  Object.Attach(hLine, Me, "Line")
  hLine._Line = {Line}
  Return hLine
  
End

Private Function Count_Read() As Integer
  
  Try Return $hDoc.Count
  
End

Public Sub View_Scroll()
  
  If $hView.ScrollX <> $iLastScrollX Then
    ClearCacheLine
    $iLastScrollX = $hView.ScrollX
  Endif
  If $bShowPreview Then $hSideBar.Refresh
  Raise Scroll
  
End

Public Sub _RaiseChange()
  
  If $hTimerChange Then Return
  $hTimerChange = New Timer As "TimerChange"
  RefreshSideBar
  $hTimerChange.Trigger
  
End

Public Sub TimerChange_Timer()
  
  If Not $hTimerChange Then Return
  $hTimerChange = Null
  Raise Change
  
End

Private Function ShowPosition_Read() As Boolean
  
  Return $bShowPosition
  
End

Private Sub UpdatePosition()
  
  Dim sText As String
  
  If $hLabel And If $hLabel.Visible Then
    
    If $bOverwrite Then sText &= "  Overwrite"
    sText &= "  " & CStr($X + 1) & " : " & CStr($Y + 1)
    $hLabel.Text = "  " & Trim(sText) & "  "
    $hLabelFrame.Move($hView.ClientW - $hLabel.W, $hView.ClientH - $hLabel.H, $hLabel.W, $hLabel.H)
    $hLabel.Move(0, 0)
    
  Endif
  
End

Private Sub ShowPosition_Write(Value As Boolean)
  
  Dim hSave As Container
  
  $bShowPosition = Value
  If $bShowPosition Then
    If Not $hLabel Then
      hSave = $hView._Container
      $hView._Container = Null
      $hLabelFrame = New Panel($hView)
      $hView._Container = hSave
      $hLabelFrame.Background = Color.SetAlpha($hStyles[Highlight.Background].Color, 64)
      $hLabelFrame.Ignore = True
      $hLabel = New Label($hLabelFrame) ' TODO: NULL + gb.gtk => crash!
      $hLabel.AutoResize = True
      $hLabel.Font = Font[Me.Parent.Font.ToString()] ' TODO: Setting font directly sets nothing
      $hLabel.Foreground = $hStyles[Highlight.Normal].Color
      $hLabel.Show
    Endif
    UpdatePosition
  Else
    If $hLabel Then
      $hLabelFrame.Delete
      $hLabel = Null
      $hLabelFrame = Null
    Endif
  Endif
  
End

Public Sub View_Arrange()
  
  UpdatePosition
  If $cLineLayout Then UpdateWidth
  
End

Private Function Overwrite_Read() As Boolean
  
  Return $bOverwrite
  
End

Private Sub Overwrite_Write(Value As Boolean)
  
  $bOverwrite = Value
  UpdatePosition
  _RefreshLine($Y)
  
End

Private Function ShowIcon_Read() As Boolean
  
  Return $bShowIcon
  
End

Private Sub ShowIcon_Write(Value As Boolean)
  
  $bShowIcon = Value
  UpdateMargin
  Refresh
  
End

Private Function LineHeight_Read() As Integer
  
  Return $LH
  
End

Private Function Font_Read() As Font
  
  Return $hView.Font
  
End

Private Sub Font_Write(Value As Font)
  
  $hView.Font = Value
  
End

Private Function Current_Read() As _TextEditor_Line
  
  Return _get($Y)
  
End

Private Function StopLine_Read() As Integer
  
  Return $iStopLine
  
End

Private Sub StopLine_Write(Value As Integer)
  
  $iStopLine = Value
  Refresh
  
End

Private Function EndOfLine_Read() As Integer
  
  Return $hDoc.EndOfLine
  
End

Private Sub EndOfLine_Write(Value As Integer)
  
  $hDoc.EndOfLine = Value
  
End

Private Function Breakpoints_Read() As Integer[]
  
  Return $hDoc.Breakpoints
  
End

Private Sub Breakpoints_Write(Value As Integer[])
  
  $hDoc.Breakpoints = Value
  
End

Private Function Bookmarks_Read() As Integer[]
  
  Return $hDoc.Bookmarks
  
End

Private Sub Bookmarks_Write(Value As Integer[])
  
  $hDoc.Bookmarks = Value
  
End

Public Sub Select(Column As Integer, ({Line}) As Integer, Column2 As Integer, Line2 As Integer)
  
  Goto(Column, {Line})
  Goto(Column2, {Line2}, True)
  
End

Private Function ShowBraces_Read() As Boolean
  
  Return $bShowBraces
  
End

Private Sub ShowBraces_Write(Value As Boolean)
  
  $bShowBraces = Value
  CheckMatch
  Refresh
  
End

Private Function Styles_Read() As _TextEditor_Styles
  
  Return $hStyles
  
End

Public Sub FindPreviousLimit(Y As Integer) As Integer
  
  Do
    Dec Y
    If Y < 0 Then Return -1
    If $hDoc.Info(Y).Limit Then Return Y
  Loop
  
End

Public Sub FindNextLimit(Y As Integer) As Integer
  
  Do
    Inc Y
    If Y > $hDoc.Max Then Return -1
    If $hDoc.Info(Y).Limit Then Return Y
  Loop
  
End

Private Function View_Read() As TextEditor
  
  Return Object.Parent($hDoc)
  
End

Private Sub View_Write(Value As TextEditor)
  
  Me.View._RemoveView(Me)
  Value._AddView(Me)
  GotoCenter(Value.Column, Value.Line)
  
End

Public Sub _GetDocument() As CDocument
  
  Return $hDoc
  
End

Public Sub _SetDocument(hDoc As CDocument)
  
  If hDoc Then
    If hDoc = $hDoc Then Return
    $hDoc = hDoc
  Else
    $hDoc = New CDocument
    Object.Attach($hDoc, Me, "Document")
  Endif
  Init
  
End

Public Sub _AddView(hOther As TextEditor)
  
  If hOther = Me Then Return
  
  If Not _Views Then _Views = New TextEditor[]
  _Views.Add(hOther)
  
  hOther._SetDocument($hDoc)
  
End

Public Sub _RemoveView(hOther As TextEditor)
  
  If Not _Views Then Return
  Try _Views.Remove(_Views.FindByRef(hOther))
  If _Views.Count = 0 Then _Views = Null
  
End

Public Sub View_GotFocus()
  
  $hTimerCursor.Start
  
  If Not $bFirstFocus Then
    $bFirstFocus = True
    EnsureVisible(True)
  Endif
  
  If Object.Parent($hDoc) <> Me Then
    
    _Views = Me.View._Views
    _RemoveView(Me)
    _AddView(Me.View)
    Me.View._Views = Null
    Object.Attach($hDoc, Me, "Document")
    
  Endif
  
End

Public Sub View_LostFocus()
  
  $hTimerCursor.Stop
  $hDoc.HighlightFrom($Y)
  $hTimerCacheLine.Trigger
  
End

Public Sub _GetViews() As TextEditor[]
  
  Dim aView As New TextEditor[]
  Dim hView As TextEditor
  
  If Object.IsValid(Me) Then aView.Add(Me)
  
  If _Views Then
    For Each hView In _Views
      If Object.IsValid(hView) Then aView.Add(hView)
    Next
  Endif
  
  Return aView
  
End

Public Sub ToPosX(Optional Column As Integer = $X, ({Line}) As Integer = $Y) As Integer
  
  Return LinePos({Line}, Column).X - $hView.ScrollX + $MW
  
End

Public Sub ToPosY(Optional ({Line}) As Integer = $Y) As Integer
  
  Return $hRows._GetRowY({Line}) - $hView.ScrollY
  
End

Public Sub ToPos(Optional ({Line}) As Integer, Column As Integer) As Point
  
  Dim hPoint As Point
  
  If IsMissing({Line}) Then
    {Line} = $Y
    If IsMissing(Column) Then Column = $X
  Endif
  
  hPoint = LinePos({Line}, Column).Copy()
  hPoint.X += $MW - $hView.ScrollX
  hPoint.Y += $hRows._GetRowY({Line}) - $hView.ScrollY
  Return hPoint
  
End

Public Sub CursorAt(Optional ({Line}) As Integer, Column As Integer) As Point
  
  If IsMissing({Line}) Then
    {Line} = $Y
    If IsMissing(Column) Then Column = $X
  Endif
  
  Return ToPos({Line}, Column)
  
End

Public Sub ToColumn(X As Integer, Y As Integer) As Integer
  
  Dim L As Integer
  Dim RY As Integer
  
  L = PosToLine(Y)
  RY = $hRows.RelativeY
  
  If L < 0 Then Return L
  Return PosToColumn(L, X, RY)
  
End

Public Sub ToLine(Y As Integer) As Integer
  
  Return PosToLine(Y)
  
End

Private Sub GotoXY(X As Integer, Y As Integer, bMark As Boolean) As Boolean
  
  Dim L As Integer
  Dim RY As Integer
  Dim X0 As Integer
  
  L = PosToLine(Y)
  If L < 0 Then Return True
  
  RY = $hRows.RelativeY
  X0 = $X0
  Goto(PosToColumn(L, X, RY), L, bMark)
  $X0 = X0
  
End

Public Sub Indent()
  
  DoIndent(False)
  
End

Public Sub Unindent()
  
  DoIndent(True)
  
End

Private Function Keywords_Read() As String[]
  
  Return $hDoc.Keywords
  
End

Public Sub Undo()
  
  $hDoc.Undo
  
End

Public Sub Redo()
  
  $hDoc.Redo
  
End

Public Sub UpperCase()
  
  Dim X As Integer
  Dim Y As Integer
  
  If Not HasSelection() Then Return
  
  X = $SX
  Y = $SY
  Insert(String.UCase($hDoc.GetText($X, $Y, $SX, $SY)))
  Goto($SX, $SY)
  Goto(X, Y, True)
  
End

Public Sub LowerCase()
  
  Dim X As Integer
  Dim Y As Integer
  
  If Not HasSelection() Then Return
  
  X = $SX
  Y = $SY
  Insert(String.LCase($hDoc.GetText($X, $Y, $SX, $SY)))
  Goto($SX, $SY)
  Goto(X, Y, True)
  
End

Private Sub PrintNewLine()
  
  'Dim X As Integer = $X
  Goto(-1, $Y)
  Insert("\n")
  'If $bTerminal Then Goto(X, $Y)
  
End

' static void print_text(void *_object, const char *str, int lstr, bool esc = false)
' {
'   QString s = QString::fromUtf8(str, lstr);
'   int line, col;
'   uint i, len;
'
'   //fprintf(stderr, "-> %.*s\n", lstr, str);
'
'   WIDGET->getCursor(&line, &col);
'   /*if (col == 0)
'   {
'     DOC->remove(line, 0, line, DOC->lineLength(line));
'     WIDGET->cursorGoto(line, 0, false);
'   }*/
'
' //   if (col < DOC->lineLength(line))
' //   {
' //     end = col + s.length();
' //     if (end > DOC->lineLength(line))
' //       end = DOC->lineLength(line);
' //     DOC->remove(line, col, line, end);
' //   }
'
'   if (!esc)
'   {
'     i = 0;
'     for (;;)
'     {
'       if (col == MAX_CONSOLE_WIDTH)
'       {
'         print_newline(THIS);
'         col = 0;
'       }
'       len = s.length() - i;
'       if ((col + len) >= MAX_CONSOLE_WIDTH)
'         len = MAX_CONSOLE_WIDTH - col;
'       DOC->remove(WIDGET->getLine(), col, WIDGET->getLine(), col + len);
'       WIDGET->insert(s.mid(i, len));
'       i += len;
'       if (i >= (uint)s.length())
'         break;
'       col += len;
'     }
'   }
'   else
'   {
'     if (col >= MAX_CONSOLE_WIDTH)
'       print_newline(THIS);
'     DOC->remove(WIDGET->getLine(), col, WIDGET->getLine(), col + s.length());
'     WIDGET->insert(s);
'   }
'
'   //qApp->processEvents(QEventLoop::ExcludeUserInputEvents, 0);
'   //BREAKPOINT();
' }
'
' static int ansi_read_integer(const char *str, int len, int def, int *pos)
' {
'   int value = 0;
'   int n = 0;
'   uchar c;
'
'   str += *pos;
'   len -= *pos;
'
'   while (len > 0)
'   {
'     c = str[n];
'     if (c < '0' || c > '9')
'       break;
'     value = value * 10 + c - '0';
'     len--;
'     n++;
'     if (n > 6)
'     {
'       value = -1;
'       break;
'     }
'   }
'
'   if (n == 0)
'     value = def;
'
'   while (len > 0)
'   {
'     c = str[n];
'     len--;
'     n++;
'     if (c == ';' || c < '0' || c > '9')
'       break;
'   }
'
'   *pos += n;
'   return value;
' }
'

' Private Sub PrintAnsi(Text As String, I As Integer) As Integer
'
'   Dim C As String
'   Dim L As Integer
'
'   If I > Len(Text) Then Return 0
'
'   C = Mid$(Text, I, 1)
'   If InStr("[]()", C) Then
'     For L = I + 1 To Len(Text)
'       If IsLetter(Mid$(Text, L, 1)) Then Break
'     Next
'     L -= I
'   Endif
'
' End

' static int ansi_process(void *_object, const char *str, int len)
' {
'   uchar c;
'   int n, m, l, pos;
'   bool print;
'
'   if (len == 0)
'     return 0;
'
'   c = *str;
'   if (c == '[' || c == ']' || c == '(' || c == ')')
'   {
'     for (l = 0; l < len; l++)
'     {
'       c = str[l];
'       if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))
'         break;
'     }
'   }
'   else
'     l = 0;
'
'   if (l >= len)
'     return 0;
'
'   print = false;
'
'   if (*str == '[')
'   {
'     pos = 1;
'
'     switch(str[l])
'     {
'       case 'A':
'         n = ansi_read_integer(str, l, 1, &pos);
'         if (n > 0) WIDGET->cursorRelGoto(-n, 0, false);
'         break;
'
'       case 'B':
'         n = ansi_read_integer(str, l, 1, &pos);
'         if (n > 0) WIDGET->cursorRelGoto(n, 0, false);
'         break;
'
'       case 'C':
'         n = ansi_read_integer(str, l, 1, &pos);
'         if (n > 0) WIDGET->cursorRelGoto(0, n, false);
'         break;
'
'       case 'D':
'         n = ansi_read_integer(str, l, 1, &pos);
'         if (n > 0) WIDGET->cursorRelGoto(0, -n, false);
'         break;
'
'       case 'G':
'         n = ansi_read_integer(str, l, 1, &pos);
'         if (n > 0) WIDGET->cursorGoto(WIDGET->getLine(), n - 1, false);
'         break;
'
'       case 'd':
'         n = ansi_read_integer(str, l, 1, &pos);
'         if (n > 0) WIDGET->cursorGoto(n - 1, WIDGET->getColumn(), false);
'         break;
'
'       case 'H': case 'f':
'         n = ansi_read_integer(str, l, 1, &pos);
'         m = ansi_read_integer(str, l, 1, &pos);
'
'         while (DOC->numLines() < n)
'           DOC->insertLine(DOC->numLines());
'
'         WIDGET->cursorGoto(n - 1, m - 1, false);
'         THIS->terminal = TRUE;
'         //qApp->processEvents(QEventLoop::ExcludeUserInputEvents, 0);
'         break;
'
'       case 'J':
'         n = ansi_read_integer(str, l, 1, &pos);
'         switch(n)
'         {
'           case 0: WIDGET->clearDocument(false, true); break;
'           case 1: WIDGET->clearDocument(true, false); break;
'           case 2: WIDGET->clearDocument(true, true); break;
'         }
'
'       case 'K':
'         n = ansi_read_integer(str, l, 0, &pos);
'         switch (n)
'         {
'           case 0: WIDGET->clearLine(false, true); break;
'           case 1: WIDGET->clearLine(true, false); break;
'           case 2: WIDGET->clearLine(true, true); break;
'         }
'         break;
'
'       case 's':
'         WIDGET->saveCursor();
'         break;
'
'       case 'u':
'         WIDGET->restoreCursor();
'         break;
'
'       case 'X':
'         n = ansi_read_integer(str, l, 1, &pos);
'         WIDGET->clearAfter(n);
'         break;
'
'       default:
'         print = FALSE;
'     }
'   }
'
'   if (print)
'   {
'     fprintf(stderr, "ESC ");
'     for (n = 0; n <= l; n++)
'     {
'       uchar c = str[n];
'
'       if (c < 32)
'         fprintf(stderr, "\\x%02X", c);
'       else
'         fputc(c, stderr);
'     }
'     fputc('\n', stderr);
'
'     //qApp->processEvents(QEventLoop::ExcludeUserInputEvents, 0);
'     //BREAKPOINT();
'   }
'
'   return l;
' }
'

Private Sub PrintAnsi(Text As String, I As Integer) As Integer
  
  Dim C As String
  Dim N As Integer
  Dim aParam As New Integer[]
  Dim bDigit As Boolean
  
  C = Mid$(Text, I, 1)
  
  If C = "[" Then ' [
    
    N = 1
    Inc I
    While I <= Len(Text)
      Inc N
      C = Mid$(Text, I, 1)
      If IsDigit(C) Then
        If Not bDigit Then
          aParam.Add(0)
          bDigit = True
        Endif
        aParam[aParam.Max] = aParam[aParam.Max] * 10 + Asc(C) - 48
      Else If C = ";" Then
        bDigit = False
      Else
        Break
      Endif
      Inc I
    Wend
    
    If I > Len(Text) Then
      $sPrintBuffer = Chr$(27) & Mid$(Text, I, N)
      Return N
    Endif
    
    Select Case C
        
      Case "A"
        If aParam.Count Then
          RelGoto(0, - aParam[0])
        Else
          RelGoto(0, -1)
        Endif
        
      Case "B"
        If aParam.Count Then
          RelGoto(0, aParam[0])
        Else
          RelGoto(0, 1)
        Endif
        
      Case "C"
        If aParam.Count Then
          RelGoto(aParam[0], 0)
        Else
          RelGoto(1, 0)
        Endif
        
      Case "D"
        If aParam.Count Then
          RelGoto(- aParam[0], 0)
        Else
          RelGoto(-1, 0)
        Endif
        
      Case "K"
        aParam.Resize(1)
        Select Case aParam[0]
          Case 0
            ClearLine(False, True)
          Case 1
            ClearLine(True, False)
          Case 2
            ClearLine(True, True)
        End Select
        
    End Select
    
  Endif
  
  Return N
  
End

Public Sub Print(Text As String)
  
  Dim I, J, C As Integer
  Dim bSaveOverwrite As Boolean
  
  $hDoc.DisableUndo
  bSaveOverwrite = $bOverwrite
  $bOverwrite = True
  $bPrint = True
  
  If $sPrintBuffer Then
    Text = $sPrintBuffer & Text
    $sPrintBuffer = ""
  Endif
  
  J = 1
  For I = 1 To Len(Text)
    
    C = Asc(Text, I)
    
    If C < 32 Then
      
      If I > J Then Insert(Mid$(Text, J, I - J))
      
      J = I + 1
      
      If C = 9 Then
        Insert("\t")
      Else If C = 13 Then
        Goto(0, $Y)
      Else If C = 10 Then
        PrintNewLine
      Else If C = 12 Then
        Clear
      Else If C = 7 Then
        ' Flash
      Else If C = 8 Then
        If $X > 0 Then Goto($X - 1, $Y)
      Else If C = 27 Then
        I += PrintAnsi(Text, I + 1)
        J = I + 1
      Else
        Insert("^" & Chr$(64 + C))
      Endif
      
    Endif
    
  Next
  
  If I > J Then Insert(Mid$(Text, J, I - J))
  
  $bOverwrite = bSaveOverwrite
  $bPrint = False
  $hDoc.EnableUndo
  
End

'       else if (c == 27)
'       {
'         i++;
'         i += ansi_process(THIS, &str[i], len - i);
'         j = i + 1;
'         i--;
'       }
'       else
'       {
'         QString tmp;
'         tmp.sprintf("^%c", c + 64);
'         print_text(THIS, tmp, 2, true);
'       }
'     }
'   }
'
'   if (i > j)
'     print_text(THIS, &str[j], i - j);
'
'   DOC->end();
'
' END_METHOD
'

Public Sub FindNextString(Search As String, Start As Integer) As Integer
  
  If IsAscii(Search) Then
    Do
      If Start >= $hDoc.Count Then Return -1
      If InStr($hDoc.Lines[Start], Search, 1, gb.IgnoreCase) Then Return Start
      Inc Start
    Loop
  Else
    Do
      If Start >= $hDoc.Count Then Return -1
      If String.InStr($hDoc.Lines[Start], Search, 1, gb.IgnoreCase) Then Return Start
      Inc Start
    Loop
  Endif
  
End

Private Function ScrollX_Read() As Integer
  
  Return $hView.ScrollX
  
End

Private Sub ScrollX_Write(Value As Integer)
  
  $hView.ScrollX = Value
  
End

Private Function ScrollY_Read() As Integer
  
  Return $hView.ScrollY
  
End

Private Sub ScrollY_Write(Value As Integer)
  
  $hView.ScrollY = Value
  
End

Private Function ScrollWidth_Read() As Integer
  
  Return $hView.ScrollWidth
  
End

Private Function ScrollHeight_Read() As Integer
  
  Return $hView.ScrollHeight
  
End

Public Sub Scroll(X As Integer, Y As Integer)
  
  $hView.Scroll(X, Y)
  
End

Private Function ShowCursor_Read() As Boolean
  
  Return Not $bHideCursor
  
End

Private Sub ShowCursor_Write(Value As Boolean)
  
  $bHideCursor = Not Value
  Refresh
  
End

Public Sub Cut()
  
  If Not HasSelection() Then
    Goto(0, $Y)
    If $Y < $hDoc.Max Then
      Goto(0, $Y + 1, True)
    Else
      Goto(-1, $Y, True)
    Endif
  Endif
  Copy()
  DeleteSelection()
  
End

Public Sub Refresh()
  
  ClearCacheLine
  $hView.Refresh
  RefreshSideBar
  
End

Public Sub Reset()
  
  $hTimerChange = Null
  $hDoc.Reset
  
End

Public Sub _RaiseHighlight(sText As String)
  
  Raise Highlight(sText)
  
End

Public Sub _ViewToReal(Y As Integer) As Integer
  
  Dim I As Integer
  Dim M As Integer
  Dim J As Integer
  Dim YO As Integer
  
  YO = Y
  
  If $aFold Then
    
    Try Y = $cCacheView[Y]
    If Error Then
      
      M = $hDoc.Max
      
      For I = 0 To $aFold.Max Step 2
        If Y <= $aFold[I] Then Break
        J = I + 1
        If $aFold[J] < M Then
          Y += $aFold[J] - $aFold[I]
        Else
          Y = M + 1
        Endif
      Next
      
      $cCacheView[YO] = Y
      
    Endif
    
  Endif
  
  Return Y
  
End

Public Sub _RealToView(Y As Integer) As Integer
  
  Dim I As Integer
  Dim YY As Integer
  Dim J As Integer
  Dim YO As Integer
  
  YO = Y
  
  If $aFold Then
    
    Try Y = $cCacheView[- Y]
    If Error Then
      
      YY = Y
      
      For I = 0 To $aFold.Max Step 2
        If Y < $aFold[I] Then Continue
        J = I + 1
        If Y <= $aFold[J] Then
          YY -= Y - $aFold[I]
        Else
          YY -= $aFold[J] - $aFold[I]
        Endif
      Next
      
      Y = YY
      $cCacheView[- YO] = Y
      
    Endif
    
  Endif
  
  Return Y
  
End

' int GEditor::realToView(int row) const
' {
'   uint i;
'   GFoldedProc *fp;
'   int y;
'
'   //fprintf(stderr, "realToView: %d -> ", row);
'
'   y = row;
'
'   for (i = 0; i < fold.count(); i++)
'   {
'     fp = fold.at(i);
'     if (row < fp->start)
'       continue;
'     if (row <= fp->end)
'       y -= row - fp->start;
'     else
'       y -= fp->end - fp->start;
'   }
'
'   //fprintf(stderr, "%d\n", y);
'
'   return y;
' }
'

Private Sub UpdateCount()
  
  Dim Y As Integer
  'Dim X As Integer
  
  _ClearCachePos
  $hRows.Count = _RealToView($hDoc.Max) + 1
  
  Y = _ViewToReal(_RealToView($Y))
  'X = NormalizeColumn($X, Y)
  Goto($X, Y)
  
  $hView.Refresh
  RefreshSideBar
  
End

Public Sub _CheckRowWithFolding(Y As Integer) As Integer
  
  Dim NY As Integer
  Dim I As Integer
  
  If Not $aFold Then Return Y
  
  NY = Y
  For I = 0 To $aFold.Max Step 2
    If Y > $aFold[I] And If Y <= $aFold[I + 1] Then
      NY = $aFold[I]
      Break
    Endif
  Next
  
  Return NY
  
  ' int GEditor::checkCursor(int y)
  ' {
  '   uint i;
  '   GFoldedProc *fp;
  '   int ny;
  '
  '   ny = y;
  '   for (i = 0; i < fold.count(); i++)
  '   {
  '     fp = fold.at(i);
  '     if (y > fp->start && y <= fp->end)
  '     {
  '       ny = fp->start;
  '       break;
  '     }
  '   }
  '
  '   return ny;
  ' }
  '
  
End

Public Sub _CollapseRow(Y As Integer, Optional bNoRefresh As Boolean)
  
  Dim iStart As Integer
  Dim iEnd As Integer
  Dim iPos As Integer
  Dim I As Integer
  Dim NY As Integer
  
  If Not $hDoc.Info(Y).Limit Then
    Y = FindPreviousLimit(Y)
  Endif
  
  If Y < 0 Or If Y >= $hDoc.Count Then Return
  
  iStart = Y
  iEnd = FindNextLimit(iStart)
  If iEnd < 0 Then
    iEnd = $hDoc.Max
  Else
    Dec iEnd
  Endif
  
  iPos = -1
  
  If Not $aFold Then $aFold = New Integer[]
  
  For I = 0 To $aFold.Max Step 2
    If iEnd >= $aFold[I] And If iStart <= $aFold[I + 1] Then Return
    If iPos < 0 And If iStart < $aFold[I] Then
      iPos = I
    Endif
  Next
  
  If iPos < 0 Then
    $aFold.Add(iStart)
    $aFold.Add(iEnd)
  Else
    $aFold.Add(iStart, iPos)
    $aFold.Add(iEnd, iPos + 1)
  Endif
  
  NY = _CheckRowWithFolding(Y)
  If NY <> Y Then Goto($X, NY)
  
  If Not bNoRefresh Then
    $cCacheView.Clear
    UpdateCount
  Endif
  
End

Public Sub _ExpandRow(Y As Integer)
  
  Dim I As Integer
  
  For I = 0 To $aFold.Max Step 2
    If Y >= $aFold[I] And If Y <= $aFold[I + 1] Then
      $aFold.Remove(I, 2)
      $cCacheView.Clear
      UpdateCount
      Break
    Endif
  Next
  
End

Private Function ShowExpand_Read() As Boolean
  
  Return $bShowExpand
  
End

Private Sub ShowExpand_Write(Value As Boolean)
  
  If Not Value Then ExpandAll
  $bShowExpand = Value
  UpdateMargin
  
End

Public Sub _IsRowExpanded(Y As Integer) As Boolean
  
  Dim D As Integer
  Dim F As Integer
  Dim I As Integer
  
  If Not $aFold Then Return True
  
  D = 0
  F = $aFold.Count
  
  While F > D
    
    I = ((F + D) \ 4) * 2
    If $aFold[I] = Y Then Return
    If $aFold[I] < Y Then
      D = I + 2
    Else
      F = I
    Endif
    
  Wend
  
  Return True
  
End

Fast Public Sub _IsRowVisible(Y As Integer) As Boolean
  
  Dim D As Integer
  Dim F As Integer
  Dim I As Integer
  
  If Not $aFold Then Return True
  
  D = 0
  F = $aFold.Count
  
  While F > D
    
    I = ((F + D) \ 4) * 2
    If $aFold[I] = Y Then Return True
    If $aFold[I] < Y Then
      If Y <= $aFold[I + 1] Then Return False
      D = I + 2
    Else
      F = I
    Endif
    
  Wend
  
  Return True
  
End

Public Sub _GetLastVisibleRow() As Integer
  
  Dim N As Integer
  
  N = $hDoc.Max
  If _IsRowVisible(N) Then Return N
  Return $aFold[$aFold.Max - 1]
  
End

Private Sub ToggleRow(Y As Integer)
  
  If _IsRowExpanded(Y) Then
    _CollapseRow(Y)
  Else
    _ExpandRow(Y)
  Endif
  
  RefreshSideBar
  
End

' bool GEditor::isFolded(int row)
' {
'   uint i;
'   GFoldedProc *fp;
'   int d, f;
'
'   d = 0;
'   f = fold.count();
'
'   while (f > d)
'   {
'     i = (f + d) / 2;
'     fp = fold.at(i);
'     if (fp->start == row)
'       return true;
'     else if (fp->start < row)
'       d = i + 1;
'     else
'       f = i;
'   }
'
'   return false;
' }
'
'

Private Sub CheckFolded(Y As Integer) As Integer
  
  Dim I As Integer
  
  If Not $aFold Then Return Y
  
  For I = 0 To $aFold.Max Step 2
    If Y <= $aFold[I + 1] Then
      If Y > $aFold[I] Then Return $aFold[I]
      Break
    Endif
  Next
  
  Return Y
  
End

' int GEditor::checkFolded(int row)
' {
'   uint i;
'   GFoldedProc *fp;
'
'   for (i = 0; i < fold.count(); i++)
'   {
'     fp = fold.at(i);
'     if (row <= fp->end)
'     {
'       if (row > fp->start)
'         return fp->start;
'       else
'         break;
'     }
'   }
'
'   return row;
' }
'

Public Sub CollapseAll()
  
  Dim Y As Integer
  
  Y = 0
  Do
    _CollapseRow(Y, True)
    Y = FindNextLimit(Y)
    If Y < 0 Then Break
  Loop
  
  $cCacheView.Clear
  UpdateCount
  EnsureVisible(True)

  RefreshSideBar
  
End

' void GEditor::foldAll()
' {
'   int row;
'
'   if (getFlag(NoFolding))
'     return;
'
'   row = 0;
'   for(;;)
'   {
'     foldLine(row, true);
'     row = doc->getNextLimit(row);
'     if (row < 0)
'       break;
'   }
'
'   setNumRows(numLines());
'   //updateContents();
' }
'

Public Sub ExpandAll()
  
  $aFold = Null
  UpdateCount
  $cCacheView.Clear
  EnsureVisible(True)
  
  RefreshSideBar
  
End

' void GEditor::unfoldAll()
' {
'   foldClear();
'   setNumRows(numLines());
'   ensureCursorVisible();
'   //redrawContents();
' }
'
'

Private Sub _ExpandRemove(Y1 As Integer, Y2 As Integer)
  
  Dim N As Integer
  Dim I As Integer
  
  If Not $aFold Then Return
  
  If Y2 <= Y1 Then
    _ExpandRow(Y1)
    Return
  Endif
  
  N = Y2 - Y1
  
  While I < $aFold.Count
    If Y2 < $aFold[I] Then
      $aFold[I] -= N
      $aFold[I + 1] -= N
      I += 2
    Else If Y1 > $aFold[I + 1] Then
      I += 2
    Else
      $aFold.Remove(I, 2)
    Endif
  Wend
  
  $cCacheView.Clear
  
End

' void GEditor::foldRemove(int y1, int y2)
' {
'   uint i;
'   GFoldedProc *fp;
'   int n;
'
'   if (getFlag(NoFolding))
'     return;
'
'   if (y2 < 0)
'   {
'     unfoldLine(y1);
'     return;
'   }
'
'   n = y2 - y1 + 1;
'
'   for (i = 0; i < fold.count(); i++)
'   {
'     fp = fold.at(i);
'     if (y2 < fp->start)
'     {
'       fp->start -= n;
'       fp->end -= n;
'     }
'     else if (y1 > fp->end)
'       continue;
'     else
'     {
'       fold.remove(i);
'       i--;
'     }
'   }
' }
'

Private Sub _ExpandInsert(Y As Integer, N As Integer)
  
  Dim I As Integer
  
  If Not $aFold Then Return
  
  If N = 0 Then
    _ExpandRow(Y)
    Return
  Endif
  
  While I < $aFold.Count
    If $aFold[I] > Y Then
      $aFold[I] += N
      $aFold[I + 1] += N
      I += 2
    Else If $aFold[I + 1] >= Y Then
      '$aFold[I + 1] += N
      $aFold.Remove(I, 2)
    Else
      I += 2
    Endif
  Wend
  
  $cCacheView.Clear
  
End
'
' void GEditor::foldInsert(int y, int n)
' {
'   uint i;
'   GFoldedProc *fp;
'
'   if (getFlag(NoFolding))
'     return;
'
'   if (n == 0)
'   {
'     unfoldLine(y);
'     return;
'   }
'
'   for (i = 0; i < fold.count(); i++)
'   {
'     fp = fold.at(i);
'     if (fp->start > y)
'     {
'       fp->start += n;
'       fp->end += n;
'     }
'     else if (fp->end >= y)
'     {
'       fp->end += n;
'       fold.remove(i); //unfoldLine(fp->start);
'       i--;
'     }
'   }
' }
'

Private Sub MoveSelection(bUp As Boolean)
  
  Dim X, Y As Integer
  Dim X1, Y1, X2, Y2 As Integer
  Dim sText As String
  Dim bSelect As Boolean
  
  X = $X
  Y = $Y
  
  If Not HasSelection() Then
    X1 = 0
    Y1 = $Y
    If $Y < $hDoc.Max Then
      X2 = 0
      Y2 = $Y + 1
    Else
      X2 = $hDoc.LineLength[$Y]
      Y2 = $Y
    Endif
  Else
    bSelect = True
    GetSelection(ByRef X1, ByRef Y1, ByRef X2, ByRef Y2)
    X1 = 0
    If X2 > 0 And If Y2 < $hDoc.Max Then
      Inc Y2
      X2 = 0
    Endif
  Endif
  
  If bUp Then
    If Y1 = 0 Then Return
  Else
    If Y2 = $hDoc.Max Then Return
  Endif
  
  Goto(X1, Y1)
  Goto(X2, Y2, True)
  
  $hDoc.Begin
  
  sText = $hDoc.GetText(X1, Y1, X2, Y2)
  Remove(X1, Y1, X2, Y2)
  If bUp Then
    Dec Y1
    Dec Y2
  Else
    Inc Y1
    Inc Y2
  Endif
  Goto(X1, Y1)
  Insert(sText)
  
  If bSelect Then
    Goto(X1, Y1)
    Goto(X2, Y2, True)
  Else
    If bUp Then
      Goto(X, Y - 1)
    Else
      Goto(X, Y + 1)
    Endif
  Endif
  
  $hDoc.HighlightFrom($Y)
  
  $hDoc.End
  
End

Public Sub SaveCursor()
  
  If $iSaveCursor = 0 Then $aSaveCursor = [$X, $Y, $SX, $SY]
  Inc $iSaveCursor
  
End

Public Sub RestoreCursor()
  
  Dim X, Y, SX, SY As Integer
  
  Dec $iSaveCursor
  If $iSaveCursor Then Return
  
  X = $aSaveCursor[0]
  Y = $aSaveCursor[1]
  SX = $aSaveCursor[2]
  SY = $aSaveCursor[3]
  
  Goto(SX, SY)
  If X <> SX Or If Y <> SY Then Goto(X, Y, True)
  
End

Public Sub _UpdateLineHeight(Y As Integer)
  
  Dim sText As String
  Dim WMax As Integer
  Dim D, F, P As Integer
  Dim aLayout As Integer[]
  Dim W As Integer
  Dim L As Integer
  Dim S As Integer
  
  If Not $cLineLayout Then Return
  
  sText = $hDoc.Lines[Y]
  WMax = $hView.ClientW - $MW - 8
  
  'Print Y;
  
  aLayout = New Integer[]
  
  S = 1
  L = $hDoc.LineLength[Y]
  
  Do
    
    D = S
    F = L + 1
    
    While F > D + 1
      
      P = (D + F) \ 2
      W = TextWidth(sText, S, P - S + 1)
      If W > WMax Then
        F = P
      Else
        D = P
      Endif
      
    Wend
    
    If D >= L Then Break
    
    If String.Code(sText, D) > 32 Then
      ' For P = D - 1 DownTo S
      '   If InStr(" ,.;:-([])", String.Mid$(sText, P, 1)) Then
      '     Inc P
      '     Break
      '   Endif
      ' Next
      P = String.RInStr(sText, " ", D - 1)
      If P >= S And If Trim(String.Mid(sText, S, P - S + 1)) Then D = P
    Endif
    
    If aLayout.Count = 0 Then WMax -= LineStartPos(Y)
    aLayout.Add(D - S + 1)
    S = D + 1
    
    'sText = String.Mid$(sText, D + 1)
    'If Not sText Then Break
    
  Loop
  
  If aLayout.Count >= 1 Then
    $cLineLayout[Y] = aLayout
    $hRows._SetRowHeight(Y, aLayout.Count + 1)
    ' Print " -> [ ";
    ' For D = 0 To aLayout.Max
    '   Print aLayout[D];;
    ' Next
    ' Print "]"
  Else
    $cLineLayout[Y] = Null
    $hRows._SetRowHeight(Y, 1)
    'Print
  Endif
  
  If Y = $Y Then $XY = LinePos($Y, $X)
  If Y = $SY Then $SXY = LinePos($Y, $X)
  
  Try $cCachePos.Remove(Y)
  
End

Public Sub _UpdateAllHeight(Optional bNow As Boolean)
  
  Dim TY As Integer
  
  If Not $bUpdateHeightAllowed Then Return
  
  If Not $cLineLayout Then
    
    TY = $hRows._GetRowY($Y) - $hView.ScrollY
    $hRows.Clear
    _ClearCachePos
    $XY = LinePos($Y, $X)
    $SXY = LinePos($SY, $SX)
    $hView.ScrollY = $hRows._GetRowY($Y) - TY
    Return
    
  Endif
  
  If Not $hTimerHeight Then
    $hTimerHeight = New Timer As "TimerHeight"
    $hTimerHeight.Delay = 50
  Endif
  
  If bNow Then
    TimerHeight_Timer
  Else
    $hTimerHeight.Start
  Endif
  
End

Public Sub TimerHeight_Timer()
  
  Dim Y As Integer
  Dim CY, TY As Integer
  
  'Debug Me.Window.Title;; $iWidth;; $hView.ClientW
  
  If $hView.Scrolling Then Return
  
  Y = $hRows._GetRowY($Y)
  If Y < $hView.ScrollY Then
    TY = 0
    CY = PosToLine(TY)
  Else If Y + $LH >= $hView.ScrollY + $hView.ClientH Then
    TY = $hView.ClientH
    CY = PosToLine(TY)
  Else
    TY = Y - $hView.ScrollY
    CY = $Y
  Endif
  
  If $hDoc.Count >= 10000 Then Inc Application.Busy
  
  $bNoResizeContents = True
  For Y = 0 To $hDoc.Max
    _UpdateLineHeight(Y)
  Next
  $bNoResizeContents = False
  _ClearCachePos
  _ResizeContents
  
  $hView.ScrollY = $hRows._GetRowY(CY) - TY
  
  'EnsureVisible
  $hView.Refresh
  
  $XY = LinePos($Y, $X)
  $SXY = LinePos($SY, $SX)
  
  If $hTimerHeight Then
    $hTimerHeight.Stop
    $hTimerHeight = Null
  Endif
  
  If $hDoc.Count >= 10000 Then Dec Application.Busy
  
End

Private Function Wrap_Read() As Boolean
  
  Return $cLineLayout
  
End

Private Sub Wrap_Write(Value As Boolean)
  
  If Value Then
    If $cLineLayout Then Return
    $cLineLayout = New Collection
  Else
    If Not $cLineLayout Then Return
    $cLineLayout = Null
  Endif
  
  _UpdateAllHeight(True)
  CalcSizes
  EnsureVisible
  
End

' Public Sub Test()
'
'   Dim Y As Integer
'   Dim RY As Integer
'   Dim ORY As Integer = -1
'
'   For Y = 0 To 2500
'     RY = $hRows._GetRowY(Y)
'     If _IsRowVisible(Y) Then
'       Print Y; ": "; RY / $LH
'       'ORY = RY
'     Endif
'   Next
'
' End

Public Sub _GetRowHeight(Y As Integer) As Integer
  
  Return $hRows._GetRowHeight(Y)
  
End

' Public Sub _Lock()
'
'   Inc $iLock
'
' End
'
' Public Sub _Unlock()
'
'   Dec $iLock
'   If $iLock = 0 Then
'
'   Endif
'
' End
'
Public Sub Styles_Change()
  
  If $bStyleChanged Then Return
  $bStyleChanged = True
  ClearCacheText
  If $hLabelFrame Then
    $hLabelFrame.Background = $hStyles[Highlight.Background].Color
    $hLabel.Foreground = $hStyles[Highlight.Normal].Color
  Endif
  If $bShowPreview Then
    $hSideBar.Background = $hStyles[Highlight.Background].Color
    SyncSideBarViewerStyles
    $hTimerSideBarRefresh.Trigger
  Endif
  
End

Private Function ShowSpaces_Read() As Boolean
  
  Return $bShowSpaces
  
End

Private Sub ShowSpaces_Write(Value As Boolean)
  
  $bShowSpaces = Value
  $hView.Refresh
  
End

Private Function ShowIndent_Read() As Boolean
  
  Return $bShowIndent
  
End

Private Sub ShowIndent_Write(Value As Boolean)
  
  $bShowIndent = Value
  $hView.Refresh
  
End

' void GEditor::clearLine(bool before, bool after)
' {
'   int ox = x;
'
'   doc->begin();
'
'   if (before)
'   {
'     QString ins;
'
'     doc->remove(y, 0, y, x + 1);
'     ins.fill(' ', ox + 1);
'     doc->insert(y, 0, ins);
'     x = ox;
'   }
'
'   if (after)
'   {
'     doc->remove(y, x, y, doc->lineLength(y) -1);
'   }
'
'   doc->end();
' }
'
'

Private Sub ClearLine(bBefore As Boolean, bAfter As Boolean)
  
  Dim OX As Integer
  
  OX = $X
  
  $hDoc.Begin()
  
  If bBefore Then
    $hDoc.Remove(0, $Y, $X + 1, 0)
    $hDoc.Insert(Space$(OX + 1), 0, $Y)
    $X = OX
  Endif
  
  If bAfter Then
    $hDoc.Remove($X, $Y, $hDoc.LineLength[$Y], $Y)
  Endif
  
  $hDoc.End()
  
End

Private Sub RelGoto(DX As Integer, DY As Integer)
  
  Goto(Max(0, $X + DX), Max(0, $Y + DY))
  
End

Public Sub TimerCacheLine_Timer()
  
  ClearCacheLine
  $hTimerCacheLine.Stop
  
End

Private Sub ClearCacheLine()
  
  If $bRemoteDisplay Then Return
  $cCacheLine.Clear
  $iCacheLineH = 0
  
End

Private Sub ClearCacheText()
  
  If $bRemoteDisplay Then Return
  $cCacheText.Clear
  
End

Public Sub _HasFolding() As Boolean
  
  If $aFold And If $aFold.Count Then Return True
  
End

Private Sub DrawBarImage3()

  Dim aLines As String[]
  Dim H, F As Integer
  Dim I As Integer
  Dim N As Integer
  Dim iRow As Integer
  Dim aLineLength As Integer[]
  Dim iLen As Integer
  Dim Y As Integer
  Dim X As Integer
  Dim sLine As String
  Dim sIndent As String
  Dim aLinesInfo As CLineInfo[]
  Dim hInfo As CLineInfo
  Dim iCol As Integer
  Dim J As Integer
  Dim FX As Float
  Dim bModified As Boolean
  Dim bSaved As Boolean
  Dim iAlpha As Integer
  Dim iColComment As Integer
  Dim iColNormal As Integer
  Dim iColModified As Integer
  Dim iColSaved As Integer

  aLines = $hDoc.Lines
  aLineLength = $hDoc.LineLength
  aLinesInfo = $hDoc.LinesInfo
  
  N = _RealToView(aLines.Max)

  If N <= Paint.H Then
    F = 1
    H = Max(N, CInt(Paint.H / 2))
  Else
    F = CInt(N / Paint.H)
    H = (N + F - 1) \ F
  Endif
  
  FX = (Paint.w - 4) / 100 'Max(4, Min(8, F))
  
  iAlpha = 255 - 128 \ F
  iColComment = Color.SetAlpha($hStyles[Highlight.Comment].Color, iAlpha)
  iColNormal = Color.SetAlpha($hStyles[Highlight.Normal].Color, iAlpha)
  iColModified = Color.SetAlpha(Color.Merge($iBackground, Color.Red, 0.4), 128)
  iColSaved = Color.SetAlpha(Color.Merge($iBackground, Color.Green, 0.4), 128)
  
  $hImageSideBar = New Image(Paint.Width - 1, H, $hStyles[Highlight.Background].Color)
  Paint.Begin($hImageSideBar)
  
  For I = 0 To N Step F
    
    bModified = False
    bSaved = False

    Paint.FillRect(0, Y, 4, 1, $iMarginColor)
    
    For J = I To Min(N, I + F - 1)
    
      iRow = _ViewToReal(J)
      sLine = RTrim(aLines[iRow])
      iLen = Min(String.Len(sLine), 100)
      
      If sLine Then 
        
        sLine = RTrim(aLines[iRow])
        hInfo = aLinesInfo[iRow]
        
        X = 0
        
        If IsSpace(Left(sLine)) Then
          sIndent = GetLineIndentText(iRow)
          sIndent = Replace(sIndent, "\t", Space$($iTabSize))
          X = Len(sIndent)
        Endif
        
        If hInfo And If hInfo.Comment Then
          iCol = iColComment
        Else
          iCol = iColNormal
        Endif
        
        Paint.FillRect(X * FX + 5, Y, (iLen - X) * FX, 1, iCol)
        
      Endif
      
      If $bShowModified Then
        If Not bModified Then
          If hInfo Then
            If hInfo.Modified Then
              bModified = True
              Paint.FillRect(0, Y, Paint.W, 1, iColModified)
            Else If hInfo.Saved And If Not bSaved Then
              bSaved = True
              Paint.FillRect(0, Y, Paint.W, 1, iColSaved)
            Endif
          Endif
        Endif
      Endif
      
    Next
    
    Inc Y
      
  Next
  
  Paint.End

End

Public Sub SideBar_Draw()
  
  Dim D As Integer = Desktop.Scale * 2
  Dim NL, Row As Integer
  Dim X, Y, W, H As Integer
  Dim iBorder As Integer = IIf(System.RightToLeft, 0, 1)
  Dim iCount As Integer = _RealToView($hDoc.Max)

  NL = $hView.ClientH \ $hRows.H + 1
  Row = _RealToView($hRows._FindRowFromPos($hView.ScrollY))
  $fBarLineHeight = Min(2, Paint.Height / (iCount + 1))
  
  Paint.AntiAlias = False
  'Barre Cache
  If Not $hImageSideBar Then DrawBarImage3()
  Paint.DrawImage($hImageSideBar, iBorder, 0, Paint.W - 1, Paint.H)
  
  'Border Line
  Paint.FillRect(If(System.RightToLeft, Paint.W - 1, 0), 0, 1, Paint.H, $iLimitColor)
  
  'Arrow Buttons
  If $iSideBarClick <> SIDEBAR_VIEW And If $hSideBar.Hovered Then
    If $hView.ScrollY > 0 Then
      Paint.FillRect(iBorder, 0, Paint.W - 1, D, Color.Background)
      Style.PaintArrow((Paint.W - D) / 2, 0, D, D, Align.Top) ' If($iSideBarStyle = 1, Style.Hovered, 0))
    Endif
    If $hView.ScrollY < $hView.ScrollHeight - $hView.ClientHeight Then
      Paint.FillRect(iBorder, Paint.H - D, Paint.W - 1, D, Color.Background)
      Style.PaintArrow((Paint.W - D) / 2, Paint.H - D, D, D, Align.Bottom) ', If($iSideBarStyle = 2, Style.Hovered, 0))
    Endif
  Endif
  
  'ViewPort Rectangle
  $rectSideBar = Rect(iBorder, $fBarLineHeight * Row, Paint.Width - 1, Max($fBarLineHeight * NL, 10))
  Paint.Rectangle(iBorder, $fBarLineHeight * Row, Paint.Width - 1, $rectSideBar.Height)
  Paint.Background = Color.SetAlpha(Color.SelectedBackground, 128)
  Paint.Fill()
  
  'Draw the Tooltip
  If $iSideBarClick Then
    Paint.AntiAlias = True
    Paint.Background = Color.TooltipBackground
    W = Paint.Font.TextWidth(CStr(Row) & "00")
    H = Paint.Font.H * 2.8
    
    Y = $iMY + D
    If Y + H > Paint.H Then Y = Max(0, $iMY - H - D)
    
    'Y = Max(0, IIf(Paint.Height - ($iMY + (Paint.Font.H * 3 + 6)) < 0, $iMY - ((Paint.Font.H * 3 + 6)), $iMY - H))
    X = IIf(System.RightToLeft, Paint.Width - W - 3, 3)
    Paint.Rectangle(X, Y, W, H, Paint.Font.H / 4)
    Paint.Fill
    'Paint.Font.Grade = - 1
    Paint.Background = Color.TooltipForeground
    'Paint.DrawText(_ViewToReal((Row + 1)) & "\n-\n" & _ViewToReal(Min((Row + NL), iCount)), X + 3, y + 3, W - 6, H - 6, Align.Center)
    Paint.DrawText(CStr(PosToLine(0) + 1), X, Y, W, H \ 2, Align.Center)
    Paint.DrawText(CStr(PosToLine($hView.ClientH - $LH \ 2) + 1), X, Y + H - H \ 2, W, H \ 2, Align.Center)
    Paint.FillRect(X + D / 4, Y + H \ 2, W - D / 2, 1, Color.SetAlpha(Color.TooltipForeground, 128))
  Endif
  
End

Private Sub SideBarClick(Y As Integer)
  
  $iMY = Y
  Y = Min(Max(0, Floor(((Y - $iMD)) / $fBarLineHeight)), _RealToView($hDoc.Max))
  Me.GotoCenter(0, _ViewToReal(Y))
  
End

Public Sub SideBar_MouseMove()
  
  Dim iCurLine As Integer
  Dim X As Integer
  Dim D As Integer = Desktop.Scale * 2
  Dim iCount As Integer = _RealToView($hDoc.Max)
  Dim iWhere As Integer
  
  If Mouse.Y < D Then
    iWhere = SIDEBAR_UP
  Else If Mouse.Y > Last.ClientH - D Then
    iWhere = SIDEBAR_DOWN
  Else
    iWhere = SIDEBAR_VIEW
  Endif
  
  If iWhere <> $iSideBarWhere Then
    $iSideBarWhere = iWhere
    $hSideBar.Refresh
  Endif

  Select Case $iSideBarClick

    Case SIDEBAR_VIEW 
      $hSideBarViewer.Hide
      SideBarClick(Mouse.Y)    

    Case SIDEBAR_UP, SIDEBAR_DOWN
      $hSideBarViewer.Hide
      
    Case Else
      
      If Not $hSideBarViewer.Visible Then UpdatePreviewViewer
      iCurLine = _ViewToReal(Min(Max(0, Floor((Mouse.Y - $iMD) / $fBarLineHeight)), iCount))
      $hSideBarViewer.GotoCenter(0, iCurLine)
      X = IIf(System.RightToLeft, $hSideBar.Left + $hSideBar.Width, $hSideBar.Left - $hView.Width / 2)
      $hSideBarViewer.Move(X, Min(Max(1, Mouse.Y - ($hView.Height / 5) / 2), $hSideBar.Height - $hSideBarViewer.Height))
      $hSideBarViewer.Raise
      $hSideBarViewer.Show
      
  End Select

  ' If Mouse.Y > $fBarLineHeight * iCount Then
  '   If Not $bSideBarLockViewer Then $hSideBarViewer.Hide
  ' Else
  '   If $iMD > 0 Then
  '     If Not $bSideBarLockViewer Then $hSideBarViewer.Hide
  '   Else
  '     If Not $bSideBarLockViewer Then
  '       If $hSideBarViewer.Visible Then
  '         X = IIf(System.RightToLeft, $hSideBar.Left + $hSideBar.Width, $hSideBar.Left - $hView.Width / 2)
  '         $hSideBarViewer.Move(X, Min(Max(1, Mouse.Y - ($hView.Height / 5) / 2), $hSideBar.Height - $hSideBarViewer.Height))
  '         $hSideBarViewer.Raise
  '         'iCurLine = Min(Max(0, Floor(((Mouse.y - $iMD)) / $fBarLineHeight)), iCount)
  '         iCurLine = _ViewToReal(Min(Max(0, Floor((Mouse.Y - $iMD) / $fBarLineHeight)), iCount))
  '         'If $hSideBarViewer.Line <> iCurLine Then
  '         $hSideBarViewer.GotoCenter(0, iCurLine)
  '         '$hSideBarViewer.Tag = iCurLine
  '         'Endif
  '       Endif
  '     Endif
  '   Endif
  '   
  '   $iMY = Mouse.Y
  '   If Mouse.Left Then
  '     $bSideBarMouseDown = True
  '     If $iMD = 0 Then
  '       If $rectSideBar.Contains(Mouse.x, Mouse.y) Then
  '         If Not $bSideBarLockViewer Then $hSideBarViewer.Hide
  '         $iMD = Mouse.y - $rectSideBar.Top
  '       Endif
  '     Endif
  '   Endif
  '   
  ' Endif
  
End

Public Sub SideBar_Enter()
  
  $hSideBar.Refresh
  
End


Public Sub SideBar_Leave()
  
  $iSideBarWhere = SIDEBAR_NONE
  $iSideBarClick = SIDEBAR_NONE
  $hSideBar.Refresh
  '$hTimerSideBarViewer.Stop
  If Not $bSideBarLockViewer Then $hSideBarViewer.Hide
  
End

Public Sub TimerSideBarMouse_Timer()

  Dim DY As Integer
  
  DY = If($iSideBarClick = SIDEBAR_DOWN, $LH, - $LH)
  
  If $hView.ScrollY + DY < 0 Or If $hView.ScrollY + DY >= $hView.ScrollH Then
    Try $hTimerSideBarMouse.Stop
    $hTimerSideBarMouse = Null
  Else
    $hView.ScrollY += DY
    If Not $hTimerSideBarMouse Then
      $hTimerSideBarMouse = New Timer As "TimerSideBarMouse"
      $hTimerSideBarMouse.Delay = 250
      $hTimerSideBarMouse.Start
    Else If $hTimerSideBarMouse.Delay <> 10 Then
      $hTimerSideBarMouse.Delay = 10
      $hTimerSideBarMouse.Restart
    Endif
  Endif
  
End

Public Sub SideBar_MouseDown()
  
  If Mouse.Left Then
    
    SideBar_MouseMove
    $iSideBarClick = $iSideBarWhere
    
    Select Case $iSideBarClick
      
      Case SIDEBAR_UP, SIDEBAR_DOWN
        TimerSideBarMouse_Timer
        
      Case Else
        SideBarClick(Mouse.Y)
        
    End Select
    
    ' If $iSideBarStyle > 0 Then
    '   If Not $bSideBarLockViewer Then $hSideBarViewer.Hide
    '   Select Case $iSideBarStyle
    '     Case 1
    '       $hView.ScrollY -= $LH
    '     Case 2
    '       $hView.ScrollY += $LH
    '   End Select
    ' Else
    '   
    '   If $rectSideBar.Contains(Mouse.x, Mouse.y) Then
    '     If Not $bSideBarLockViewer Then $hSideBarViewer.Hide
    '     $iMD = Mouse.y - $rectSideBar.Top
    '   Else
    '     SideBarClick(Mouse.Y)
    '     $bSideBarMouseDown = True
    '     $iMY = Mouse.Y
    '   Endif
    '   
    ' Endif
  Endif
  
  ' If Mouse.Middle Then
  '   If $iSideBarStyle > 0 Then
  '     If $iSideBarStyle = 1 Then
  '       Me.GotoCenter($SX, 0)    
  '     Else
  '       Me.GotoCenter($SX, $hDoc.Count)
  '     Endif
  '   Else
  '     If $hSideBarViewer.Visible Then $bSideBarLockViewer = Not $bSideBarLockViewer
  '   Endif
  ' Endif
  
End

Public Sub SideBar_MouseUp()
  
  $iSideBarClick = SIDEBAR_NONE
  $iMD = 0
  '$iMY = -1
  Try $hTimerSideBarMouse.Stop
  $hTimerSideBarMouse = Null
  $hSideBar.Refresh
  
End

Public Sub SideBar_MouseWheel()
  'C'est po bien !!!! Mais bon.
  
  $hView.DrawingArea_MouseWheel
  
End

Public Sub TimerRefreshBar_Timer()
  
  $hImageSideBar = Null
  If $bShowPreview Then
    $hTimerSideBarRefresh.Stop
    $hSideBar.Refresh
    UpdatePreviewViewer
  Endif
  
End

Public Sub SideBar_Arrange()
  
  $hTimerSideBarRefresh.Restart
  
End

Private Function ShowPreview_Read() As Boolean
  
  Return $bShowPreview
  
End

Private Sub UpdateSideBarFont()
  
  Dim hFont As Font
  
  If Not $hSideBarViewer Then Return
  
  hFont = Me.Font.Copy()
  hFont.Grade -= 2
  $hSideBarViewer.Font = hFont
  
End

Private Sub ShowPreview_Write(Value As Boolean)
  
  If $bShowPreview = Value Then Return
  $bShowPreview = Value
  If Value Then
    $hTimerSideBarRefresh = New Timer As "TimerRefreshBar"
    $hTimerSideBarRefresh.Delay = 250
    ' $hTimerSideBarViewer = New Timer As "TimerShowPreviewViewer"
    ' $hTimerSideBarViewer.Delay = 100
    
    $hSideBarViewer = New TextEditor(Me) As "SideBarViewer"
    $hSideBarViewer.Hide
    $hSideBarViewer.ReadOnly = True
    SyncSideBarViewerStyles
    $hSideBarViewer.ShowCursor = False
    $hSideBarViewer.Ignore = True
    $hSideBarViewer.Enabled = False
    $hSideBarViewer.ScrollBar = Scroll.None
    ScrollArea($hSideBarViewer.Proxy).NoShadow = True
    
    $hSideBar = New DrawingArea($hPanel) As "SideBar"
    $hSideBar.Width = Desktop.Scale * 8
    $hSideBar.Background = $hStyles[Highlight.Background].Color
    $hSideBar.Tracking = True
    
    UpdateSideBarFont
    
    ScrollBar_Write($iScrollBar)
    
  Else
    If $hSideBar Then
      $hSideBar.Hide
      $hSideBar.Delete
      $hSideBar = Null
      $hTimerSideBarRefresh.Stop
      $hTimerSideBarRefresh = Null
      $hSideBarViewer.Delete
      $hSideBarViewer = Null
      '$hTimerSideBarViewer.Stop
      '$hTimerSideBarViewer = Null
      ScrollBar_Write($iScrollBar)
    Endif
  Endif
  
End

Private Sub SyncSideBarViewerStyles()
  
  Dim i As Integer
  
  For i = 0 To 31
    If IsNull($hSideBarViewer.Styles[i]) Or If IsNull($hStyles[i]) Then Continue
    $hSideBarViewer.Styles[i].Underline = $hStyles[i].Underline
    $hSideBarViewer.Styles[i].Bold = $hStyles[i].Bold
    $hSideBarViewer.Styles[i].Color = $hStyles[i].Color
  Next
  
  With $hSideBarViewer
    .ShowExpand = Me.ShowExpand
    .ShowIcon = Me.ShowIcon
    .ShowIndent = Me.ShowIndent
    .ShowLimit = Me.ShowLimit
    .ShowLineNumber = Me.ShowLineNumber
    .ShowModified = Me.ShowModified
    .ShowSpaces = Me.ShowSpaces
    .Highlight = Me.Highlight
  End With
  
End

' Public Sub TimerShowPreviewViewer_Timer()
'   
'   $hSideBarViewer.Move($hSideBar.Left - $hView.Width / 2, Min(Max(1, $iMY - ($hView.Height / 5) / 2), $hSideBar.Height - $hSideBarViewer.Height), $hView.Width / 2, $hView.Height / 5)
'   $iSideBarNBLines = Ceil(($hSideBarViewer.ClientH / $hSideBarViewer.LineHeight) / 2)
'   $hSideBarViewer.View = Me
'   $hSideBarViewer._SyncFolding()
'   $hSideBarViewer.Show
'   '$hSideBarViewer.ShowExpand = True
'   $hSideBarViewer.Raise
'   $hTimerSideBarViewer.Stop
'   
' End

Public Sub UpdatePreviewViewer()
  
  $hSideBarViewer.Resize($hView.Width / 2, $hView.Height / 5)
  $hSideBarViewer.View = Me
  $hSideBarViewer._SyncFolding()
  ' $hSideBarViewer.Show
  ' '$hSideBarViewer.ShowExpand = True
  ' $hSideBarViewer.Raise
  ' '$hTimerSideBarViewer.Stop
  
End

Public Sub SideBarViewer_MouseDown()
  
  $hSideBarViewer.Hide
  $bSideBarLockViewer = False
  
End

Public Sub SideBar_Menu()
  
  Stop Event
  
End

Public Sub _SyncFolding()
  
  Dim I As Integer
  Dim hSrc As TextEditor
  
  hSrc = Me.View
  If hSrc = Me Then Return
  
  ExpandAll
  Repeat
    If Not hSrc[I].Expanded Then
      _CollapseRow(I)
    Endif
    I = hSrc.FindNextLimit(I)
  Until I < 0
  
End

Private Function Mode_Read() As String

  Return $hDoc.Mode

End

Private Sub Mode_Write(Value As String)

  $hDoc.Mode = Value

End

Private Function CloseBraces_Read() As Boolean

  Return $hDoc.CloseBraces

End

Private Sub CloseBraces_Write(Value As Boolean)

  $hDoc.CloseBraces = Value

End

Private Function TabIndent_Read() As Boolean

  Return $bTabIndent

End

Private Sub TabIndent_Write(Value As Boolean)

  $bTabIndent = Value

End

Private Sub RefreshSideBar()

  If $bShowPreview Then $hTimerSideBarRefresh.Restart

End

Public Sub GetIndent(StartLine As Integer, Optional EndLine As Integer) As String
  
  If EndLine = 0 Then EndLine = StartLine + 1
  Return $hDoc.GetIndentText(StartLine, EndLine)
  
End

Public Sub GetHighlight(Y As Integer, ByRef Symbols As String[], ByRef Types As Integer[])
  
  Dim aColors As Byte[]
  Dim sLine As String
  Dim I As Integer
  Dim P As Integer
  
  $hDoc.HighlightFrom(Y)
  Try aColors = $hDoc.LinesInfo[Y].Colors
  If Not aColors Then Return
  
  Symbols = New String[]
  Types = New Integer[]
  
  sLine = $hDoc.Lines[Y]
  P = 1
  For I = 0 To aColors.Max Step 2
    Types.Add(aColors[I])
    Symbols.Add(String.Mid$(sLine, P, aColors[I + 1]))
    P += aColors[I + 1]
  Next
  
End

Private Function DisabledBreakpoints_Read() As Integer[]

  Return $hDoc.DisabledBreakpoints  

End

Private Sub DisabledBreakpoints_Write(Value As Integer[])

  $hDoc.DisabledBreakpoints = Value

End

Public Sub HighlightString(Text As String, Optional IgnoreCase As Boolean, Optional WordOnly As Boolean)
  
  $sHighlightString = Text
  $iHighlightStringLen = String.Len(Text)
  $iHighlightStringMode = If(IgnoreCase, gb.IgnoreCase, gb.Binary)
  $bHighlightWordOnly = WordOnly
  
  ClearCacheLine
  $hView.Refresh
  
End

Private Sub IsWordLimit(sCar As String) As Boolean
  
  sCar = String.RemoveDiacritics(sCar)
  If IsLetter(sCar) Or IsDigit(sCar) Or If InStr("_$", sCar) Then Return
  Return True
  
End


Private Function LastLine_Read() As Integer

  Return $LY

End

Private Function LastColumn_Read() As Integer

  Return $LX

End

Private Function CloseStrings_Read() As Boolean

  Return $hDoc.CloseStrings

End

Private Sub CloseStrings_Write(Value As Boolean)

  $hDoc.CloseStrings = Value

End
