' Gambas class file

Event Fake

Property Text As String
Property Read Count As Integer
Property Read Max As Integer
Property Read Current As TextEditor
Property Highlight As String
Property Read Length As Integer
Property Read Keywords As String[]
Property Breakpoints As Integer[]
Property Bookmarks As Integer[]
Property EndOfLine As Integer

Public Lines As String[]
Public LinesInfo As CLineInfo[]
Public LineLength As Integer[]

Public XAfter As Integer
Public YAfter As Integer

Private $aUndo As New CCommand[]
Private $aRedo As New CCommand[]
Private $iNoUndo As Integer

Private $hDefaultInfo As New CLineInfo

Private $hHighlight As TextHighlighter

Private $bHighlighting As Boolean
Private $cHighlightLater As Collection
Private $iNoHighlight As Integer
Private $iBegin As Integer

Private $iEndOfLine As Integer = gb.Unix
Private $sEndOfLine As String = "\n"

Public Sub _new()
  
  Clear
  
End

Public Sub Clear()
  
  Lines = New String[1]
  LinesInfo = New CLineInfo[1]
  LineLength = New Integer[1]
  $aUndo.Clear
  $aRedo.Clear
  $iBegin = 0
  $iNoHighlight = 0
  $cHighlightLater = Null
  
End

Private Function Text_Read() As String

  Return Lines.Join($sEndOfLine)

End

Private Sub UpdateLineLength()

  Dim I As Integer

  LineLength = New Integer[Lines.Count]
  For I = 0 To Lines.Max
    LineLength[I] = String.Len(Lines[I])
  Next

End

Private Sub Text_Write(Value As String)

  Clear

  If Value Then
    Lines = Split(Value, "\n")
    LinesInfo = New CLineInfo[Lines.Count]
    UpdateLineLength
    HighlightFrom(0)
    LayoutLines
  Endif
  
End

Private Sub LayoutLines()

  Dim hView As TextEditor

  For Each hView In GetAllViews()
    hView._UpdateAllHeight
  Next

End

Public Sub Load(sPath As String, bAddNewLine As Boolean)

  Dim hFile As File
  Dim sLine As String
  
  hFile = Open sPath
  
  Clear
  Lines.Clear
  
  For Each sLine In hFile.Lines
    Lines.Add(sLine)
  Next
  
  If Not hFile.EndOfFile Then 
    Lines.Add("")
  Else If bAddNewLine And If Trim(sLine) Then 
    Lines.Add("")
  Endif
  
  LinesInfo = New CLineInfo[Lines.Count]
  UpdateLineLength
  HighlightFrom(0)
  LayoutLines
  
End

Public Sub Save(sPath As String)

  Dim hFile As File
  Dim I As Integer
  
  hFile = Open sPath For Create
  hFile.EndOfLine = $iEndOfLine
  For I = 0 To Lines.Max - 1
    Print #hFile, Lines[I]
  Next
  Print #hFile, Lines[Lines.Max];
  
  Close #hFile
  
  Reset(True)
  
End


Private Function Count_Read() As Integer

  Return Lines.Count

End

Private Function Max_Read() As Integer

  Return Lines.Max

End

Public Sub Begin()

  If $iNoUndo Then Return
  Inc $iBegin
  AddUndo(CCommand(Me, CCommand.BEGIN,, Me.Current.Column, Me.Current.Line))
  DisableHighlight
  
End

Public Sub End()
  
  If $iNoUndo Then Return
  If $iBegin = 0 Then Error.Raise("Missing call to Begin")
  Dec $iBegin
  EnableHighlight
  AddUndo(CCommand(Me, CCommand.END,, Me.Current.Column, Me.Current.Line))
  
  CheckUnlock
  
End

Private Function Current_Read() As TextEditor

  Return Object.Parent(Me)

End

Private Sub GetAllViews() As TextEditor[]

  Return Me.Current._GetViews()  
  
End

Public Sub Refresh(Optional Y As Integer = -1)
  
  Dim hView As TextEditor
  
  If Y < 0 Then
    For Each hView In GetAllViews()
      hView.Refresh
    Next
  Else
    For Each hView In GetAllViews()
      hView._RefreshLine(Y)
    Next
  Endif
  
End

Private Sub InsertLine(Y As Integer)
  
  Lines.Add("", Y)
  LineLength.Add(0, Y)
  LinesInfo.Add(CLineInfo(), Y)
  LinesInfo[Y].Modified = True
  
End

' void GDocument::insertLine(int y)
' {
'   lines.insert(y, new GLine());
'   modifyLine(lines.at(y), y);
'   FOR_EACH_VIEW(v) { v->lineInserted(y); }
' }

Public Sub SetLine(Y As Integer, sLine As String, Optional bNoRefresh As Boolean)

  Dim hView As TextEditor
  
  If Info(Y).Colors Then SetInfo(Y).ClearHighlight
  If sLine = Lines[Y] Then Return
  
  Lines[Y] = sLine
  LineLength[Y] = String.Len(sLine)
  SetInfo(Y).Modified = True
  
  For Each hView In GetAllViews()
    hView._ClearCachePos(Y)
    hView._UpdateLineHeight(Y)
    hView._RaiseChange
  Next
  
  If Not bNoRefresh Then Refresh(Y)
  
End

Public Sub Insert(sText As String, X As Integer, Y As Integer)
  
  Dim iLen As Integer
  Dim sRest As String
  Dim aText As String[]
  Dim I, N As Integer
  Dim sLine As String
  Dim hView As TextEditor
  Dim XO, YO As Integer
  Dim bHighlight As Boolean
  Dim YA As Integer
  Dim XA As Integer
  
  If Not sText Then Return
  
  'Debug X;; Y;; Quote(sText);; System.Backtrace.Join(" ")
  
  XO = X
  YO = Y
  
  ' While Y >= Lines.Count
  '   InsertLine(Lines.Count)
  '   Inc N
  ' Wend
  
  iLen = LineLength[Y]
  If X > iLen Then SetLine(Y, Lines[Y] & Space$(X - iLen), True)
  
  sRest = String.Mid$(Lines[Y], X + 1)
  aText = Split(sText, "\n")
  
  N = aText.Max
  
  If N > 0 Then
    For Each hView In GetAllViews()
      hView._BeforeInsert(YO, N)
    Next
  Endif
  
  
  For I = 0 To aText.Max - 1
    
    SetLine(Y, String.Left(Lines[Y], X) & aText[I], True)
    X = 0
    Inc Y
    InsertLine(Y)
    bHighlight = True
    
  Next
  
  sLine = String.Left(Lines[Y], X) & aText[aText.Max]
  XA = String.Len(sLine)
  YA = Y
  SetLine(Y, sLine & sRest, True)
  
  XAfter = XA
  YAfter = YA
  
  If $iNoUndo = 0 Then 
    AddUndo(CCommand(Me, CCommand.INSERT, sText, XO, YO, XA, YA))
  Endif
  
  For Each hView In GetAllViews()
    If N > 0 Then
      hView._ClearCachePos
      hView._RaiseChange
      hView.Refresh
    Else
      hView._RefreshLine(YO)
    Endif
    hView._AfterInsert(YO, YAfter, N)
  Next
  
  If bHighlight Then HighlightFrom(YO)
  
  XAfter = XA
  YAfter = YA
  
End

' 
' void GDocument::insert(int y, int x, const GString &text, bool doNotMove)
' {
'   int pos;
'   int len;
'   int pos2;
'   int xs, ys;
'   GLine *l;
'   int n = 1;
'   int nl = 0;
'   GString rest;
'   int yy;
'   int i, ns;
'   GCommandDocument info(this);
' 
'   if (readOnly || text.length() == 0)
'   {
'     xAfter = x;
'     yAfter = y;
'     return;
'   }
' 
'   FOR_EACH_VIEW(v)
'   {
'     v->nx = v->x;
'     v->ny = v->y;
'   }
' 
'   disableColorize();
'   
'   while (y >= (int)lines.count())
'   {
'     yy = (int)lines.count();
'     insertLine(yy);
'     nl++;
'   }
' 
'   l = lines.at(y);
'   
'   ns = x - (int)l->s.length();
'   if (ns > 0)
'   {
'     GString str;
'     
'     for (i = 0; i < ns; i++)
'       str.append(' ');
'     
'     insert(y, x - ns, str, doNotMove);
'   }
' 
'   xs = x;
'   ys = y;
'   pos = 0;
' 
'   for(;;)
'   {
'     pos2 = text.findNextLine(pos, len);
' 
'     l = lines.at(y);
' 
'     if (len > 0)
'     {
'       l->insert(x, text.mid(pos, len));
'       modifyLine(l, y);
' 
'       //maxLength = GMAX(maxLength, (int)l->s.length());
'       //updateLineWidth(y);
' 
'       FOR_EACH_VIEW(v)
'       {
'         if (v->ny == y && v->nx >= x)
'           v->nx += len;
'       }
' 
'       x += len;
'     }
' 
'     pos = pos2;
' 
'     if (pos == 0)
'       break;
' 
'     if (x < (int)l->s.length())
'     {
'       rest = l->s.mid(x);
' 
'       l->s.remove(x, rest.length());
'       modifyLine(l, y);
'     }
' 
'     FOR_EACH_VIEW(v)
'     {
'       if (v->ny >= y)
'         v->ny++;
'     }
' 
'     y++;
' 
'     insertLine(y);
'     nl++;
' 
'     n = -1;
'     x = 0;
' 
'   }
' 
'   if (n < 0 && rest.length())
'   {
'     l->insert(x, rest);
'     modifyLine(l, y);
'     //maxLength = GMAX(maxLength, (int)l->s.length());
'     //updateLineWidth(y);
'   }
' 
'   FOR_EACH_VIEW(v)
'   {
'     v->foldInsert(ys, nl);
'   }
'   
'   begin();
'   addUndo(new GInsertCommand(&info, ys, xs, y, x, text));
'   enableColorize();
'   end();
' 
'   updateViews(ys, n);
' 
'   yAfter = y;
'   xAfter = x;
' 
'   emitTextChanged();
' 
'   if (!doNotMove)
'   {
'     FOR_EACH_VIEW(v)
'     {
'       v->cursorGoto(v->ny, v->nx, FALSE);
'     }
'   }
' }
' 

' Private Sub RemoveLine(Y As Integer)
'   
'   Lines.Remove(Y)
'   LinesInfo.Remove(Y)
'   
' End


' void GDocument::removeLine(int y)
' {
'   lines.remove(y);
'   COLORIZE_FROM(y);
'   FOR_EACH_VIEW(v) { v->lineRemoved(y); }
' }
' 

Public Sub Remove(X1 As Integer, Y1 As Integer, X2 As Integer, Y2 As Integer)

  Dim sText As String
  Dim hView As TextEditor
  Dim bHighlight As Boolean
  
  sText = GetText(X1, Y1, X2, Y2)
  
  If Y1 > Y2 Then
    Swap X1, X2
    Swap Y1, Y2
  Endif
  
  If Y1 = Y2 Then
    
    If X1 > X2 Then
      Swap X1, X2
    Endif
  
    If X2 > X1 And If X1 < LineLength[Y1] Then
      
      SetLine(Y1, String.Left(Lines[Y1], X1) & String.Mid$(Lines[Y1], X2 + 1))
      
    Endif
  
  Else If Y1 < Y2 Then
    
    bHighlight = True
    
    SetLine(Y1, String.Left(Lines[Y1], X1) & String.Mid$(Lines[Y2], X2 + 1), True)
    
    Lines.Remove(Y1 + 1, Y2 - Y1)
    LinesInfo.Remove(Y1 + 1, Y2 - Y1)
    LineLength.Remove(Y1 + 1, Y2 - Y1)
    
    For Each hView In GetAllViews()
      hView._RaiseChange
    Next
  
    Refresh
  
  Endif
  
  XAfter = X1
  YAfter = Y1
  
  If $iNoUndo = 0 Then
    AddUndo(CCommand(Me, CCommand.DELETE, sText, X1, Y1, X2, Y2))
  Endif
  
  For Each hView In GetAllViews()
    hView._AfterRemove(Y1, Y2)
    If Y2 > Y1 Then hView._ClearCachePos
  Next
  
  If bHighlight Then
    HighlightFrom(Y1)
    XAfter = X1
    YAfter = Y1
  Endif
  
End


' void GDocument::remove(int y1, int x1, int y2, int x2)
' {
'   GLine *l, *l2;
'   GString text, rest;
'   int y;
'   GCommandDocument info(this);
' 
'   yAfter = y1;
'   xAfter = x1;
' 
'   if (readOnly)
'     return;
'   
'   FOR_EACH_VIEW(v)
'   {
'     v->nx = v->x;
'     v->ny = v->y;
'   }
'   
'   disableColorize();
'   
'   l = lines.at(y1);
' 
'   if (y1 == y2)
'   {
'     if (x2 >= x1 && x1 < lineLength(y1))
'     {
'       text = l->s.mid(x1, x2 - x1);
' 
'       l->s.remove(x1, x2 - x1);
'       if (text.hasUnicode())
'         l->unicode = l->s.hasUnicode();
' 
'       modifyLine(l, y1);
' 
'       FOR_EACH_VIEW(v)
'       {
'         v->foldRemove(y1);
'         if (v->ny == y1 && v->nx > x1)
'           v->nx = GMAX(x1, v->nx - (x2 - x1));
'       }
' 
'       updateViews(y1);
'     }
'   }
'   else
'   {
'     l2 = lines.at(y2);
'     text = l->s.mid(x1) + _eol;
'     rest = l2->s.left(x2);
' 
'     if (x1 < (int)l->s.length() || x2 < (int)l2->s.length())
'     {
'       l->s = l->s.left(x1) + lines.at(y2)->s.mid(x2);
'       l->state = 0; // force highlighting of next line.
'       modifyLine(l, y1);
'     }
'     else
'       updateLineWidth(y1);
' 
'     for (y = y1 + 1; y < y2; y++)
'       text += lines.at(y)->s + _eol;
'     text += rest;
' 
'     for (y = y1 + 1; y <= y2; y++)
'     {
'       removeLine(y1 + 1);
'     }
' 
'     FOR_EACH_VIEW(v)
'     {
'       v->foldRemove(y1 + 1, y2);
'       if (v->ny > y1)
'       {
'         v->ny = GMAX(y1, v->ny - (y2 - y1));
'         if (v->ny == y1)
'           v->nx = x1;
'       }
'       else if (v->ny == y1 && v->nx > x1)
'         v->nx = x1;
'     }
' 
'     updateViews(y1, -1);
'   }
' 
'   begin();
'   addUndo(new GDeleteCommand(&info, y1, x1, y2, x2, text));
'   enableColorize();
'   end();
' 
'   FOR_EACH_VIEW(v)
'   {
'     v->cursorGoto(v->ny, v->nx, false);
'   }
'   
'   emitTextChanged();
' }

Public Sub Info(Y As Integer) As CLineInfo

  Dim hInfo As CLineInfo

  hInfo = LinesInfo[Y]
  If Not hInfo Then 
    hInfo = $hDefaultInfo
  Endif
  Return hInfo

End

Public Sub SetInfo(Y As Integer) As CLineInfo
  
  Dim hInfo As CLineInfo

  hInfo = LinesInfo[Y]
  If Not hInfo Then 
    hInfo = CLineInfo()
    LinesInfo[Y] = hInfo
  Endif
  
  Return hInfo
  
End

Public Sub GetText(X1 As Integer, Y1 As Integer, X2 As Integer, Y2 As Integer) As String
  
  Dim sText As String
  
  If Y1 > Y2 Or If Y1 = Y2 And X1 > X2 Then
    Swap X1, X2
    Swap Y1, Y2
  Endif
  
  If Y1 = Y2 Then Return String.Mid$(Lines[Y1], X1 + 1, X2 - X1)
  
  sText = String.Mid$(Lines[Y1], X1 + 1) & "\n"
  If (Y2 - Y1 - 1) > 0 Then sText &= Lines.Copy(Y1 + 1, Y2 - Y1 - 1).Join("\n") & "\n"
  sText &= String.Left(Lines[Y2], X2)

  Return sText
  
End


Private Sub AddUndo(hCmd As CCommand)

  If $iNoUndo Then Return
  
  'hCmd.Print("AddUndo: ")
  
  If hCmd.Type = CCommand.END And If $aUndo.Count And If $aUndo[$aUndo.Max].Type = CCommand.Begin Then
    $aUndo.Pop
  Else
    $aUndo.Add(hCmd)
  Endif
  
  $aRedo.Clear

End

Public Sub Undo()
  
  Dim hCmd As CCommand
  Dim L As Integer
  Dim bOverwrite As Boolean
  
  If $aUndo.Count = 0 Then Return
  
  DisableUndo
  DisableHighlight
  
  bOverwrite = Me.Current.Overwrite
  Me.Current.Overwrite = False
  
  Repeat
  
    hCmd = $aUndo.Pop()
    
    'Print "Undo: ";
    'hCmd.Print
    
    With hCmd
      
      Select Case .Type
        
        Case CCommand.BEGIN
          .MoveCursor(Me)
          Dec L
        
        Case CCommand.END
          Inc L
        
        Case CCommand.INSERT
          Me.Current.Remove(.X, .Y, .XA, .YA)
          'If .SX <> .X Or If .SY <> .Y Then 
          '  Me.Current.Goto(.SX, .SY)
          '  Me.Current.Goto(.X, .Y, True)
          'Endif
          
        Case CCommand.DELETE
          Me.Current.Goto(.X, .Y)
          Me.Current.Insert(.Text)
          If .SX <> .XA Or If .SY <> .YA Then 
            Me.Current.Goto(.SX, .SY)
            Me.Current.Goto(.XA, .YA, True)
          Endif
        
      End Select
  
    End With
    
    $aRedo.Add(hCmd)
    
  Until L = 0
  
  Me.Current.Overwrite = bOverwrite
  
  EnableUndo
  EnableHighlight
  
End

Public Sub Redo()
  
  Dim hCmd As CCommand
  Dim L As Integer
  Dim bOverwrite As Boolean
  
  If $aRedo.Count = 0 Then Return
  
  DisableUndo
  DisableHighlight
  
  bOverwrite = Me.Current.Overwrite
  Me.Current.Overwrite = False
  
  Repeat
  
    hCmd = $aRedo.Pop()
    
    'Print "Redo: ";
    'hCmd.Print
    
    With hCmd
      
      Select Case .Type
        
        Case CCommand.BEGIN
          Inc L
          
        Case CCommand.END
          .MoveCursor(Me)
          Dec L
        
        Case CCommand.DELETE
          ' If .SX <> .X Or If .SY <> .Y Then 
          '   Me.Current.Goto(.SX, .SY)
          '   Me.Current.Goto(.X, .Y, True)
          ' Else
          '   Me.Current.Goto(.X, .Y)
          ' Endif
          Me.Current.Remove(.X, .Y, .XA, .YA)
          
        Case CCommand.INSERT
          .MoveCursor(Me)
          Me.Current.Insert(.Text)
        
      End Select
  
    End With
    
    $aUndo.Add(hCmd)
    
  Until L = 0
  
  Me.Current.Overwrite = bOverwrite
  
  EnableUndo
  EnableHighlight
  
End

Private Function Highlight_Read() As String

  If $hHighlight Then Return $hHighlight.Name

End

Private Sub Highlight_Write(Value As String)

  Dim Y As Integer
  
  If Value Then
    If Value == "c++" Then Value = "cplusplus"
    $hHighlight = TextHighlighter[Value]
  Else
    $hHighlight = Null
  Endif
  
  For Y = 0 To LinesInfo.Max
    If LinesInfo[Y] Then LinesInfo[Y].ClearHighlight()
  Next
  HighlightFrom(0)

End

Public Sub HighlightFrom(Y As Integer)

  Dim aHighlight As Byte[]
  Dim bCustom As Boolean
  Dim bRefresh As Boolean
  Dim bBegin As Boolean
  
  If $bHighlighting Then Return
  
  If $iNoHighlight Then 
    $cHighlightLater[Y] = True
    Return
  Endif
  
  If Not $hHighlight Then 
    If Object.CanRaise(Me.Current, "Highlight") Then 
      bCustom = True
    Else
      Return
    Endif
  Endif

  $bHighlighting = True

  Do

    If Y < 0 Or If Y > Lines.Max Then Break
    If Info(Y).Colors Then Break
  
    bRefresh = True
  
    If Y = 0 Then
      TextHighlighter.State = Highlight.Normal
      TextHighlighter.Tag = 0
      TextHighlighter.Alternate = False
    Else
      With Info(Y - 1)
        TextHighlighter.State = .State
        TextHighlighter.Tag = .Tag
        TextHighlighter.Alternate = .Alternate
      End With
    Endif
    TextHighlighter.Limit = False
    
    With SetInfo(Y)
  
      aHighlight = New Byte[]
      .Colors = aHighlight
      TextHighlighter._Highlight = aHighlight
      TextHighlighter.TextAfter = ""
      TextHighlighter.Line = Y
      
      'Debug "Before: State = "; .State;; "Tag = "; .Tag;; "Alternate = "; .Alternate;; "Limit = "; .Limit
      
      '$hHighlight.Run(Lines[Y])
      
      If bCustom Then
      
        Me.Current._RaiseHighlight(Lines[Y])
        
      Else
        
        $hHighlight.Run(Lines[Y])
        If Y = 0 Then TextHighlighter.Limit = True
        
      Endif
      
      If TextHighlighter.TextAfter And If Lines[Y] <> TextHighlighter.TextAfter Then
        If Not bBegin Then
          bBegin = True
          Me.Current._SaveCursor
          Begin()
        Endif
        Me.Current.Goto(0, Y)
        Me.Current.Remove(0, Y, LineLength[Y], Y)
        Me.Current.Insert(TextHighlighter.TextAfter)
        .Colors = aHighlight
      Endif
      
      If .Alternate <> TextHighlighter.Alternate Or If .State <> TextHighlighter.State Or If .Tag <> TextHighlighter.Tag Or If .Limit <> TextHighlighter.Limit Then
        .Alternate = TextHighlighter.Alternate
        .State = TextHighlighter.State
        .Tag = TextHighlighter.Tag
        .Limit = TextHighlighter.Limit
        'Debug "Update: State = "; .State;; "Tag = "; .Tag;; "Alternate = "; .Alternate;; "Limit = "; .Limit
        If Y < Lines.Max Then SetInfo(Y + 1).ClearHighlight()
      Endif
      
      Inc Y
      
    End With
    
  Loop

  If bBegin Then 
    Me.Current._RestoreCursor
    End()
  Endif

  If bRefresh Then Refresh
  
  $bHighlighting = False
    
End

Private Function Length_Read() As Integer

  Dim Y As Integer
  Dim L As Integer

  For Y = 0 To Lines.Max
    L += LineLength[Y]
  Next
  
  L += Lines.Max * Len($sEndOfLine)
  Return L

End

Private Function Keywords_Read() As String[]

  Try Return $hHighlight.GetKeywords()

End

Private Function Breakpoints_Read() As Integer[]

  Dim Y As Integer
  Dim aRes As Integer[]

  aRes = New Integer[]
  For Y = 0 To Lines.Max
    If Info(Y).Breakpoint Then
      aRes.Add(Y)
    Endif
  Next
  
  Return aRes

End

Private Sub Breakpoints_Write(Value As Integer[])

  Dim Y As Integer

  For Y = 0 To Lines.Max
    If Info(Y).Breakpoint Then SetInfo(Y).Breakpoint = False
  Next
  
  If Value Then
    For Each Y In Value
      SetInfo(Y).Breakpoint = True
    Next
  Endif

End

Private Function Bookmarks_Read() As Integer[]

  Dim Y As Integer
  Dim aRes As Integer[]

  aRes = New Integer[]
  For Y = 0 To Lines.Max
    If Info(Y).Bookmark Then
      aRes.Add(Y)
    Endif
  Next
  
  Return aRes

End

Private Sub Bookmarks_Write(Value As Integer[])

  Dim Y As Integer

  For Y = 0 To Lines.Max
    If Info(Y).Bookmark Then SetInfo(Y).Bookmark = False
  Next
  
  If Value Then
    For Each Y In Value
      SetInfo(Y).Bookmark = True
    Next
  Endif

End

Private Function EndOfLine_Read() As Integer

  Return $iEndOfLine

End

Private Sub EndOfLine_Write(Value As Integer)

  Select Case Value
    Case gb.Unix
      $sEndOfLine = "\n"
    Case gb.Windows
      $sEndOfLine = "\r"
    Case gb.Mac
      $sEndOfLine = "\r\n"
    Case Else
      Return
  End Select
  
  $iEndOfLine = Value  

End

Private Sub IsWordChar(sCar As String) As Boolean
  
  If IsSpace(sCar) Then Return
  If IsPunct(sCar) And If InStr("_$", sCar) = 0 Then Return
  If String.Code(sCar) = 160 Then Return
  Return True
  
End


Public Sub WordLeft(X As Integer, Y As Integer, Optional bWord As Boolean) As Integer

  Dim sLine As String = Lines[Y]
  Dim X2 As Integer
  Dim sCar As String
  
  X2 = X
  
  If Not bWord Then
    While X2 > 0
      If Not IsSpace(String.Mid$(sLine, X2, 1)) Then Break
      Dec X2
    Wend
  Endif
  
  If X2 > 0 Then
    If IsWordChar(String.Mid$(sLine, X2, 1)) Then
      Do
        Dec X2
        If X2 <= 0 Or If Not IsWordChar(String.Mid$(sLine, X2, 1)) Then Break
      Loop
    Else If Not bWord Then
      Do
        Dec X2
        If X2 <= 0 Then Break
        sCar = String.Mid$(sLine, X2, 1)
        If IsWordChar(sCar) Or If IsSpace(sCar) Then Break
      Loop
    Endif
  Endif
  
  Return X2
  
End

' int GDocument::wordLeft(int y, int x, bool word)
' {
'   int xw = x;
'   GString s = lines.at(y)->s;
' 
'   if (!word)
'   {
'     while (xw > 0 && s.isSpace(xw - 1))
'       xw--;
'   }
'   
'   if (xw > 0)
'   {
'     if (s.isWordChar(xw - 1))
'     {
'       for(;;)
'       {
'         xw--;
'         if (xw <= 0 || !s.isWordChar(xw - 1))
'           break;
'       }
'     }
'     else if (!word)
'     {
'       for(;;)
'       {
'         xw--;
'         if (xw <= 0 || s.isWordChar(xw - 1) || s.isSpace(xw - 1))
'           break;
'       }
'     }
'   }
' 
'   return xw;
' }
' 

Public Sub WordRight(X As Integer, Y As Integer, Optional bWord As Boolean) As Integer

  Dim sLine As String = Lines[Y]
  Dim iLen As Integer = LineLength[Y]
  Dim X2 As Integer
  Dim sCar As String
  
  X2 = X
  
  If X2 < iLen Then
    
    If IsWordChar(String.Mid$(sLine, X2 + 1, 1)) Then
      Do
        Inc X2
        If X2 >= iLen Or If Not IsWordChar(String.Mid$(sLine, X2 + 1, 1)) Then Break
      Loop
    Else If Not bWord Then
      Do
        Inc X2
        If X2 >= iLen Then Break
        sCar = String.Mid$(sLine, X2 + 1, 1)
        If IsWordChar(sCar) Or If IsSpace(sCar) Then Break
      Loop
    Endif
    
    If Not bWord Then
      While X2 < iLen
        If Not IsSpace(String.Mid$(sLine, X2 + 1, 1)) Then Break
        Inc X2
      Wend
    Endif
    
  Endif
  
  Return X2
  
End


' int GDocument::wordRight(int y, int x, bool word)
' {
'   int xw = x;
'   GString s = lines.at(y)->s;
'   int len = s.length();
' 
'   if (xw < len)
'   {
'     if (s.isWordChar(xw))
'     {
'       for(;;)
'       {
'         xw++;
'         if (xw >= len || !s.isWordChar(xw))
'           break;
'       }
'     }
'     else if (!word)
'     {
'       for(;;)
'       {
'         xw++;
'         if (xw >= len || s.isWordChar(xw) || s.isSpace(xw))
'           break;
'       }
'     }
'   }
' 
'   if (!word)
'   {
'     while (xw < len && s.isSpace(xw))
'       xw++;
'   }
'   
'   return xw;
' }
' 

Public Sub Reset(Optional bSave As Boolean)

  Dim I As Integer
  
  For I = 0 To Lines.Max
    If Info(I).Modified Then 
      With SetInfo(I)
        .Modified = False
        .Saved = bSave
      End With
    Endif
  Next

  Refresh  
  
End

Public Sub DisableHighlight()
  
  Inc $iNoHighlight
  If $iNoHighlight = 1 Then $cHighlightLater = New Collection
  
End

Public Sub EnableHighlight()
  
  Dim cHighlightLater As Collection
  
  Dec $iNoHighlight
  If $iNoHighlight = 0 Then 
    cHighlightLater = $cHighlightLater
    For Each cHighlightLater
      HighlightFrom(cHighlightLater.Key)
    Next
    $cHighlightLater = Null
  Endif
  
End

Public Sub DisableUndo()
  
  Inc $iNoUndo
  
End

Public Sub EnableUndo()
  
  Dec $iNoUndo
  CheckUnlock
  
End

Public Sub IsLocked() As Boolean
  
  Return $iBegin + $iNoUndo
  
End

Private Sub CheckUnlock()

  Dim hView As TextEditor
  
  If IsLocked() Then Return
  For Each hView In GetAllViews()
    hView._RaiseCursor
  Next
  

End
