' Gambas class file

Export
Create Private
Inherits ReportFrame

Public Const _IsContainer As Boolean = True
Public Const _Group As String = "Container"
Public Const _Properties As String = "*,Spacing{ReportCoord},OnePiece"
'Public Const _DefaultEvent As String = "Data"
Private $bDataIsResult As Boolean
'Private $iCount As Integer

Property _CurItem As Integer
Private $iCurItem As Integer

Public _Arrangement As Integer
Private $bIndexChange As Boolean
Private $aChild As New ReportControl[]
Private $fSpacing As Float
Private $sSpacing As String
Private $bRelativeSpacing As Boolean
Private $bRepeat As Boolean
Private $aChildCopy As TControl[]
Private $bOnePiece As Boolean
Private $iIndex As Integer
Private $hData As Object
Private $fFixedSize As Float
Property _Index As Integer

Property DataCount As Integer

Property Read Children As ReportControl[]
'Property Read Index As Integer
Property Spacing As String
'Property Data As Object  '<==== remettre pour automation

Property Read _Spacing As Float
Property Read _RelativeSpacing As Boolean
Property OnePiece As Boolean
Public _RealSpacing As Integer
Static Private $iLevel As Integer
Event BeforeData
Event AfterData

Public Function _Add(cControl As ReportControl) 'As TControl

  'Dim hTControl As New TControl

  'hTControl.Ctrl = cControl
  $aChild.Add(cControl)
  ReportControl._ObjectFromId[cControl.Id] = cControl
  'Return hTControl

End

Public Sub _Remove(id As Integer)

  $aChild.Remove($aChild.Find(ReportControl._ObjectFromId[id]))

End

Public Sub _Free()

End

Private Function Children_Read() As ReportControl[]

  Return $aChild

End

Private Function Spacing_Read() As String

  Return $sSpacing

End

Private Sub Spacing_Write(Value As String)

  $sSpacing = Value

End

Public Sub _ClipChildren(Page As Integer, X As Float, Y As Float, hControl As TControl, VirtualId As Integer, fScale As Float)

  Dim hChild As TControl
  Dim vi As Integer

  Dim CX1, CX2, CY1, CY2 As Float
  Dim hCont As ReportContainer

  With Paint.ClipExtents
    CX1 = .X
    CY1 = .Y
    CX2 = .X2
    CY2 = .Y2
  End With

  X += hControl.RealLeft
  Y += hControl.RealTop

  For Each hChild In Me.Children
    vi = VirtualId
    If hControl.VirtualId > -1 Then vi = hControl.VirtualId

    hChild._SkipPainting = False

    If Not Paint.Device Is Printer And If CX2 > CX1 And If CY2 > CY1 Then
      If (X + hChild.RealLeft) > CX2 Then
        hChild._SkipPainting = True
        Continue
      Endif
      If (X + hChild.RealLeft + hChild.RealWidth) < CX1 Then
        hChild._SkipPainting = True
        Continue
      Endif
      If (Y + hChild.RealTop) > CY2 Then
        hChild._SkipPainting = True
        Continue
      Endif
      If (Y + hChild.RealTop + hChild.RealHeight) < CY1 Then
        hChild._SkipPainting = True
        Continue
      Endif
    Endif

    If hChild.RelPage >= 0 And If (hChild.RelPage + hControl.RealPage) <> Page Then
      hChild._SkipPainting = True
      Continue
    Endif

    If hChild.Ctrl Is ReportContainer Then
      hCont = hChild.Ctrl
      hCont._ClipChildren(Page, X, Y, hChild, vi, fScale)
    Endif

  Next

End

Public Sub _Paint(Page As Integer, X As Float, Y As Float, hControl As TControl, VirtualId As Integer)

  Dim hChild As TControl

  X += hControl.RealLeft
  Y += hControl.RealTop
  If Not hControl._PageChildren.Exist(Page) Then Return
  Me._Index = hControl.Index
  For Each hChild In hControl._PageChildren[Page]
    'Print object.Type(hchild.Ctrl), hControl.RelPage, hControl.RealPage + hchild.RelPage, Page - 1

    'If hchild.RelPage = -1 Or hControl.RealPage + hchild.RelPage = Page - 1 Then

    'Inc MTools.DrawCount

    '$iIndex = VirtualId
    'If hControl.VirtualId > -1 Then $iIndex = hControl.VirtualId

    hChild.Ctrl._Paintframe(Page, X, Y, hChild, $iIndex)

  Next

End

Private Function _Spacing_Read() As Float

  Return $fSpacing

End

Private Function _RelativeSpacing_Read() As Boolean

  Return $bRelativeSpacing

End

Public Sub _SetUnifiedValues()

  Dim hChild As ReportControl
  Dim hSizeParse As TSizeParse

  Super._SetUnifiedValues()

  hSizeParse = New TSizeParse($sSpacing, True)
  $fSpacing = hSizeParse.GetValue()
  $bRelativeSpacing = hSizeParse.IsRelative()

  For Each hChild In $aChild
    'hchild.SizeHint = Null
    hChild._SetUnifiedValues()
  Next

End

Public Sub _GenerateClones()

  Dim hTControl, hNewTControl, hTc As TControl
  Dim o As Object
  Dim i As Integer
  Dim hCont As ReportContainer
  Dim aNewChild As TControl[]
  Dim bRaiseRet As Boolean
  Dim aCopy As TControl[]

  If $aChildCopy Then
    $aChild = $aChildCopy.Copy()
  Endif
  aCopy = $aChild.Copy()

  For Each hTc In aCopy
    If hTc.Ctrl Is ReportContainer Then
      hCont = hTc.Ctrl
      If hCont.Data Then
        aNewChild = New TControl[]

        For i = 0 To hCont.Data.Count - 1

          hNewTControl = New TControl
          hNewTControl.Ctrl = hTc.Ctrl
          hNewTControl.VirtualId = i
          aNewChild.Add(hNewTControl)

        Next
        $aChild = $aChild.Insert(aNewChild, $aChild.Find(hTc))
        $aChild.Remove($aChild.Find(hTc))

      Endif
      hCont._GenerateClones
    Endif
  Next
  If $aChild.Count <> aCopy.Count Then $aChildCopy = aCopy

End


Public Sub _GetSizeHints(AvailableW As Float, AvailableH As Float, TotalWidth As Float, TotalHeight As Float) As TSizeHint

  Dim hChild As TControl
  Dim fHeight As Float
  Dim hChildHints As TSizeHint
  Dim hMyHints As New TSizeHint
  Dim fSpacing As Float
  Dim fPadding As Float

  'If Me._SizeInt.StoreSize Then Return Me._SizeInt
  'If Me.tag = "*" Then Stop
  If Me._CurItem > Me.Children.max Then

    '   If Me Is ReportSection Then Stop
    Me._CurItem = 0
    '   'Me._DataIndex = 0
  Endif
  Raise BeforeData
  Select Case _Arrangement

    Case Arrange.Vertical
      Return GetVSizeInt(AvailableW, AvailableH, TotalWidth, TotalHeight)
    Case Arrange.Horizontal
      Return GetHSizeInt(AvailableW, AvailableH, TotalWidth, TotalHeight)
    Case Arrange.Column
      Return GetVSizeInt(AvailableW, AvailableH, TotalWidth, TotalHeight)
    Case Arrange.Fill, Arrange.None
      Return Super._GetSizeHints(AvailableW, AvailableH, TotalWidth, TotalHeight)
      'hMyHints.Height = AvailableH
      'Me._SizeInt.StoreSize = True
      'Me._SizeInt = hMyHints
      Return hMyHints

  End Select
  Raise AfterData

End

Private Function GetHSizeInt(AvailableW As Float, AvailableH As Float, TotalWidth As Float, TotalHeight As Float) As TSizeHint

  Dim hChild As ReportControl
  Dim fHeight, fWidth As Float
  Dim hChildHints As TSizeHint
  Dim hMyHints As New TSizeHint
  Dim fSpacing As Float

  'D'abord utiliser la méthode du controle pour définir la taille
  hMyHints = Super._GetSizeHints(AvailableW, AvailableH, TotalWidth, TotalHeight)

  'Puis si besoins voir le besoin des enfants
  If Me.Autoresize Then
    fSpacing = IIf(Me._RelativeSpacing, TotalWidth * Me._Spacing / 100, Me._Spacing)
    For Each hChild In Me.Children
      hChildHints = hchild._GetSizeHints(AvailableW - fWidth, AvailableH, AvailableW, AvailableH)
      fWidth += hChildHints.Width + fSpacing
      If fHeight < hChildHints.Height Then fHeight = hChildHints.Height
    Next
    If fWidth Then fWidth -= fSpacing
    hMyHints.Height = fHeight + Me.Padding._Height + Me.Border._Top + Me.Border._bottom
    hMyHints.Width = fWidth + Me.Padding._Width + Me.Border._Left + Me.Border._Right
  Endif

  Return hMyHints

End

Private Function GetVSizeInt(AvailableW As Float, AvailableH As Float, TotalWidth As Float, TotalHeight As Float) As TSizeHint

  Dim hSizeInt As New TSizeHint
  Dim htmpInts As TSizeHint
  Dim hChild As ReportControl         ''Enfants
  Dim fHeight, fSpacing, fWidth As Float
  Dim i, j As Integer
  Dim bExitLoop As Boolean
  'If Me.Tag = "Boite 2" Then Stop
  'D'abord utiliser la méthode du controle pour définir la taille
  hSizeInt = Super._GetSizeHints(AvailableW, AvailableH, TotalWidth, TotalHeight)

  fSpacing = IIf(Me._RelativeSpacing, TotalHeight * Me._Spacing / 100, Me._Spacing)

  ' Si ce n'est pas fait on enregistre la place nécéssaire a tout les éléments fixes

  If Not $fFixedSize Then
    For i = 0 To Me.Children.Max
      hChild = Me.Children[i]
      htmpInts = hChild._GetSizeHints(AvailableW, AvailableH, AvailableW, AvailableH)
      If hchild.Fixed Then $fFixedSize += htmpInts.Height + fSpacing

    Next

  Endif

  'La taille ne peut être inférieur a celle de tout les éléments fixes
  hSizeInt.Height = Max(hSizeInt.Height, $fFixedSize)

  'On ajoute la taille des objets fixes précédents
  fHeight = $fFixedSize

  If Me.Autoresize Then
    'On définit la taille au besoins des enfants
    For i = Me._CurItem To Me.Children.Max
      hChild = Me.Children[i]
      For j = hchild._DataIndex To hchild._Count - 1
        If hChild.Ignore Then Continue
        If hChild.Fixed Then Continue
        hchild._Index = j
        htmpInts = hChild._GetSizeHints(AvailableW, AvailableH - fHeight, AvailableW, AvailableH)
        'on ajoute la hauteur aux besoins
        fHeight += htmpInts.Height + fSpacing
        If fHeight - fSpacing > AvailableH Then
          hSizeInt.NotFinished = True
          Break
          bExitLoop = True
        Endif
        'On récupère la largeur de l'enfant le plus large
        If fWidth < htmpInts.Width Then fWidth = htmpInts.Width
      Next
      If bExitLoop Then Break
    Next

    'on enlève le dernier espace
    If fHeight > 0 Then fHeight -= fSpacing
    'bogue bizzard
    fHeight += 0.01

    'On indique la place nécéssaire aux enfants+les éléments fixes
    hSizeInt.Height = fHeight + Me.Padding._Height + Me.Border._Top + Me.Border._Bottom
    hSizeInt.Width = fWidth + Me.Padding._Width + Me.Border._Left + Me.Border._Right
  Endif

  'On ne peut pas dépasser la taille disponible (report sur prochaine page)
  If Not Me.OnePiece Then
    hSizeInt.Height = Min(hSizeInt.Height, AvailableH)
  Endif

  hSizeInt.Height = Min(TotalHeight, hSizeInt.Height)

  Me._SizeInt = hSizeInt
  ' If Me.Tag = "Boite 2" Then
  ' Print hSizeInt.Height
  ' Stop
  ' Endif
  Return hSizeInt

End

Public Function _GetData(sKey As String) As Variant

  If $bDataIsResult Then
    If $hData.Fields.Exist(sKey) Then
      $hData.MoveTo(Me._Index)
      Return $hData[skey]
    Endif
  Else
    If $hdata <> Null And If $hData[0].Exist(sKey) Then
      Return $hdata[Me._Index][skey]
    Endif
  Endif

  Try Return Me.Parent._GetData(sKey)

  Return Null

End

Private Function Data_Read() As Object

  Return $hData

End

Private Sub Data_Write(Value As Object)

  If Not (Object.Type(Value) = "Collection[]") Then
    If Object.Type(Value) = "Result" Then
      $bDataIsResult = True
    Else
      Print Error.Text
      $bDataIsResult = False

    Endif
    If Not $bDataIsResult Then
      Error.Raise("You must give a Collection[] object or a Result Object")
      Return
    Endif
  Endif
  Me._Count = Value.Count
  $hData = Value

End

Public Sub _Reset()

  Dim hChild As ReportControl
  'mise a zéro de l'index de suivit de progression
  Me._CurItem = 0
  'Mise a zéro de l'index de reproduction
  Me._DataIndex = 0
  'Netoyage du layout précédent
  'Me._PageChildren.Clear
  'Nettoyage récurssif des enfants
  For Each hChild In Me.Children

    hChild._Reset

  Next

End

Public Sub _SetChildGeometry(X As Float, Y As Float, W As Float, H As Float, ContPage As Integer, TCont As TControl, bInFixed As Boolean)
  'If Me.Tag = "*" Then Stop
  'Print "Geometry " & Object.Type(Me)

  If Me._CurItem > Me.Children.max Then
    '   If Me Is ReportSection Then Stop
    Me._CurItem = 0
  Endif

  If $bIndexChange Then
    Raise BeforeData
    $bIndexChange = False
  Endif

  Select Case _Arrangement
    Case Arrange.Vertical
      SetVChildGeometry(X, Y, W, H, ContPage, TCont, bInFixed)
    Case Arrange.Horizontal
      SetHChildGeometry(X, Y, W, H, ContPage, TCont, bInFixed)
    Case Arrange.Column
      SetCChildGeometry(X, Y, W, H, ContPage, TCont, bInFixed)
    Case Arrange.Fill
      SetFChildGeometry(X, Y, W, H, ContPage, TCont, bInFixed)
    Case Arrange.None
      SetNChildGeometry(X, Y, W, H, ContPage, TCont, bInFixed)
  End Select
  Raise AfterData

End

Private Sub SetCChildGeometry(X As Float, Y As Float, W As Float, H As Float, ContPage As Integer, TCont As TControl, bInFixed As Boolean)

  Dim aPageItems As New TControl[] ''Éléments contenu par cette page
  Dim aPageColumns As New TControl[][]
  Dim aPageColumn As New TControl[]
  Dim aColX As New Float[]
  Dim hChildHints As TSizeHint ''Besoins en hauteur/largeur de l'enfant
  Dim hChild As ReportControl  ''Un enfant reportcontrol
  Dim oChild As Object
  Dim TH, fHeight, fSpc As Float
  Dim fExp As Float
  Dim iNExp As Integer
  Dim O As Object
  Dim i, j, k As Integer
  Dim hTItem As TControl
  'Dim bPass As Boolean
  Dim fX, fY, fTmpY As Float
  Dim bExitLoop As Boolean
  Dim AllowNextCol As Boolean
  Dim fNextColStartPos, fCurColX As Float

  'Initialisation des variables
  fSpc = IIf(Me._RelativeSpacing, H * Me._Spacing / 100, Me._Spacing) 'ME._Spacing
  'On retire les marges a la hauteur et les bordures
  H = H - Me.Padding._Top - Me.Padding._Bottom - Me.Border._Top - Me.Border._Bottom
  'on retire a la largeur les paddings (et les bordure ?)
  W = W - Me.Padding._Left - Me.Padding._Right - Me.Border._Left - Me.Border._Right

  'On positionne le curseur de position au coin a gauche
  X = Me.Padding._Left + Me.Border._Left
  Y = Me.Padding._Top + Me.Border._Top

  'On initialise la hauteur total avec la hauteur disponible
  TH = H
  fCurColX = X

  'On va retirer a la hauteur totale les éléments fixes
  For i = Me._CurItem To Me.Children.Max
    hChild = Me.Children[i]
    For j = hchild._DataIndex To hchild._Count - 1
      hChildHints = hChild._GetSizeHints(W, TH, W, H)
      hTItem = New TControl
      hTItem.Ctrl = hChild
      hTItem.SizeHint = hChildHints
      ' Je cherche l'élément le plus large pour définir la position de la colonne suivante
      If fNextColStartPos < fCurColX + hChildHints.Width Then fNextColStartPos = fCurColX + hChildHints.Width
      'Si un des éléments de colonne dépasse la largeur et qu'il n'est pas dans la première colonne
      'alors on annule toute la colonne
      If fNextColStartPos > X + W Then
        hchild._DataIndex = k
        bExitLoop = True
        'Print "trop large", fNextColStartPos, X + W
        Break
      Endif
      'si on arrive en bas du container alor on change de colonne
      If TH - hChildHints.Height < 0 Then
        'Print TH - hChildHints.Height
        aPageColumns.Add(aPageColumn)
        aColX.Add(fCurColX)
        aPageColumn = New TControl[]
        fCurColX = fNextColStartPos + fspc
        k = j
        TH = H
      Endif
      TH = TH - hChildHints.Height - fspc
      hTItem.Index = IIf(bInFixed, 0, j)
      aPageColumn.Add(hTItem)

      'On l'ajoute a la page
    Next
    'Print j & "/" & hchild._Count
    'Print Me._CurItem & "/" & Me.Children.Max

    If bExitLoop Then Break
    Inc Me._CurItem

  Next
  If Not bExitLoop Then
    aColX.Add(fCurColX)
    aPageColumns.Add(aPageColumn)
  Endif

  'On va mettre en page a présent
  'On définit la taille des éléments étendus
  If iNexp Then
    fExp = (TH + fExp) / iNexp
  Endif
  i = 0
  For Each aPageColumn In aPageColumns
    fTmpY = Y
    For Each hTItem In aPageColumn

      oChild = hTItem.Ctrl
      'Si l'élément est étendu on lui applique la taille répartie
      If oChild.Expand And Not oChild.Ignore Then
        'If Me.Tag = "*" Then Stop
        fHeight = fExp
      Else
        'sinon il maintien sa taille
        fHeight = hTItem.SizeHint.Height
      Endif
      oChild._Index = hTItem.Index
      'Print Object.Type(hChild) & "  " & fHeight
      If Not oChild.Ignore Then
        hTItem._SetGeometry(aColX[i], fTmpY, hTItem.SizeHint.Width, fHeight)

        oChild._SetChildGeometry(aColX[i], fTmpY, hTItem.SizeHint.Width, fHeight, ContPage, hTItem, bInFixed Or Me.Fixed)
        fTmpY += fHeight + fspc
      Else
        fX = X + IIf(oChild._RelativeLeft, W * oChild._Left / 100, oChild._Left)
        fY = Y + IIf(oChild._RelativeTop, H * oChild._Top / 100, oChild._Top)
        hTItem._SetGeometry(fX, fY, hTItem.SizeHint.Width, fHeight)
        oChild._SetChildGeometry(fX, fY, hTItem.SizeHint.Width, fHeight, ContPage, hTItem, bInFixed Or Me.Fixed)
      Endif

      If oChild Is ReportContainer Then

        If oChild._CurItem <= oChild.Children.max Then
          'Print "il reste des éléments dans " & oChild.Tag & " a la page " & ContPage
          'Print ochild.Children.max - ochild._CurItem
          j = Me.Children.Find(oChild)
          Me._CurItem = Min(Me._CurItem, j)
        Endif
        'ne pas incrémenter la lecture des enfants si je suis dans un élément fixe
        If bInFixed Then ochild._CurItem = 0
      Endif

    Next
    Inc i
    aPageItems.Insert(aPageColumn)
  Next
  'Fin du processus
  'On ajoute cette page au dossier du conteneur
  TCont._PageChildren[ContPage] = aPageItems

End

Private Sub SetVChildGeometry(X As Float, Y As Float, W As Float, H As Float, ContPage As Integer, TCont As TControl, bInFixed As Boolean)

  Dim aPageItems As New TControl[] ''Éléments contenu par cette page
  Dim hChildHints As TSizeHint ''Besoins en hauteur/largeur de l'enfant
  Dim hChild As ReportControl  ''Un enfant reportcontrol
  Dim oChild As Object
  Dim TH, fHeight, fSpc As Float
  Dim fExp As Float
  Dim iNExp As Integer
  Dim O As Object
  Dim i, j As Integer
  Dim hTItem As TControl
  'Dim bPass As Boolean
  Dim fX, fY, fTmpY As Float
  Dim bExitLoop As Boolean
  Dim bInLoop As Boolean
  'If Me.Tag = "*" Then Stop
  'Initialisation des variables
  fSpc = IIf(Me._RelativeSpacing, H * Me._Spacing / 100, Me._Spacing) 'ME._Spacing
  'On retire les marges a la hauteur et les bordures
  H = H - Me.Padding._Top - Me.Padding._Bottom - Me.Border._Top - Me.Border._Bottom
  'on retire a la largeur les paddings (et les bordure ?)
  W = W - Me.Padding._Left - Me.Padding._Right - Me.Border._Left - Me.Border._Right

  'On positionne le curseur de position au coin a gauche
  X = Me.Padding._Left + Me.Border._Left
  Y = Me.Padding._Top + Me.Border._Top

  'On initialise la hauteur total avec la hauteur disponible
  TH = H

  'On va retirer a la hauteur totale les éléments fixes
  For i = 0 To Me.Children.Max
    hChild = Me.Children[i]
    If hChild.Fixed Then
      hChildHints = hChild._GetSizeHints(W, TH, W, H)

      'si l'index courant est inférieur a l'objet en cour du conteneur alors
      'on l'ajoute a la page et on incrémente la place des objet étendu si il est étendu

      If Not hchild.Ignore Then TH = TH - hChildHints.Height - fspc

      If i < Me._CurItem Then
        'If Me._CurItem = 0 Then itmpItem = i
        hTItem = New TControl
        hTItem.Ctrl = hChild
        hTItem.SizeHint = hChildHints
        'On l'ajoute a la page
        aPageItems.Add(hTItem)
        'Si l'enfant est étendu alors on en tien compte :
        If hChild.Expand And Not hchild.Ignore Then
          fExp += hChildHints.Height
          Inc iNexp
        Endif
      Endif

    Endif

  Next

  'If Me._CurItem = 0 Then Me._CurItem = itmpItem
  'If ContPage = 2 Then Stop
  'If Me.Tag = "Boite 1" Then Stop
  For i = Me._CurItem To Me.Children.Max

    hChild = Me.Children[i]
    ' If ContPage = 1 And Me.tag = "Boite 1" Then
    '
    '   'Stop
    '   Print "DataIndex =" & hchild._DataIndex
    ' Endif
    'bLastElement = False
    For j = hchild._DataIndex To Max(hchild._Count - 1, 0)
      'If j = Max(hchild._Count - 1, 0) Then bLastElement = True
      'If hChild.Tag = "Contenu1" Then Stop
      'If hChild.Tag = "Contenu1" Then Stop
      hchild._Index = j
      hChildHints = hChild._GetSizeHints(W, TH, W, H)
      'If Not (j = hchild._Count - 1) Then Print " pas j ok" & j
      'If Not (i = Me.Children.Max) Then
      'If Not (j = hchild._Count - 1) Then
      ' If bFirstSpace Then
      '   TH -= fspc
      ' Else
      '   bFirstSpace = True
      ' Endif

      'Print "space"
      'Endif
      'Endif
      'Si on ne l'a pas déja compté comme fixé
      If Not hChild.Fixed And If Not hChild.Ignore Then
        'If Me.Tag = "Boite 1" Then Print TH - hChildHints.Height
        If (TH - hChildHints.Height) < 0 Or TH <= 0 Then

          'Print "manque : " & (TH - hChildHints.Height)
          ' Print "sortie forcée, il reste : " & ((hchild._Count - 1) - j)
          hchild._DataIndex = j
          bExitLoop = True
          Break
        Endif
        TH = TH - hChildHints.Height - fspc

        ' If i < Me.Children.count And If Not bLastElement Then
        '   TH -= fspc
        ' Else
        '   Print " non enlevé"
        ' Endif

      Endif
      hTItem = New TControl
      hTItem.Ctrl = hChild
      hTItem.SizeHint = hChildHints
      hTItem.Index = j
      'On l'ajoute a la page
      aPageItems.Add(hTItem)

      'Si l'enfant est étendu alors on en tien compte :
      If hChild.Expand Then
        fExp += hChildHints.Height
        Inc iNexp
      Endif
      If hChildHints.NotFinished Then hchild._DataIndex = j
      'un élément fixe ou ignore ne peut être répété
      If hchild.Fixed Or hchild.Ignore Then Break

      bInLoop = True
    Next
    If bExitLoop Then Break
    bInLoop = False
    'hchild._DataIndex = 0
    Inc Me._CurItem
  Next

  If (H - TH) > 0 Then
    TH += fspc
  Endif

  For i = Max(Me._CurItem, 0) To Me.Children.Max
    hChild = Me.Children[i]
    If hChild.Fixed Then
      hChildHints = hChild._GetSizeHints(W, TH, W, H)
      hTItem = New TControl
      hTItem.Ctrl = hChild
      hTItem.SizeHint = hChildHints
      'On l'ajoute a la page
      aPageItems.Add(hTItem)
      'Si l'enfant est étendu alors on en tien compte :
      If hChild.Expand And Not hchild.Ignore Then
        fExp += hChildHints.Height
        Inc iNexp
      Endif
    Endif
  Next

  'On va mettre en page a présent
  'On définit la taille des éléments étendus
  If iNexp Then
    fExp = (TH + fExp) / iNexp
  Endif

  fTmpY = Y
  'Print Me.tag & " " & Me._CurItem & " / " & Me.Children.Max
  For Each hTItem In aPageItems

    oChild = hTItem.Ctrl
    'Si l'élément est étendu on lui applique la taille répartie
    If oChild.Expand And Not oChild.Ignore Then
      'If Me.Tag = "*" Then Stop
      fHeight = fExp
    Else
      'sinon il maintien sa taille
      fHeight = hTItem.SizeHint.Height
    Endif
    oChild._Index = hTItem.Index
    'Print Object.Type(hChild) & "  " & fHeight
    If Not oChild.Ignore Then
      hTItem._SetGeometry(X, fTmpY, W, fHeight)
      oChild._SetChildGeometry(X, fTmpY, W, fHeight, ContPage, hTItem, bInFixed Or Me.Fixed)
      fTmpY += fHeight + fspc
    Else
      fX = X + IIf(oChild._RelativeLeft, W * oChild._Left / 100, oChild._Left)
      fY = Y + IIf(oChild._RelativeTop, H * oChild._Top / 100, oChild._Top)
      hTItem._SetGeometry(fX, fY, hTItem.SizeHint.Width, fHeight)
      oChild._SetChildGeometry(fX, fY, hTItem.SizeHint.Width, fHeight, ContPage, hTItem, bInFixed Or Me.Fixed)
    Endif

    If oChild Is ReportContainer Then

      If oChild._CurItem <= oChild.Children.max Then

        j = Me.Children.Find(oChild)

        Me._CurItem = Min(Me._CurItem, j)
      Endif

      'Print ochild._DataIndex & " / " & (ochild.DataCount - 1)
      'ne pas incrémenter la lecture des enfants si je suis dans un élément fixe
      If bInFixed Then ochild._CurItem = 0
    Endif

  Next

  'Fin du processus
  'On ajoute cette page au dossier du conteneur
  TCont._PageChildren[ContPage] = aPageItems

End

Private Function SetFChildGeometry(X As Float, Y As Float, W As Float, H As Float, ContPage As Integer, TCont As TControl, bInFixed As Boolean)

  Dim hChild As ReportControl
  Dim hTItem As TControl
  Dim hChildHints As TSizeHint
  Dim aPageItems As New TControl[]
  Dim oChild As Object
  Dim j As Integer

  X = Me.Padding._Left + Me.Border._Left
  Y = Me.Padding._Top + Me.Border._Top
  W = W - Me.Padding._Left - Me.Padding._Right - Me.Border._Left - Me.Border._Right
  H = H - Me.Padding._Top - Me.Padding._Bottom - Me.Border._Top - Me.Border._Bottom
  For Each hChild In Me.Children
    hChildHints = hchild._GetSizeHints(W, H, W, H)
    hTItem = New TControl
    hTItem.Ctrl = hchild
    hTItem.SizeHint = hChildHints

    Inc Me._CurItem
    aPageItems.Add(hTItem)

  Next
  For Each oChild In aPageItems
    oChild._Index = hTItem.Index
    hTItem._SetGeometry(X, Y, W, H)
    hChild._SetChildGeometry(X, Y, W, H, ContPage, hTItem, bInFixed Or Me.Fixed)
    If oChild Is ReportContainer Then

      If oChild._CurItem < oChild.Children.count Then
        'Print ochild.tag & " pas fini"
        j = Me.Children.Find(oChild)
        Me._CurItem = Min(j, Me._CurItem)
      Endif
      'ne pas incrémenter la lecture des enfants si je suis dans un élément fixe
      If bInFixed Then ochild._CurItem = 0
    End If
  Next

  TCont._PageChildren[ContPage] = aPageItems

End

Private Function SetNChildGeometry(X As Float, Y As Float, W As Float, H As Float, ContPage As Integer, TCont As TControl, bInFixed As Boolean)

  Dim hChild As ReportControl
  Dim ochild As Object
  Dim hTItem As TControl
  Dim hChildHints As TSizeHint
  Dim aPageItems As New TControl[]
  Dim iX, iY As Integer
  Dim J As Integer

  X = Me.Padding._Left + Me.Border._Left
  Y = Me.Padding._Top + Me.Border._Top
  W = W - Me.Padding._Left - Me.Padding._Right - Me.Border._Left - Me.Border._Right
  H = H - Me.Padding._Top - Me.Padding._Bottom - Me.Border._Top - Me.Border._Bottom

  For Each hChild In Me.Children

    hChildHints = hchild._GetSizeHints(W, H, W, H)
    hTItem = New TControl
    hTItem.Ctrl = hchild
    hTItem.SizeHint = hChildHints
    Inc Me._CurItem
    aPageItems.Add(hTItem)

  Next

  For Each hTItem In aPageItems
    oChild = hTItem.Ctrl
    hChildHints = hTItem.SizeHint
    iX = X + IIf(oChild._RelativeLeft, W * oChild._Left / 100, oChild._Left)
    iY = Y + IIf(oChild._RelativeTop, H * oChild._Top / 100, oChild._Top)
    oChild._Index = hTItem.Index
    hTItem._SetGeometry(iX, iY, hChildHints.Width, hChildHints.Height)
    hChild._SetChildGeometry(iX, iY, hChildHints.Width, hChildHints.Height, ContPage, hTItem, bInFixed Or Me.Fixed)

    If oChild Is ReportContainer Then

      If oChild._CurItem < oChild.Children.count Then
        j = Me.Children.Find(oChild)
        Me._CurItem = Min(j, Me._CurItem)
      Endif
      'ne pas incrémenterla lecture des enfants si je suis dans un élément fixe
      If bInFixed Then ochild._CurItem = 0
    End If
  Next
  TCont._PageChildren[ContPage] = aPageItems

End

Private Sub SetHChildGeometry(X As Float, Y As Float, W As Float, H As Float, ContPage As Integer, TCont As TControl, bInFixed As Boolean)

  Dim aPageItems As New TControl[] ''Éléments contenu par cette page
  Dim hChildHints As TSizeHint ''Besoins en hauteur/largeur de l'enfant
  Dim hChild As ReportControl  ''Un enfant reportcontrol
  Dim oChild As Object
  Dim TW, fWidth, fSpc As Float
  Dim fExp As Float
  Dim iNExp As Integer
  Dim O As Object
  Dim i, j, itmpItem As Integer
  Dim fTmpX, fX, fY As Float
  Dim hTItem As TControl

  'Initialisation des variables
  fSpc = IIf(Me._RelativeSpacing, H * Me._Spacing / 100, Me._Spacing) 'ME._Spacing
  'On retire les marges a la hauteur et les bordures
  H = H - Me.Padding._Top - Me.Padding._Bottom - Me.Border._Top - Me.Border._Bottom
  'Print H
  'on retire a la largeur les paddings (et les bordure ?)
  W = W - Me.Padding._Left - Me.Padding._Right - Me.Border._Left - Me.Border._Right

  'On positionne le curseur de position au coin a gauche
  X = Me.Padding._Left + Me.Border._Left
  Y = Me.Padding._Top + Me.Border._Top

  'On initialise la largeur totale avec la largeur disponible
  TW = W

  For i = 0 To Me.Children.Max

    hChild = Me.Children[i]

    hChildHints = hChild._GetSizeHints(w, h, w, h)

    'Si l' éléments ne loge pas on quitte et on oublit
    If TW - hChildHints.Width < 0 Then Break

    'Si l'élément n'est pas ignoré
    If Not hChild.Ignore Then
      TW = TW - hChildHints.Width - fSpc
      'Si il est étendu on en tient compte
      If hChild.Expand Then
        Inc iNExp
        fExp += hChildHints.Width
      Endif
    Endif

    'On ajoute l'élément a la page
    hTItem = New TControl
    hTItem.Ctrl = hChild
    hTItem.SizeHint = hChildHints
    aPageItems.Add(hTItem)

  Next

  'De toute les façon je ne cherche pas a parcourir tout
  'Les objet donc j'indique que j'ai tout vu
  Me._CurItem = Me.Children.count

  If (W - TW) > 0 Then
    TW += fspc
  Endif

  'On va mettre en page a présent
  'On définit la taille des éléments étendus
  If iNexp Then
    fExp = (TW + fExp) / iNexp
  Endif

  fTmpX = X
  For Each hTItem In aPageItems
    oChild = hTItem.Ctrl
    'Si l'élément est étendu on lui applique la taille répartie
    If oChild.Expand And Not oChild.Ignore Then
      'If Me.Tag = "*" Then Stop
      fWidth = fExp
    Else
      'sinon il maintien sa taille
      fWidth = hTItem.SizeHint.Width
    Endif
    oChild._Index = hTItem.Index
    If Not oChild.Ignore Then
      hTItem._SetGeometry(fTmpX, Y, fWidth, H)
      oChild._SetChildGeometry(fTmpX, Y, fWidth, H, ContPage, hTItem, bInFixed Or Me.Fixed)
      fTmpX += fWidth + fspc
    Else
      fX = X + IIf(oChild._RelativeLeft, W * oChild._Left / 100, oChild._Left)
      fY = Y + IIf(oChild._RelativeTop, H * oChild._Top / 100, oChild._Top)
      hTItem._SetGeometry(fX, fY, fWidth, hTItem.SizeHint.Height)
      oChild._SetChildGeometry(fX, fY, fWidth, hTItem.SizeHint.Height, ContPage, hTItem, bInFixed Or Me.Fixed)
    Endif

    If oChild Is ReportContainer Then
      If oChild._CurItem <= oChild.Children.max Then
        'Print ochild.tag & " pas fini"
        j = Me.Children.Find(oChild)
        Me._CurItem = Min(Me._CurItem, j)
      Endif
      'ne pas incrémenter la lecture des enfants si je suis dans un élément fixe
      If bInFixed Then ochild._CurItem = 0

    Endif
  Next

  'On ajoute la page a la collection de page du conteneur
  TCont._PageChildren[ContPage] = aPageItems

End

Private Function DataCount_Read() As Integer

  Return Me._Count

End

Private Sub DataCount_Write(Value As Integer)
  'If value = 0 Then value = 1

  Me._Count = Value

End

Public Function _GetIndex() As Integer

  If Me._Count > 0 Then
    Return Me._Index
  Else
    Try Return Me.Parent._GetIndex
  Endif

End

Private Function _Index_Read() As Integer

  Return Super._Index

End

Private Sub _Index_Write(Value As Integer)

  $bIndexChange = True
  Super._Index = Value

End

Private Function _CurItem_Read() As Integer

  Return $iCurItem

End

Private Sub _CurItem_Write(Value As Integer)
  'Print "_CurItem = " & Value
  'If Me.tag = "Boite 1" And Value = 0 Then Stop
  'If Me.tag = "Boite 1" And ContPage = 1 Then Print "CurItem: " & Me._CurItem

  $iCurItem = Value

End

Private Function OnePiece_Read() As Boolean

  Return $bOnePiece

End

Private Sub OnePiece_Write(Value As Boolean)

  $bOnePiece = Value

End
