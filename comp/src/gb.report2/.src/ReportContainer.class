' Gambas class file

Export
Create Private
Inherits ReportFrame

Public Const _IsContainer As Boolean = True
Public Const _Group As String = "Container"
Public Const _Properties As String = "*,Spacing{ReportCoord},OnePiece,ForceNewPage"
'Public Const _DefaultEvent As String = "Data"
'Private $bDataIsResult As Boolean
'Private $iCount As Integer

Property _CurItem As Integer
Private $iCurItem As Integer

Public _Arrangement As Integer
Private $bIndexChange As Boolean
Private $aChild As New ReportControl[]
Private $fSpacing As Float
Private $sSpacing As String
Private $bRelativeSpacing As Boolean

'Private $aChildCopy As TControl[]
Private $bOnePiece As Boolean
'Private $iIndex As Integer
'Private $hData As Object
Private $fFixedSize As Float
Property _Index As Integer

Property DataCount As Integer

Property Read Children As ReportControl[]

'Property Read Index As Integer
Property Spacing As String
'Property Data As Object  '<==== remettre pour automation

Property Read _Spacing As Float
Property Read _RelativeSpacing As Boolean

Property OnePiece As Boolean
Public _RealSpacing As Integer
Public _NotFinished As Boolean

Event BeforeData
Event AfterData

Public Function _Add(cControl As ReportControl) 'As TControl
  
  'Dim hTControl As New TControl
  
  'hTControl.Ctrl = cControl
  $aChild.Add(cControl)
  ReportControl._ObjectFromId[cControl.Id] = cControl
  'Return hTControl
  
End

Public Sub _Remove(id As Integer)
  
  $aChild.Remove($aChild.Find(ReportControl._ObjectFromId[id]))
  
End

Public Sub _Free()
  
End

Public Sub _Raise(hControl As ReportControl)
  
  Dim iPos As Integer
  
  iPos = $aChild.Find(hControl)
  If iPos = -1 Then Return
  $aChild.Remove(iPos)
  $aChild.add(hControl, 0)
  
End

Public Sub _Lower(hControl As ReportControl)
  
  Dim iPos As Integer
  
  iPos = $aChild.Find(hControl)
  If iPos = -1 Then Return
  $aChild.Remove(iPos)
  $aChild.add(hControl)
  
End

Private Function Children_Read() As ReportControl[]
  
  Return $aChild
  
End

Private Function Spacing_Read() As String
  
  Return $sSpacing
  
End

Private Sub Spacing_Write(Value As String)
  
  $sSpacing = Value
  
End

Public Sub _Paint(Page As Integer, X As Float, Y As Float, hControl As TControl, (DataIndex) As Integer)
  
  Dim hChild As TControl
  Dim i As Integer
  
  X += hControl.RealLeft
  Y += hControl.RealTop
  '     Paint.Text(DataIndex, X + 20, Y + 20)
  ' Paint.Brush = Paint.Color(Color.Black)
  ' Paint.Fill
  
  If Not hControl._PageChildren.Exist(Page) Then Return
  'For Each hChild In hControl._PageChildren[Page]
  For i = 0 To hControl._PageChildren[Page].Max
    hchild = hControl._PageChildren[Page][i]
    Me._Index = hchild.Index
    If $bIndexChange Then
      Raise BeforeData
      $bIndexChange = False
    Endif
    hChild.Ctrl._Paintframe(Page, X, Y, hChild, hchild.Index) 'hChild.Index)
    
  Next
  
End

Private Function _Spacing_Read() As Float
  
  Return $fSpacing
  
End

Private Function _RelativeSpacing_Read() As Boolean
  
  Return $bRelativeSpacing
  
End

Public Sub _NormalizeUnits()
  
  Dim hChild As ReportControl
  Dim hSizeParse As TSizeParse
  
  Super._NormalizeUnits()
  
  hSizeParse = New TSizeParse($sSpacing, True)
  $fSpacing = hSizeParse.GetValue()
  $bRelativeSpacing = hSizeParse.IsRelative()
  
  For Each hChild In $aChild
    'hchild.SizeHint = Null
    hChild._NormalizeUnits()
  Next
  
End

Public Sub _GetSizeHints((AvailableW) As Float, (AvailableH) As Float, (TotalWidth) As Float, (TotalHeight) As Float, DataIndex As Integer) As TSizeHint
  
  Dim hMyHints As New TSizeHint
  
  'If Me._SizeInt.StoreSize Then Return Me._SizeInt
  'If Me.tag = "*" Then Stop
  If Me._CurItem > Me.Children.max Then
    
    '   If Me Is ReportSection Then Stop
    Me._CurItem = 0
    '   'Me._DataIndex = 0
  Endif
  Me._Index = DataIndex
  If $bIndexChange Then
    Raise BeforeData
    $bIndexChange = False
  Endif
  Select Case _Arrangement
      
    Case Arrange.Vertical
      Return GetVSizeInt(AvailableW, AvailableH, TotalWidth, TotalHeight, DataIndex)
    Case Arrange.Horizontal
      Return GetHSizeInt(AvailableW, AvailableH, TotalWidth, TotalHeight, DataIndex)
    Case Arrange.Column
      Return GetVSizeInt(AvailableW, AvailableH, TotalWidth, TotalHeight, DataIndex)
    Case Arrange.Fill, Arrange.None
      Return Super._GetSizeHints(AvailableW, AvailableH, TotalWidth, TotalHeight, DataIndex)
      'hMyHints.Height = AvailableH
      'Me._SizeInt.StoreSize = True
      'Me._SizeInt = hMyHints
      Return hMyHints
      
  End Select
  Raise AfterData
  
End

Private Function GetHSizeInt((AvailableW) As Float, (AvailableH) As Float, (TotalWidth) As Float, (TotalHeight) As Float, DataIndex As Integer) As TSizeHint
  
  Dim hChild As ReportControl
  Dim fHeight, fWidth As Float
  Dim hChildHints As TSizeHint
  Dim hMyHints As New TSizeHint
  Dim fSpc As Float
  Dim fMaxSpc As Float
  Dim i As Integer
  'D'abord utiliser la méthode du controle pour définir la taille
  hMyHints = Super._GetSizeHints(AvailableW, AvailableH, TotalWidth, TotalHeight, DataIndex)
  
  'Puis si besoins voir le besoin des enfants
  If Me.Autoresize Or If (Me._Width = 0 And Me._Height = 0) Then
    fSpc = IIf(Me._RelativeSpacing, TotalWidth * Me._Spacing / 100, Me._Spacing)
    'on ajoute la marge supérieur du premier objet
    If Me.Children.Max > 0 Then fWidth += Me.Children[0].Margin._Top
    For i = 0 To Me.Children.Max
      hChild = Me.Children[i]
      hChildHints = hchild._GetSizeHints(AvailableW - fWidth, AvailableH, AvailableW, AvailableH, DataIndex)
      fMaxSpc = Max(fspc, hchild.Margin._Right)
      If i < Me.Children.Max Then fMaxSpc = Max(fMaxSpc, Me.Children[i + 1].Margin._Left)
      fWidth += hChildHints.Width + fMaxSpc
      If fHeight < hChildHints.Height Then fHeight = hChildHints.Height
      'Si l'enfant n'est pas finit alors moi non plus (:-P)
      If hChildHints.NotFinished Then hMyHints.NotFinished = True
    Next
    'Retrait du dernier espace
    If fWidth Then fWidth -= fSpc
    hMyHints.Height = fHeight + Me.Padding._Height + Me.Border._Top + Me.Border._bottom
    hMyHints.Width = fWidth + Me.Padding._Width + Me.Border._Left + Me.Border._Right
  Endif
  
  Return hMyHints
  
End

Private Function GetVSizeInt((AvailableW) As Float, (AvailableH) As Float, (TotalWidth) As Float, (TotalHeight) As Float, DataIndex As Integer) As TSizeHint
  
  Dim hSizeInt As New TSizeHint
  Dim htmpInts As TSizeHint
  Dim hChild As ReportControl         ''Enfants
  Dim fHeight, fSpc, fWidth As Float
  Dim i, j As Integer
  Dim bExitLoop As Boolean
  Dim fMaxSpc As Float
  'Dim IndexKey As String = Str(Me.Id) &/ Str(DataIndex)
  'If Me.Tag = "**" Then Stop
  'D'abord utiliser la méthode du controle pour définir la taille
  hSizeInt = Super._GetSizeHints(AvailableW, AvailableH, TotalWidth, TotalHeight, DataIndex)
  'Circuit court
  If Me.Children.Count = 0 Then Return hSizeInt
  
  fSpc = IIf(Me._RelativeSpacing, TotalHeight * Me._Spacing / 100, Me._Spacing)
  
  ' Si ce n'est pas fait on enregistre la place nécéssaire a tout les éléments fixes
  
  If Not $fFixedSize Then
    'On ajoute la marge superieur du premier objet7
    'If Me.tag = "**" Then Stop
    For i = 0 To Me.Children.Max
      hChild = Me.Children[i]
      If hchild.Fixed Then 
        'On ajoute la marge supérieur du premier objet fixe
        If $fFixedSize = 0 Then $fFixedSize = hchild.Margin._Top 
        htmpInts = hChild._GetSizeHints(AvailableW, AvailableH, AvailableW, AvailableH, DataIndex)
        fMaxSpc = Max(hchild.Margin._Bottom, fspc)
        If i < Me.Children.Max Then fMaxSpc = Max(fMaxSpc, Me.Children[i + 1].Margin._Top)
        $fFixedSize += htmpInts.Height + fMaxSpc
      Endif
    Next
    'If $fFixedSize Then $fFixedSize = Me.Children[0].Margin._Top 
  Endif
  
  'La taille ne peut être inférieur a celle de tout les éléments fixes ou a défaut
  'a celle du premier élément.
  hSizeInt.Height = Max(hSizeInt.Height, $fFixedSize)
  
  'On ajoute la taille des objets fixes précédents
  If $fFixedSize > 0 Then
    fHeight = $fFixedSize
  Else
    'On ajoute la marge supérieur du premier objet listé si aucun objet fixe n'est a l'Horizon
    fHeight = Me.Children[Me._CurItem].Margin._Top
  Endif
  
  'If Me.Tag = "**" Then Stop
  If Me.Autoresize Or If (Me._Width = 0 And Me._Height = 0) Then
    'On définit la taille au besoins des enfants
    For i = Me._CurItem To Me.Children.Max
      hChild = Me.Children[i]
      For j = hchild._DataIndex To hchild._Count - 1
        'If hchild.Tag = "head" Then Print "VDataHint = " & DataIndex
        If hChild.Ignore Then Continue
        If hChild.Fixed Then Continue
        hchild._Index = j
        htmpInts = hChild._GetSizeHints(AvailableW, AvailableH - fHeight, AvailableW, AvailableH, j)
        'Si l'enfant n'est pas terminé alors moi non plus
        If htmpInts.NotFinished Then hSizeInt.NotFinished = True
        fMaxSpc = Max(fspc, hchild.Margin._Bottom)
        If hchild._Count <= 0 Or If j = hchild._Count - 1 Then
          If i < Me.Children.Max Then 
            fMaxSpc = Max(fMaxSpc, Me.Children[i + 1].Margin._Top)
          Endif
        Else
          fMaxSpc = Max(fMaxSpc, hchild.Margin._Top)
        Endif
        
        'on ajoute la hauteur aux besoins
        fHeight += htmpInts.Height + fMaxSpc
        ' If Me.Tag = "**" Then
        '   Print "fHeight , AvailableH : ", fHeight - fMaxSpc, AvailableH
        '   Print "fMaxSpc : ", fMaxSpc
        ' 'If fMaxSpc = 0 Then Stop  
        ' Endif
        
        If fHeight - fMaxSpc > AvailableH Then
          'Les enfants ne loge pas ... on ne peut pas finir
          hSizeInt.NotFinished = True
          bExitLoop = True
          'Print "Avec Parent : " & DataIndex & "         Je loge : " & j  
          Break
        Endif
        'On récupère la largeur de l'enfant le plus large
        If fWidth < htmpInts.Width Then fWidth = htmpInts.Width
      Next
      If bExitLoop Then Break
    Next
    
    'on enlève le dernier espace
    If fHeight > 0 Then fHeight -= fSpc
    'bogue bizzard
    fHeight += 0.01
    
    'On indique la place nécéssaire aux enfants+les éléments fixes
    hSizeInt.Height = fHeight + Me.Padding._Height + Me.Border._Top + Me.Border._Bottom
    hSizeInt.Width = fWidth + Me.Padding._Width + Me.Border._Left + Me.Border._Right
  Endif
  
  'On ne peut pas dépasser la taille disponible (report sur prochaine page)
  'FIXME: Onepiece partially desactivated
  If Not Me.OnePiece Then
    hSizeInt.Height = Min(hSizeInt.Height, AvailableH)
  Endif
  
  hSizeInt.Height = Min(TotalHeight, hSizeInt.Height)
  
  Me._SizeInt = hSizeInt
  ' If Me.Tag = "Boite 2" Then
  ' Print hSizeInt.Height
  ' Stop
  ' Endif
  'If Me.tag = "toto" Then Stop
  ' If hSizeInt.NotFinished = False Then
  '   Print Me.Tag & " : EST FINIT"
  ' Endif
  Return hSizeInt
  
End

Public Sub _Reset()
  
  Dim hChild As ReportControl
  'mise a zéro de l'index de suivit de progression
  Me._CurItem = 0
  'Mise a zéro de l'index de reproduction
  Me._DataIndex = 0
  'Netoyage du layout précédent
  'Me._PageChildren.Clear
  'Nettoyage récurssif des enfants
  For Each hChild In Me.Children
    
    hChild._Reset
    
  Next
  
End

Public Sub _SetChildGeometry(X As Float, Y As Float, W As Float, H As Float, ContPage As Integer, TCont As TControl, bInFixed As Boolean)
  'If Me.Tag = "*" Then Stop
  'Print "Geometry " & Object.Type(Me)
  'If ContPage > 0 Then Return

  Me._Index = TCont.Index
  
  If Me._CurItem > Me.Children.max Then
    '   If Me Is ReportSection Then Stop
    Me._CurItem = 0
    'Me._DataIndex = 0
  Endif
  
  ' If $bIndexChange Then
  '   Raise BeforeData
  '   $bIndexChange = False
  ' Endif
  
  Select Case _Arrangement
    Case Arrange.Vertical
      SetVChildGeometry(X, Y, W, H, ContPage, TCont, bInFixed)
    Case Arrange.Horizontal
      SetHChildGeometry(X, Y, W, H, ContPage, TCont, bInFixed)
    Case Arrange.Column
      Me._SetCChildGeometry(X, Y, W, H, ContPage, TCont, bInFixed)
    Case Arrange.Fill
      SetFChildGeometry(X, Y, W, H, ContPage, TCont, bInFixed)
    Case Arrange.None
      SetNChildGeometry(X, Y, W, H, ContPage, TCont, bInFixed)
  End Select
  Raise AfterData
  
End

Private Function SetFChildGeometry(X As Float, Y As Float, W As Float, H As Float, ContPage As Integer, TCont As TControl, bInFixed As Boolean)
  
  Dim hChild As ReportControl
  Dim hTItem As TControl
  Dim hChildHints As TSizeHint
  Dim aPageItems As New TControl[]
  Dim oChild As Object
  Dim j As Integer
  
  X = Me.Padding._Left + Me.Border._Left
  Y = Me.Padding._Top + Me.Border._Top
  W = W - Me.Padding._Left - Me.Padding._Right - Me.Border._Left - Me.Border._Right
  H = H - Me.Padding._Top - Me.Padding._Bottom - Me.Border._Top - Me.Border._Bottom
  For Each hChild In Me.Children
    hChildHints = hchild._GetSizeHints(W, H, W, H)
    hTItem = New TControl
    hTItem.Ctrl = hchild
    hTItem.SizeHint = hChildHints
    
    Inc Me._CurItem
    aPageItems.Add(hTItem)
    
  Next
  For Each oChild In aPageItems
    oChild._Index = hTItem.Index
    hTItem._SetGeometry(X, Y, W, H)
    hChild._SetChildGeometry(X, Y, W, H, ContPage, hTItem, bInFixed Or Me.Fixed)
    If oChild Is ReportContainer Then
      
      If oChild._CurItem < oChild.Children.count Then
        'Print ochild.tag & " pas fini"
        j = Me.Children.Find(oChild)
        Me._CurItem = Min(j, Me._CurItem)
      Endif
      'ne pas incrémenter la lecture des enfants si je suis dans un élément fixe
      If bInFixed Then ochild._CurItem = 0
    End If
  Next
  
  TCont._PageChildren[ContPage] = aPageItems
  
End

Private Function SetNChildGeometry(X As Float, Y As Float, W As Float, H As Float, ContPage As Integer, TCont As TControl, bInFixed As Boolean)
  
  Dim hChild As ReportControl
  Dim ochild As Object
  Dim hTItem As TControl
  Dim hChildHints As TSizeHint
  Dim aPageItems As New TControl[]
  Dim iX, iY As Integer
  Dim J As Integer
  
  If Me.Children.Count = 0 Then Return

  X = Me.Padding._Left + Me.Border._Left
  Y = Me.Padding._Top + Me.Border._Top
  W = W - Me.Padding._Left - Me.Padding._Right - Me.Border._Left - Me.Border._Right
  H = H - Me.Padding._Top - Me.Padding._Bottom - Me.Border._Top - Me.Border._Bottom
  
  
  For Each hChild In Me.Children
    
    hChildHints = hchild._GetSizeHints(W, H, W, H, TCont.Index)
    hTItem = New TControl
    hTItem.Ctrl = hchild
    hTItem.SizeHint = hChildHints
    Inc Me._CurItem
    aPageItems.Add(hTItem)
    
  Next
  
  For Each hTItem In aPageItems
    oChild = hTItem.Ctrl
    hChildHints = hTItem.SizeHint
    iX = X + IIf(oChild._RelativeLeft, W * oChild._Left / 100, oChild._Left)
    iY = Y + IIf(oChild._RelativeTop, H * oChild._Top / 100, oChild._Top)
    oChild._Index = hTItem.Index
    hTItem._SetGeometry(iX, iY, hChildHints.Width, hChildHints.Height)
    hChild._SetChildGeometry(iX, iY, hChildHints.Width, hChildHints.Height, ContPage, hTItem, bInFixed Or Me.Fixed)
    
    If oChild Is ReportContainer Then
      
      If oChild._CurItem < oChild.Children.count Then
        j = Me.Children.Find(oChild)
        Me._CurItem = Min(j, Me._CurItem)
      Endif
      'ne pas incrémenterla lecture des enfants si je suis dans un élément fixe
      If bInFixed Then ochild._CurItem = 0
    End If
  Next
  TCont._PageChildren[ContPage] = aPageItems
  
End

Private Sub SetHChildGeometry(X As Float, Y As Float, W As Float, H As Float, ContPage As Integer, TCont As TControl, bInFixed As Boolean)
  
  Dim aPageItems As New TControl[] ''Éléments contenu par cette page
  Dim hChildHints As TSizeHint ''Besoins en hauteur/largeur de l'enfant
  Dim hChild As ReportControl  ''Un enfant reportcontrol
  Dim oChild As Object
  Dim TW, fWidth, fSpc As Float
  Dim fExp As Float
  Dim iNExp As Integer
  
  Dim i, j As Integer
  Dim fTmpX, fX, fY As Float
  Dim hTItem As TControl
  Dim fMaxSpc As Float
  Dim fChildX, fChildY, fChildW, fChildH As Float
  'Initialisation des variables
  fSpc = IIf(Me._RelativeSpacing, H * Me._Spacing / 100, Me._Spacing) 'ME._Spacing
  'On retire les marges a la hauteur et les bordures
  H = H - Me.Padding._Top - Me.Padding._Bottom - Me.Border._Top - Me.Border._Bottom
  'Print H
  'on retire a la largeur les paddings (et les bordure ?)
  W = W - Me.Padding._Left - Me.Padding._Right - Me.Border._Left - Me.Border._Right
  
  'On positionne le curseur de position au coin a gauche
  X = Me.Padding._Left + Me.Border._Left
  Y = Me.Padding._Top + Me.Border._Top
  
  'On initialise la largeur totale avec la largeur disponible
  TW = W
  
  For i = 0 To Me.Children.Max
    
    hChild = Me.Children[i]
    
    'hchild._Index = IIf(Me.DataCount > 0, j, TCont.Index)
    hChild._Index = TCont.Index
    hChildHints = hChild._GetSizeHints(w, h, w, h, TCont.Index)
    
    'Si l' éléments ne loge pas on quitte et on oublit
    If TW - hChildHints.Width < 0 Then Break
    
    'Si l'élément n'est pas ignoré
    If Not hChild.Ignore Then
      fMaxSpc = Max(fspc, hchild.Margin._Right)
      If i < Me.Children.Max Then fMaxSpc = Max(fMaxSpc, Me.Children[i + 1].Margin._Left)
      
      TW = TW - hChildHints.Width - fMaxSpc
      'Si il est étendu on en tient compte
      If hChild.Expand Then
        Inc iNExp
        fExp += hChildHints.Width
      Endif
    Endif
    
    'On ajoute l'élément a la page
    hTItem = New TControl
    hTItem.Ctrl = hChild
    hTItem.SizeHint = hChildHints
    hTItem.Index = TCont.Index
    aPageItems.Add(hTItem)
    
  Next
  
  'De toute les façon je ne cherche pas a parcourir tout
  'Les objet donc j'indique que j'ai tout vu
  Me._CurItem = Me.Children.count
  
  If (W - TW) > 0 Then
    TW += fspc
  Endif
  
  fTmpX = X
  If aPageItems.Count > 0 Then 
    fTmpX += aPageItems[0].Ctrl.Margin._Left
    fExp = fExp - aPageItems[0].Ctrl.Margin._Left '- aPageItems[aPageItems.Max].Ctrl.Margin._Right
  Endif
  
  'On va mettre en page a présent
  'On définit la taille des éléments étendus
  If iNexp Then
    fExp = (TW + fExp) / iNexp
  Endif
  
  For i = 0 To aPageItems.Max
    hTItem = aPageItems[i]
    oChild = hTItem.Ctrl
    'Si l'élément est étendu on lui applique la taille répartie
    If oChild.Expand And Not oChild.Ignore Then
      'If Me.Tag = "*" Then Stop
      fWidth = fExp
    Else
      'sinon il maintien sa taille
      fWidth = hTItem.SizeHint.Width
    Endif
    'oChild._Index = hTItem.Index
    If Not oChild.Ignore Then
      fChildH = H - ochild.Margin._Top - oChild.Margin._Bottom
      fChildY = Y + oChild.Margin._Top
      hTItem._SetGeometry(fTmpX, fChildY, fWidth, fChildH)
      oChild._SetChildGeometry(fTmpX, fChildY, fWidth, fChildH, ContPage, hTItem, bInFixed Or Me.Fixed)
      fMaxSpc = Max(fspc, ochild.Margin._Right)
      If i < aPageItems.Max Then fMaxSpc = Max(fMaxSpc, aPageItems[i + 1].Ctrl.Margin._Left)
      fTmpX += fWidth + fMaxspc
    Else
      fX = X + IIf(oChild._RelativeLeft, W * oChild._Left / 100, oChild._Left)
      fY = Y + IIf(oChild._RelativeTop, H * oChild._Top / 100, oChild._Top)
      hTItem._SetGeometry(fX, fY, fWidth, hTItem.SizeHint.Height)
      oChild._SetChildGeometry(fX, fY, fWidth, hTItem.SizeHint.Height, ContPage, hTItem, bInFixed Or Me.Fixed)
    Endif
    
    If oChild Is ReportContainer Then
      If oChild._CurItem <= oChild.Children.max Then
        'Print ochild.tag & " pas fini"
        j = Me.Children.Find(oChild)
        Me._CurItem = Min(Me._CurItem, j)
      Endif
      'ne pas incrémenter la lecture des enfants si je suis dans un élément fixe
      If bInFixed Then ochild._CurItem = 0
      
    Endif
  Next
  
  'On ajoute la page a la collection de page du conteneur
  TCont._PageChildren[ContPage] = aPageItems
  
End

Private Function DataCount_Read() As Integer
  
  Return Me._Count
  
End

Private Sub DataCount_Write(Value As Integer)
  'If value = 0 Then value = 1
  
  Me._Count = Value
  
End

' Public Function _GetIndex() As Integer
'   
'   If Me._Count > 0 Then    'Si c'est moi le répéteur alors je fournis mon index
'     Return Me._Index
'   Else
'     Try Return Me.Parent._GetIndex  'Sinon je ontinue a remonter la lignée jusqu'au répéteur
'   Endif
'   
' End

Private Function _Index_Read() As Integer
  
  Return Super._Index
  
End

Private Sub _Index_Write(Value As Integer)
  
  If Super._Index = Value And If Super._Index > 0 Then Return 
  $bIndexChange = True
  Super._Index = Value
  
End

Private Function _CurItem_Read() As Integer
  
  Return $iCurItem
  
End

Private Sub _CurItem_Write(Value As Integer)
  'Print "_CurItem = " & Value
  'If Me.tag = "Boite 1" And Value = 0 Then Stop
  'If Me.tag = "Boite 1" And ContPage = 1 Then Print "CurItem: " & Me._CurItem
  
  $iCurItem = Value
  
End

Private Function OnePiece_Read() As Boolean
  
  Return $bOnePiece
  
End

Private Sub OnePiece_Write(Value As Boolean)
  
  $bOnePiece = Value
  
End

Public Sub _SetCChildGeometry(X As Float, Y As Float, W As Float, H As Float, ContPage As Integer, TCont As TControl, bInFixed As Boolean)
  
End

Private Sub SetVChildGeometry(X As Float, Y As Float, W As Float, H As Float, ContPage As Integer, TCont As TControl, bInFixed As Boolean)
  
  Dim aPageItems As New TControl[] ''Éléments contenu par cette page
  Dim hChildHints As TSizeHint ''Besoins en hauteur/largeur de l'enfant
  Dim hChild As ReportControl  ''Un enfant reportcontrol
  Dim fTH As Float ''Hauteur restante
  Dim fSpc As Float ''Taille d'un espace
  Dim hTItem As TControl ''Un objet virtuel
  Dim oChild As Object  ''Un objet gambas générique
  Dim fExp As Float ''taille des objets étendus
  Dim iNExp As Integer ''Nombre d'objets étendus
  Dim ftmpHeight As Float ''Tampon pour le calcul de la taille répartie
  Dim ftmpY As Float  ''Curseur temporaire de position haute
  Dim fX, fY As Float  ''Tampon de position
  Dim i, j As Integer  ''Des indexs
  Dim bExitLoop As Boolean ''Flag de sortie de traitement
  Dim bForceNewPage As Boolean ''Flag d'anticipation de sortie 1 par page
  Dim iPreIndex As Integer
  Dim fMaxSpc As Float   ''Résultat de la comparaison ds espaces (marges/spacing)
  Dim fChildX, fChildW As Float
  Dim iIndex As Integer
  Dim bFirst As Boolean
  Dim hSizeInt As Boolean
  Dim bTop As Boolean
  Dim fPrevTH As Float
  Dim cChildFixe As New Collection
  Dim iVal As Integer
  'Dim IndexKey As String = Str(Me.Id) &/ Str(TCont.Index)
  
  'Détermination de la taille d'un espace
  'et prise en compte de la taille relative
  fSpc = IIf(Me._RelativeSpacing, H * Me._Spacing / 100, Me._Spacing)
  
  'Retrait du padding et des bordures de la hauteur de travail
  H = H - Me.Padding._Top - Me.Border._Top - Me.Border._Bottom - Me.Padding._Bottom
  
  'Retrait du padding et des bordures a la largeur de travail
  W = W - Me.Padding._Left - Me.Border._Left - Me.Border._Right - Me.Padding._Right
  
  'Positioinnement du curseur en haut a gauche
  X = Me.Padding._Left + Me.Border._Left
  Y = Me.Padding._Top + Me.Border._Top
  
  'La hauteur restante est initialisée avec la hauteur de travail
  fTH = H
  
  'On énumère tout les éléments an tête en ne retenant que les fixes
  For i = 0 To Me.Children.Max
    hchild = Me.Children[i]
    If hchild.Fixed Then
      cChildFixe[j] = hchild
      Inc j
    Endif
  Next
  
  j = 0
  
  For i = 0 To Me.Children.Max
    hchild = Me.Children[i]
    'If Not hchild._DataIndex.Exist(IndexKey) Then hchild._DataIndex[IndexKey] = 0
    If hchild.Fixed Then
      
      If Not bTop And If i < Me._CurItem Then
        fTH = fTH - Me.Children[i].Margin._Top
        bTop = True
      Endif
      'trouver le fixe suivant
      For j = i + 1 To Me._CurItem
        If Me.Children[j].Fixed Then 
          iVal = j
          Break
        Endif
      Next
      'Si le fixe suivant n'est pas définit alors on utlise l'objet suivant
      If Not iVal Then iVal = i + 1
      
      fMaxSpc = Max(hchild.Margin._Bottom, fspc)
      If i < Me.Children.Max Then fMaxSpc = Max(fMaxSpc, Me.Children[i + 1].Margin._Top)
      'Calcul de l'espace interobjet (c'est a dire la plus grande valeur entre la marge basse de l'objet,
      'le spacing, et la marge haute de l'objet suivant.)
      
      hChildHints = hchild._GetSizeHints(W, fTH, W, H, TCont.Index)
      
      If Not hchild.Ignore Then fTH -= hChildHints.Height + fMaxSpc
      If i < Me._CurItem Then
        'Génération de l'objet virtuel
        hTItem = New TControl
        'Lier l'objet
        hTItem.Ctrl = hchild
        'Associer sa taille
        hTItem.SizeHint = hChildHints
        'TODO: Restorer
        'hTItem.Index = TCont.Index
        hTItem.Index = iIndex
        Inc iIndex
        'L'ajouter a la page
        aPageItems.Add(hTItem)
        
        'Si l'objet est étendu alors on en tient compte 
        'sauf si celui-ci est ignoré par l'arrangement
        If hchild.Expand And If Not hchild.Ignore Then
          fExp += hChildHints.Height
          Inc iNExp
        Endif
        
      Endif
      
    Endif
  Next
  'If ContPage = 2 And Me.Tag = "**" Then Stop
  'On parcour les élément de l'index a la fin
  For i = Me._CurItem To Me.Children.Max
    
    If Not bTop Then
      fTH = fTH - Me.Children[i].Margin._Top
      bTop = True
    Endif
    hchild = Me.Children[i]
    'Je traite ici la boucle de clonage
    'On définit le point de départ
    'If ContPage = 1 And hchild.Tag = "**" Then Stop
    j = hChild._DataIndex
    'hchild._PageDataIndex = hchild._DataIndex
    Do
      'Calcul de l'espace interobjet (c'est a dire la plus grande valeur entre la marge basse de l'objet,
      'le spacing, et la marge haute de l'objet suivant.)
      fMaxSpc = Max(hchild.Margin._Bottom, fspc)
      'Définit l'espace en fonction du contexte
      If hchild._Count > 0 And If j <= hchild._count - 1 Then
        fMaxSpc = Max(fMaxSpc, Me.Children[i].Margin._Top)
      Else
        If i < Me.Children.Max Then fMaxSpc = Max(fMaxSpc, Me.Children[i + 1].Margin._Top)
      Endif
      'If Me.Tag = "**" And j = 3 Then Stop
      'If TCont.Index = 2 Then Stop
      'If ContPage = 2 And Me.Tag = "**" Then Stop
      hChildHints = hchild._GetSizeHints(W, fTH, W, H, TCont.Index)
      'If ContPage = 2 And Me.Tag = "**" Then Print fTH, hChildHints.Height
      'Les éléments fixes ont déja été traités on ne tient donc pas compte de leur hauteur
      'car elle a déja été déduite de l'espace restant. De meme on ignore les objets flottants (ignore=true)
      If Not hchild.Fixed And If Not hchild.Ignore Then
        'Si l'élément ne loge pas dans la place restante ou
        'si la place restante est insuffisante
        'on provoque la sortie en fin de boucle
        If fTH - hChildHints.Height <= 0 Or If bForceNewPage Then 
          ' Debug "Lélément index : " & j & " Ne loge pas dans le conteneur"
          ' Debug "fTH : " & fTH
          ' Debug "fTH - hChildHints.Height : " & (fTH - hChildHints.Height)
          ' Print
          If Not bFirst Then
            'SI il est le premier de la série alors il doit loger dans la page coute que coute
            hChildHints.Height = fTH - hchild.Margin._bottom
          Else
            
            bForceNewPage = False
            hchild._DataIndex = j
            
            bExitLoop = True
            Break
          Endif
        Endif
        bFirst = True
        fTH = fTH - hChildHints.Height - fMaxSpc
      Endif
      'On l'ajoute a la page
      'Génération de l'objet virtuel
      hTItem = New TControl
      'Lier l'objet
      hTItem.Ctrl = hchild
      'Associer sa taille
      hTItem.SizeHint = hChildHints
      'TODO: Restorer
      'hTItem.Index = TCont.Index
      hTItem.Index = j 'iIndex
      Inc iIndex
      'L'ajouter a la page
      aPageItems.Add(hTItem)
      
      'Si l'objet est étendu alors on en tient compte 
      'sauf si celui-ci est ignoré par l'arrangement
      If hchild.Expand And If Not hchild.Ignore Then
        fExp += hChildHints.Height 
        Inc iNExp
      Endif
      'If hChildHints.NotFinished Then hchild._DataIndex = j
      'un élément fixe ou ignore ne peut être répété
      If hchild.Fixed Or hchild.Ignore Then Break
      
      'Sachant que hChild._count peut être à -1 on le considère dans ce cas la comme étant a 0
      'si j est égale au compte alors on quitte la boucle
      If j >= Max(hchild._Count - 1, 0) Then 
        'Remise a 0 si le contenu de l 'enfant est entièrement affiché
        If Not hChildHints.NotFinished Then 
          hChild._DataIndex = 0 
        Endif
        Break
      Endif
      'sinon on incrémente le compte a condition que le dernier enfant aie finit d'afficher ses enfants
      If Not hChildHints.NotFinished Then Inc j
      
      'On prévoie un sortie de boucle si l'enfant demande un affichage 1 par page
      If hchild.ForceNewPage Then bForceNewPage = True
      
      ' If fTH = 0 Then 
      '   hchild._DataIndex = j
      '   Break
      '   bExitLoop = True
      ' Endif
      
    Loop
    'Si la sortie anticipé est demandée alors on sort de la boucle
    'If bExitLoop Then Stop
    If bExitLoop Then Break
    
    'Si l'objet suivant est un objet spécial de rupture de page alors
    'On force la rupture de page
    If i < Me.Children.Max And If Me.Children[i + 1] Is ReportPageBreak Then
      Inc Me._CurItem
      bForceNewPage = True
      Inc i  'on saute l'objet.
    Endif
    
    'Enfin on incrémente la variable de saugarde de l'objet en cour.
    'If Me.Tag = "**" Then Debug "Inc"
    Inc Me._CurItem
    
  Next
  '***************************************************************************
  'Pour tous les éléments fixes jusqu'à la fin du document
  For i = Max(Me._CurItem, 0) To Me.Children.Max
    hchild = Me.Children[i]
    If hchild.Fixed Then
      fMaxSpc = Max(hchild.Margin._Bottom, fspc)
      If i < Me.Children.Max Then fMaxSpc = Max(fMaxSpc, Me.Children[i + 1].Margin._Top)
      hChildHints = hchild._GetSizeHints(W, fPrevTH, W, H, iPreIndex)
      'on génère l'objet virtuel
      hTItem = New TControl
      'On associe le controle
      hTItem.Ctrl = hchild
      'On associe sa taille
      hTItem.SizeHint = hChildHints
      'NOTE: Restorer
      hTItem.Index = iIndex
      Inc iIndex
      'On l'ajoute a la page
      aPageItems.Add(hTItem)
      
      'Si l'objet est étendu alors on tien compte de sa taille
      'pour le calcul de l'espace réparti
      If hchild.Expand Then
        fExp += hChildHints.Height
        Inc iNExp
      Endif
      fPrevTH = fPrevTH - fMaxSpc
    Endif
  Next
  
  'Si on est en mode spacing alors le dernier expace doit être enlevé
  If fspc > 0 And If fMaxSpc = fspc Then
    fTH += fSpc
  Endif
  
  '******************************************************************************
  'A présent tous les éléments pouvant être placé sur la page ont été marqué.
  'On peut donc procéder a la mise en forme de ceux-ci
  
  ftmpY = Y  'On définit la position de départ
  If aPageItems.Count > 0 Then 
    fTmpY += aPageItems[0].Ctrl.Margin._Top
    'fExp = fExp - aPageItems[0].Ctrl.Margin._Top '- aPageItems[aPageItems.Max].Ctrl.Margin._Right
  Endif 
  If iNExp Then
    fExp = (fExp + fTH) / iNExp
  Endif
  
  For i = 0 To aPageItems.Max
    'on récupère l'objet virtuel
    hTItem = aPageItems[i]
    'on récupère l'instance de l'objet réel
    ochild = hTItem.Ctrl
    
    'Si l'objet est étendu alors on calcul sa hauteur
    'Un objet flottant ne peut pas être étendu
    If Not oChild.Ignore And If ochild.Expand Then
      'Calcul de la taille répartie
      ftmpHeight = fExp
    Else
      'Si l'objet n'est pas étendu alors sa taille est celle demandée par celui-ci
      ftmpHeight = hTItem.SizeHint.Height
    Endif
    'oChild._Index = hTItem.Index
    'Traitement des objets ignoré
    'Les propriété de taille sont celle fournie par l'objet
    If oChild.Ignore Then
      'Calcul de la position de l'objet
      'si sa position est relative (%) alors on fait le ratio a partir de la largeur ou de la hauteur
      'sinon on utilise la position fournie par l'objet
      fX = X + IIf(oChild._RelativeLeft, W * oChild._Left / 100, oChild._Left)
      fY = Y + IIf(oChild._RelativeTop, H * oChild._Top / 100, oChild._Top)
      'Fixer la position de l'objet
      hTItem._SetGeometry(fX, fY, hTItem.SizeHint.Width, ftmpHeight)
      'L'objet flottant peut être un conteneur il faut donc demander aussi a ses enfants de s 'organiser
      oChild._SetChildGeometry(fX, fY, hTItem.SizeHint.Width, ftmpHeight, ContPage, hTItem, bInFixed Or Me.Fixed)
      
    Else
      fChildX = X + oChild.Margin._Left
      fChildW = W - oChild.Margin._Left - oChild.Margin._Right
      'Fixer la position de l'objet
      hTItem._SetGeometry(fChildX, fTmpY, fChildW, ftmpHeight)
      'L'objet flottant peut être un conteneur il faut donc demander aussi a ses enfants de s 'organiser
      oChild._SetChildGeometry(fChildX, fTmpY, fChildW, ftmpHeight, ContPage, hTItem, bInFixed Or Me.Fixed)
      'Calcul de l'espace interobjet (c'est a dire la plus grande valeur entre la marge basse de l'objet,
      'le spacing, et la marge haute de l'objet suivant.)
      fMaxSpc = Max(ochild.Margin._Bottom, fspc)
      If i < aPageItems.Max Then fMaxSpc = Max(fMaxSpc, aPageItems[i + 1].Ctrl.Margin._Top)
      'on incrémente la position verticale de l'objet
      'pour définir sa place sur la page relativement aux autres éléments
      fTmpY += ftmpHeight + fMaxSpc
      
    Endif
    
    'Si l'objet est un conteneur alors il faut vérifier si il a finit d'être traité
    
    If oChild Is ReportContainer Then
      'If oChild._NotFinished Then Me.NotFinished = True
      'Si son traitement n'est pas terminé alors on trouve
      'sa position dans la liste des enfant et on l'assigne a l'index de traitement
      'si sa position est > a l'index courant
      'If oChild.Tag = "VB1" Then Stop
      If ochild._CurItem <= oChild.Children.Max Then
        j = Me.Children.Find(oChild)
        Me._CurItem = Min(Me._CurItem, j)
      Endif
      'Si on est dans la lignée d'un conteneur fixe on incrémente pas la lecture des enfants
      'En clair ce sont toujours les mêmes éléments qui apparaitrons
      If bInFixed Then ochild._CurItem = 0
    Endif
  Next
  'On ajoute cette page au dossier du conteneur
  TCont._PageChildren[ContPage] = aPageItems
  
End