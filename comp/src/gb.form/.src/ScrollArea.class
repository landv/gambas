' Gambas class file

Export
Inherits UserContainer

Public Const _Properties As String = "*,Border=True,ScrollBar{Scroll.*}=Both,Painted,Focus,NoBackground,Tablet"
Public Const _DefaultEvent As String = "Draw"
Public Const _DefaultSize As String = "24,24"
Public Const _Similar As String = "DrawingArea,ScrollView"
'Public Const _Group As String = "View"

Property ScrollX As Integer
Property ScrollY As Integer
Property Read ScrollWidth, ScrollW As Integer
Property Read ScrollHeight, ScrollH As Integer

' Property Read ClientWidth As Integer
' Property Read ClientHeight As Integer
' Property Read ClientW As Integer
' Property Read ClientH As Integer

Property Border As Boolean
Property Focus As Boolean
Property Painted As Boolean
Property NoBackground As Boolean
Property ScrollBar As Integer
Property Tracking As Boolean
Property Background As Integer
Property Tablet As Boolean
Property Shadow As Boolean
Property Read View As DrawingArea

Event Scroll
Event Draw

Static Private $hFadeN As Picture
Static Private $hFadeS As Picture
Static Private $hFadeW As Picture
Static Private $hFadeE As Picture
Static Private $iFadeColor As Integer = -1

Private $hDrawingArea As DrawingArea
Private $hHBar As ScrollBar
Private $hVBar As ScrollBar
Private $hObserver As Observer
Private $iScroll As Integer = Scroll.Both
Private $iBackground As Integer = Color.Default
Private $bBorder As Boolean 
Private $bPainted As Boolean

Private $W As Integer
Private $H As Integer

Private $bShadow As Boolean
Private $iShadowN As Integer
Private $iShadowS As Integer
Private $iShadowW As Integer
Private $iShadowE As Integer

'Static Private $iArrangeCount As Integer

Private Sub LoadFades()
  
  Dim hImage As Image
  Dim Y As Integer
  Dim iColor As Integer
  
  iColor = Color.Desaturate(If(Me.Foreground = Color.Default, Color.TextForeground, Me.Foreground))
  
  If iColor = $iFadeColor Then Return
  
  hImage = New Image(32, 8, Color.Transparent)
  For Y = 0 To 7
    hImage.FillRect(0, Y, hImage.W, 1, Color.SetAlpha(iColor, 160 + Y * 12))
  Next
  
  $hFadeN = hImage.Picture
  hImage.RotateLeft
  $hFadeW = hImage.Picture
  hImage.RotateLeft
  $hFadeS = hImage.Picture
  hImage.RotateLeft
  $hFadeE = hImage.Picture
  
  $iFadeColor = iColor
  
End


Public Sub _new()
  
  Me.Arrangement = Arrange.None
  
  '$hBorder = New DrawingArea(Me) As "Border"
  '$hBorder.Arrangement = Arrange.Fill

  $hDrawingArea = New DrawingArea(Me) As "DrawingArea"
  $hObserver = New Observer(Me) As "ScrollArea"
  
  $hHBar = New ScrollBar(Me) As "Scrollbar"
  $hHBar.Step = Desktop.Scale
  $hVBar = New ScrollBar(Me) As "Scrollbar"
  $hVBar.Step = Desktop.Scale
  
  Me.Proxy = $hDrawingArea
  Me._Container = $hDrawingArea

  Border_Write(True)
  'ScrollArea_Arrange
  '
  'Debug "<<<<<"
  
End

Public Sub ScrollArea_Arrange()
  
  Dim SB, SP, FW, W, H, P As Integer
  Dim bHBarAllowed, bVBarAllowed As Boolean
  Dim OW, OH As Integer
  ' Dim hChild As Control
  ' Dim iMargin As Integer
  
  ' Inc $iArrangeCount
  ' Print Format($iArrangeCount, "###0");; System.Backtrace.Join(" ")
  
  'Debug "ScrollArea:";; Me.W;; Me.H
  'Debug "DrawingArea:";; $hDrawingArea.W;; $hDrawingArea.H
  
  'Error "\t" & System.Backtrace.Join("\n\t")
  
  ' If $hDrawingArea.Children.Count Then
  '   iMargin = If($hDrawingArea.Margin, If($hDrawingArea.Padding, $hDrawingArea.Padding, Desktop.Scale), 0)
  '   For Each hChild In $hDrawingArea.Children
  '     If Not hChild.Visible Then Continue
  '     $W = Max($W, hChild.X + hChild.W + iMargin)
  '     $H = Max($H, hChild.Y + hChild.H + iMargin)
  '   Next
  ' Endif
  
  SB = Style.ScrollbarSize
  SP = Style.ScrollbarSpacing
  'If $bBorder Then FW = Style.FrameWidth
  
  bHBarAllowed = $iScroll = Scroll.Horizontal Or $iScroll = Scroll.Both
  bVBarAllowed = $iScroll = Scroll.Vertical Or $iScroll = Scroll.Both

RETRY:
  
  W = Me.Width - FW * 2
  H = Me.Height - FW * 2
  'Debug W;; H;; "/";; $W;; $H
  
  If W >= $W And If H >= $H Then
    
    $hHBar.MinValue = 0
    $hHBar.MaxValue = 0
    $hVBar.MinValue = 0
    $hVBar.MaxValue = 0
    $hHBar.Hide
    $hVBar.Hide
    
  Else If bHBarAllowed And If $W > W And If $H <= (H - SB - SP) Then
    
    $hHBar.MinValue = 0
    $hHBar.MaxValue = $W - W
    $hHBar.PageStep = W
    $hVBar.MinValue = 0
    $hVBar.MaxValue = 0
    $hHBar.Show
    $hVBar.Hide
    
  Else If bVBarAllowed And If $H > H And If $W <= (W - SB - SP) Then
    
    $hVBar.MinValue = 0
    $hVBar.MaxValue = $H - H
    $hVBar.PageStep = H
    $hHBar.MinValue = 0
    $hHBar.MaxValue = 0
    $hVBar.Show
    $hHBar.Hide
    
  Else 
    
    $hHBar.MinValue = 0
    If bVBarAllowed Then
      P = W - SB - SP
    Else
      P = W
    Endif
    If $W > P Then
      $hHBar.MaxValue = $W - P
      $hHBar.PageStep = P
      $hHBar.Visible = bHBarAllowed
    Else
      $hHBar.Hide
    Endif
    
    
    $hVBar.MinValue = 0
    If bHBarAllowed Then
      P = H - SB - SP
    Else
      P = H 
    Endif
    If $H > P Then
      $hVBar.MaxValue = $H - P
      $hVBar.PageStep = P
      $hVBar.Visible = bVBarAllowed
    Else
      $hVBar.Hide
    Endif
    
  Endif
  
  If $hHBar.Visible Then H -= SB + SP
  If $hVBar.Visible Then W -= SB + SP
  
  W += FW * 2
  H += FW * 2
  
  If W <> OW Or If H <> OH Then
    OW = W
    OH = H
    Goto RETRY
  Endif
  
  $hDrawingArea.Move(0, 0, W, H)
  If $hHBar.Visible Then $hHBar.Move(0, H + SP, W, SB)
  If $hVBar.Visible Then $hVBar.Move(W + SP, 0, SB, H)
  
  'Debug "DrawingArea: -> ";; $hDrawingArea.W;; $hDrawingArea.H
  
End

Public Sub ResizeContents(Width As Integer, Height As Integer)
  
  If $W = Width And If $H = Height Then Return 
  
  $W = Width
  $H = Height
  ScrollArea_Arrange
  $hDrawingArea.Refresh
  
End


Private Function ScrollX_Read() As Integer

  Return $hHBar.Value

End

Private Sub ScrollX_Write(Value As Integer)

  Scroll(Value, $hVBar.Value)

End

Private Function ScrollY_Read() As Integer

  Return $hVBar.Value

End

Private Sub ScrollY_Write(Value As Integer)

  Scroll($hHBar.Value, Value)

End

Public Sub Scroll(X As Integer, Y As Integer)
  
  If $hHBar.Value = X And If $hVBar.Value = Y Then Return
  $hHBar.Value = X
  $hVBar.Value = Y
  'Debug X;; Y
  'Error "\t" & System.Backtrace.Join("\n\t")
  $hDrawingArea.Refresh
  
End

Public Sub DrawingArea_Draw()
  
  Dim FW As Integer
  Dim hClip As Rect
  Dim hFrame As Rect
  
  If $bBorder Then FW = Style.FrameWidth
  
  If $iBackground <> Color.Default Then 
    Draw.FillRect(FW, FW, Draw.W - FW * 2, Draw.H - FW * 2, $iBackground)
  Endif
  
  'Debug Draw.Clip.X;; Draw.Clip.Y;; Draw.Clip.W;; Draw.Clip.H
  
  hClip = New Rect(Draw.Clip.X, Draw.Clip.Y, Draw.Clip.W, Draw.Clip.H)
  hFrame = New Rect(FW, FW, Draw.W - FW * 2, Draw.H - FW * 2)
  hClip = hClip.Intersection(hFrame)
  
  If hClip Then

    Draw.Clip(hClip.X, hClip.Y, hClip.W, hClip.H)

    If $bPainted Then Paint.Begin($hDrawingArea)
    Raise Draw
    If $bPainted Then Paint.End

    If $bShadow Then
      
      ' Draw.Clip(hClip.X, hClip.Y + $iShadowN, hClip.W, hClip.H - $iShadowN - $iShadowS)
      ' If $hVBar.Value > $hVBar.MinValue Then Draw.Tile($hFadeN, 0, $iShadowN - Max(0, 16 - ($hVBar.Value - $hVBar.MinValue)), Draw.W, 16)
      ' If $hVBar.Value < $hVBar.MaxValue Then Draw.Tile($hFadeS, 0, Draw.H - 16 - $iShadowS + Max(0, 16 - ($hVBar.MaxValue - $hVBar.Value)), Draw.W, 16)
      ' 
      ' Draw.Clip(hClip.X + $iShadowW, hClip.Y, hClip.W - $iShadowW - $iShadowE, hClip.H)
      ' If $hHBar.Value > $hHBar.MinValue Then Draw.Tile($hFadeW, $iShadowW - Max(0, 16 - ($hHBar.Value - $hHBar.MinValue)), 0, 16, Draw.H)
      ' If $hHBar.Value < $hHBar.MaxValue Then Draw.Tile($hFadeE, Draw.W - 16 - $iShadowE + Max(0, 16 - ($hHBar.MaxValue - $hHBar.Value)), 0, 16, Draw.H)
  
      If $hVBar.Visible Then
        LoadFades()
        Draw.Clip(hClip.X + $iShadowW, hClip.Y + $iShadowN, hClip.W - $iShadowW - $iShadowE, hClip.H - $iShadowN - $iShadowS)
        If $hVBar.Value > $hVBar.MinValue Then Draw.Tile($hFadeN, 0, $iShadowN - Max(0, $hFadeN.H - ($hVBar.Value - $hVBar.MinValue)), Draw.W, $hFadeN.H)
        If $hVBar.Value < $hVBar.MaxValue Then Draw.Tile($hFadeS, 0, Draw.H - $hFadeS.H - $iShadowS + Max(0, $hFadeS.H - ($hVBar.MaxValue - $hVBar.Value)), Draw.W, $hFadeS.H)
      Endif
      
      If $hHBar.Visible Then
        LoadFades()
        Draw.Clip(hClip.X + $iShadowW, hClip.Y + $iShadowN, hClip.W - $iShadowW - $iShadowE, hClip.H - $iShadowN - $iShadowS)
        If $hHBar.Value > $hHBar.MinValue Then Draw.Tile($hFadeW, $iShadowW - Max(0, $hFadeW.W - ($hHBar.Value - $hHBar.MinValue)), 0, $hFadeW.W, Draw.H)
        If $hHBar.Value < $hHBar.MaxValue Then Draw.Tile($hFadeE, Draw.W - $hFadeE.W - $iShadowE + Max(0, $hFadeE.W - ($hHBar.MaxValue - $hHBar.Value)), 0, $hFadeE.W, Draw.H)
      Endif
      
    Endif

    Draw.Clip.Enabled = False

  Endif
  
  If $bBorder Then 
    Draw.Reset
    'Draw.Style.Box(0, 0, Draw.W, Draw.H)
    Draw.Style.Panel(0, 0, Draw.W, Draw.H, Border.Sunken, If(Me.HasFocus, Draw.Focus, Draw.Normal))
  Endif
  
End

Public Sub Scrollbar_Change()
  
  Raise Scroll
  $hDrawingArea.Refresh
  
End

Private Function Border_Read() As Boolean

  Return $bBorder

End

Private Sub Border_Write(Value As Boolean)

  $bBorder = Value
  ScrollArea_Arrange
  $hDrawingArea.Refresh

End

Private Function Focus_Read() As Boolean

  Return $hDrawingArea.Focus

End

Private Sub Focus_Write(Value As Boolean)

  $hDrawingArea.Focus = Value

End

Private Function Painted_Read() As Boolean

  Return $bPainted

End

Private Sub Painted_Write(Value As Boolean)

  $bPainted = Value

End

Private Function NoBackground_Read() As Boolean

  Return $hDrawingArea.NoBackground

End

Private Sub NoBackground_Write(Value As Boolean)

  $hDrawingArea.NoBackground = Value

End

Private Function Scrollbar_Read() As Integer

  Return $iScroll

End

Private Sub Scrollbar_Write(Value As Integer)

  If $iScroll < Scroll.None Or If $iScroll > Scroll.Both Then Return
  $iScroll = Value
  ScrollArea_Arrange

End

Private Function ScrollWidth_Read() As Integer

  Return $W

End

Private Function ScrollHeight_Read() As Integer

  Return $H

End

Private Function Tracking_Read() As Boolean

  Return $hDrawingArea.Tracking

End

Private Sub Tracking_Write(Value As Boolean)

  $hDrawingArea.Tracking = Value
  Super.Tracking = Value

End

Public Sub DrawingArea_MouseWheel()
  
  If Not Me.Enabled Or If Me.Design Then Return
  
  If Mouse.Orientation = Mouse.Horizontal Or If $H <= $hDrawingArea.H Then
    $hHBar.Value -= Mouse.Delta * $hHBar.PageStep / 4
  Else
    $hVBar.Value -= Mouse.Delta * $hVBar.PageStep / 4
  Endif
  
End

Public Sub EnsureVisible(X As Integer, Y As Integer, W As Integer, H As Integer)
  
  Dim PW, PH, CX, CY, CW, CH, FW As Integer
  
  'Debug X;; Y;; W;; H;; "[";; $hDrawingArea.W;; $hDrawingArea.H;; "]"
  
  W = (W + 1) / 2
  H = (H + 1) / 2
  X = X + W
  Y = Y + H

  If $bBorder Then FW = Style.FrameWidth
  
  PW = $hDrawingArea.W - FW * 2
  PH = $hDrawingArea.H - FW * 2

  CX = - Me.ScrollX
  CY = - Me.ScrollY
  CW = Me.ScrollWidth
  CH = Me.ScrollHeight

  If PW < (W * 2) Then W = PW / 2
  If PH < (H * 2) Then H = PH / 2

  If CW <= PW Then
    W = 0
    CX = 0
  Endif
  
  If CH <= PH Then
    H = 0
    CY = 0
  Endif

  If X < (- CX + W) Then
    CX = - X + W
  Else If X >= (- CX + PW - W) Then
    CX = - X + PW - W
  Endif
  
  If Y < (- CY + H) Then
    CY = - Y + H
  Else If Y >= (- CY + PH - H) Then
    CY = - Y + PH - H
  Endif

  If CX > 0
    CX = 0
  Else If CX < (PW - CW) And If CW > PW Then
    CX = PW - CW
  Endif

  If CY > 0 Then
    CY = 0
  Else If CY < (PH - CH) And If CH > PH Then
    CY = PH - CH
  Endif

  Scroll(- CX, - CY)
  
End

Private Function Background_Read() As Integer

  Return $iBackground

End

Private Sub Background_Write(Value As Integer)

  $iBackground = Value
  $hDrawingArea.Refresh

End

Private Function View_Read() As DrawingArea

  Return $hDrawingArea

End

Public Sub _SetShadowOffset(North As Integer, South As Integer, West As Integer, East As Integer)
  
  $iShadowN = North
  $iShadowS = South
  $iShadowW = West
  $iShadowE = East
  
End

Private Function Tablet_Read() As Boolean

  Return $hDrawingArea.Tablet

End

Private Sub Tablet_Write(Value As Boolean)

  $hDrawingArea.Tablet = Value

End

Private Function Shadow_Read() As Boolean

  Return $bShadow

End

Private Sub Shadow_Write(Value As Boolean)

  $bShadow = Value

End
