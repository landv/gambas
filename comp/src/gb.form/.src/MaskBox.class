' Gambas class file

Export

Inherits TextBox

Public Const _Properties As String = "*,-Password,-MaxLength,Action,Mask,ShowDefault"
'Public Const _DefaultEvent As String = "Click"
'Public Const _DefaultSize As String = "24,4"
Public Const _Similar As String = "TextBox"
Public Const _DrawWith As String = "TextBox"

Property Mask As String
Property ShowDefault As Boolean
'Property Text As String

Private $hObserver As Observer

Private Const MASK_CHARACTER As String = "90A6?"
Private Const MASK_DEFAULT As String = "_0___"
Private Const UNMASKED_CHAR As String = "\xFF"

Private $sMaskOrg As String

Private $aMask As New String[]
Private $sDefault As String
Private $sSeparator As String
Private $sAlign As String

Private $iPosFocus As Integer
Private $bShowDefault As Boolean

Public Sub _new()
  
  $hObserver = New Observer(Me) As "TextBox"
  
End

Private Function Mask_Read() As String

  Return $sMaskOrg

End

Private Sub GetDefaultCharacter(iPos As Integer) As String
  
  Dim sCar As String = String.Mid$($sDefault, iPos + 1, 1)
  If sCar = "." Then sCar = String.Mid$($sSeparator, iPos + 1, 1)
  Return sCar
  
End


Private Sub MakeDefault() As String
  
  Dim sDefault As String
  Dim iInd As Integer
  
  For iInd = 0 To $aMask.Max
    sDefault &= GetDefaultCharacter(iInd)
  Next
  
  Return RTrim(sDefault)
  
End

Private Sub GetFirstCharacterPos() As Integer
  
  Dim iPos As Integer
  
  For iPos = 0 To $aMask.Max
    If $aMask[iPos] Then Return iPos
  Next
  
End

Private Sub GetLastCharacterPos() As Integer
  
  Dim iPos As Integer
  
  For iPos = $aMask.Max DownTo 0
    If $aMask[iPos] Then Return iPos + 1
  Next
  
End

Private Sub UpdateMaskAndSeparator(sMask As String)
  
  Dim iPos, iPos2 As Integer
  Dim sCar As String
  Dim iLen As Integer
  Dim aMask As New String[]
  Dim sSeparator As String
  Dim sAlign As String
  Dim sDefault As String
  Dim iPosFocus As Integer

  iLen = String.Len(sMask)

  For iPos = 1 To iLen
    sCar = String.Mid$(sMask, iPos, 1)
    If sCar = "[" Then
      iPos2 = String.InStr(sMask, "]", iPos)
      If iPos2 = 0 Then Error.Raise("Bad mask")
      aMask.Add(String.Mid$(sMask, iPos, iPos2 - iPos + 1))
      iPos = iPos2
      sSeparator &= " "
      sDefault &= " "
      Continue
    Else If sCar = "<" Then
      If aMask.Count And If aMask[aMask.Max] Then
        sAlign &= Space$(aMask.Count - 1 - Len(sAlign)) & "<"
      Endif
    Else If sCar = "!" Then
      iPosFocus = aMask.Count
    Else If sCar = "?" Then
      aMask.Add(sCar)
      sSeparator &= " "
      sDefault &= " "
    ' Else If sCar = "0" Then
    '   aMask.Add("[0-9]")
    '   sSeparator &= " "
    '   sDefault &= "0"
    Else If sCar = "0" Then
      aMask.Add("[0-9]")
      sSeparator &= " "
      sDefault &= "0"
    Else If sCar = "#" Or If sCar = "9" Then
      aMask.Add("[0-9]")
      sSeparator &= " "
      sDefault &= " "
    Else If sCar = "A" Then
      aMask.Add("[A-Za-z]")
      sSeparator &= " "
      sDefault &= " "
    Else If sCar = "\\" And If iPos < iLen Then
      aMask.Add("")
      Inc iPos
      sSeparator &= String.Mid$(sMask, iPos, 1)
      sDefault &= "."
    Else
      aMask.Add("")
      sSeparator &= sCar
      sDefault &= "."
    Endif
  Next
  
  $sMaskOrg = sMask
  $aMask = aMask
  $sSeparator = sSeparator
  $sAlign = sAlign
  $sDefault = sDefault
  $iPosFocus = iPosFocus
  'If $sMaskChar Then $sDefault = Replace($sDefault, "_", $sMaskChar)
  
End


Private Sub Mask_Write(Value As String)

  UpdateMaskAndSeparator(Value)
  
  If Not $sMaskOrg Then Return
  
  If Not IsValid(Me.Text) Then
    Clear()
  Endif
  
  Me.Pos = GetFirstCharacterPos()

End

' Private Sub IsMaskCharacter(sCar As String) As Boolean
'   
'   Return InStr(MASK_CHARACTER, sCar)
'   
' End

Private Sub GetPreviousSeparator(iPos As Integer, Optional sSep As String) As Integer
  
  Dim sCar As String
  
  If iPos < 0 Then Return -1
  
  While iPos >= 0
    sCar = $aMask[iPos]
    If Not sCar Then
      If Not sSep Then Break
      If sSep = String.Mid$($sSeparator, iPos + 1, 1) Then Break
    Endif
    Dec iPos
  Wend
  
  Return iPos
  
End

Private Sub GetNextSeparator(iPos As Integer, Optional sSep As String) As Integer
  
  Dim sCar As String
  
  If iPos < 0 Then Return 0
  
  While iPos < $aMask.Count
    sCar = $aMask[iPos]
    If Not sCar Then
      If Not sSep Then Break
      If sSep = String.Mid$($sSeparator, iPos + 1, 1) Then Break
    Endif
    Inc iPos
  Wend
  
  Return iPos
  
End

Private Sub GetNextCharacter(sText As String, iPos As Integer) As Integer
  
  Dim iLen As Integer = String.Len(sText)
  
  If iPos < 0 Then Return 0
  
  While iPos < iLen
    If $aMask[iPos] Then Break
    Inc iPos
  Wend
  
  Return iPos
  
End

Private Sub IsRightAlign(iPos As Integer) As Boolean
  
  iPos = GetNextSeparator(iPos)
  If iPos = 0 Then Return
  Return Mid$($sAlign, iPos, 1) = "<"
  
End

Private Sub UnmaskText(sText As String) As String
  
  Dim iPos As Integer
  Dim sResult As String
  Dim sCar As String
  
  For iPos = 1 To String.Len(sText)
    sCar = String.Mid$(sText, iPos, 1)
    If $aMask[iPos - 1] And If sCar = GetDefaultCharacter(iPos - 1) Then sCar = UNMASKED_CHAR
    sResult &= sCar
  Next
  
  Return sResult
  
End

Private Sub MaskText(sText As String) As String
  
  Dim iPos As Integer
  Dim sResult As String
  Dim sCar As String
  Dim sMask As String
  Dim bNumber As Boolean
  
  For iPos = 1 To String.Len(sText)
    sCar = String.Mid$(sText, iPos, 1)
    If sCar = UNMASKED_CHAR Then sCar = GetDefaultCharacter(iPos - 1)
    
    sMask = $aMask[iPos - 1]
    If sMask = "" Then
      bNumber = False
    Else If sMask = "[0-9]" Then
      If sCar = "0" Or If sCar = " " Then
        If Not bNumber Then 
          sCar = GetDefaultCharacter(iPos - 1)
        Else
          sCar = "0"
        Endif
      Else
        bNumber = True
      Endif
    Endif
    sResult &= sCar
  Next
  
  Return sResult
  
End

Private Sub GotoCursor(iPos As Integer) As Boolean
  
  Dim sText As String = Me.Text
  Dim sCar As String
  
  If IsRightAlign(iPos) Then
    While iPos < Me.Length
      sCar = String.Mid$(sText, iPos + 1, 1)
      If sCar <> " " And If sCar <> "0" Then 
        Break
      Endif
      Inc iPos
    Wend
  Endif
  
  If Me.Pos <> iPos Then
    Me.Pos = iPos
    Return True
  Endif
  
End


Public Sub TextBox_KeyPress()
  
  Dim sText, sTextOrg As String
  Dim iOldPos, iPos, iPosPrev, iPosNext As Integer
  Dim iMove As Integer
  Dim sCar As String
  Dim sInsert As String
  Dim bDelete As Boolean
  Dim bBefore As Boolean
  Dim bChange As Boolean
  
  If Not $sMaskOrg Then Return
  If Me.ReadOnly Then
    Return
  Endif
  
  sText = UnmaskText(Me.Text)
  sTextOrg = sText
  
  If Me.Selected Then
    iPos = GetNextCharacter(sText, Me.Selection.Start)
  Else
    iPos = Me.Pos
  Endif
  
  Select Key.Code
    
    Case Key.Left
      iMove = -1
      
    Case Key.Right
      iMove = 1
      
    Case Key.Home
      iPos = GetFirstCharacterPos()
      
    Case Key.End
      iPos = GetLastCharacterPos()
      
    Case Key.Delete
      If iPos < Me.Length
        iMove = 0
        bDelete = True
        bBefore = IsRightAlign(iPos + 1) 
      Endif
      
    Case Key.BackSpace
      If iPos > 0 Then
        iMove = -1
        bDelete = True
        bBefore = IsRightAlign(iPos) 
      Endif
    
    Case Key.Tab, Key.BackTab, Key.Up, Key.Down, Key.Enter, Key.Return
      Return
    
    Case Else
      
      If Key.Code = Key["A"] And If Key.Control Then
        Me.SelectAll
        Stop Event
        Return
      Endif
      
      If Key.Text Then
        
        bBefore = IsRightAlign(iPos) 
        
        If bBefore Then
          If iPos > 0 Then
            sCar = $aMask[iPos - 1]
          Else
            sCar = ""
          Endif
          If sCar And If Key.Text Like sCar Then 
            sInsert = Key.Text
            iMove = 0
          Endif
        Else If iPos < $aMask.Count Then
          sCar = $aMask[iPos]
          If sCar And If Key.Text Like sCar Then 
            sInsert = Key.Text
            iMove = 1
          Endif
        Endif
          
        If Not sInsert Then
          iPosNext = GetNextSeparator(iPos, Key.Text)
          While iPosNext < Me.Length
            If iPosNext < $aMask.Max And If $aMask[iPosNext + 1] Then Break
            Inc iPosNext
          Wend
          If iPosNext >= Me.Length Then Goto DO_NOTHING
          iPos = iPosNext
          iMove = 1
        Endif
          
      Endif
    
  End Select
  
  If sInsert Or If Key.Code = Key.Delete Or If Key.Code = Key.BackSpace Then
    If Me.Selected Then
      If Me.Selection.Length = Me.Length Then sText = MakeDefault()
      'sText = String.Left$(sText, Me.Selection.Start) & String.Mid$(sDefault, Me.Selection.Start + 1, Me.Selection.Length) & String.Mid$(sText, Me.Selection.Start + Me.Selection.Length + 1)
      iPos = GetNextCharacter(sText, Me.Selection.Start)
      Me.Selection.Hide
    Endif
  Endif
  
  If sInsert Then
    If Not bBefore Then
      sText = String.Left(sText, iPos) & sInsert & String.Mid$(sText, iPos + 2)
    Else
      iPosNext = iPos
      While iPos > 0
        If Not $aMask[iPos - 1] Then Break
        Dec iPos
      Wend
      If String.Mid$(sText, iPos + 1, 1) = UNMASKED_CHAR Then
        sText = String.Left(sText, iPos) & String.Mid$(sText, iPos + 2, iPosNext - iPos - 1) & sInsert & String.Mid$(sText, iPosNext + 1)
      Endif
      iPos = iPosNext
    Endif
  Endif
  
  If iMove Then
    
    iOldPos = iPos
    Do
      iPos += iMove
      If iPos < 0 Then
        iPos = GetFirstCharacterPos()
        Break
      Endif
      If iPos >= Me.Length Then
        iPos = GetLastCharacterPos()
        Break
      Endif
      If $aMask[iPos] Then Break
    Loop
    
    If IsRightAlign(iPos) Then 
      Do
        If (iPos + iMove) < 0 Then Break
        If (iPos + iMove) > Me.Length Then Break
        sCar = String.Mid$(sText, iPos + 1, 1)
        If sCar <> UNMASKED_CHAR And If sCar <> "0" Then Break
        iPos += iMove
      Loop
    Endif
    
  Endif
  
  If bDelete Then
    iPosNext = GetNextSeparator(iPos)
    If iPosNext > iPos Then
      If bBefore Then
        iPosPrev = GetPreviousSeparator(iPos)
        sText = String.Left(sText, iPosPrev + 1) & UNMASKED_CHAR & String.Mid$(sText, iPosPrev + 2, iPos - iPosPrev - 1) & String.Mid$(sText, iPos + 2)
        Inc iPos
      Else
        sText = RTrim(String.Left(sText, iPos) & String.Mid$(sText, iPos + 2, iPosNext - iPos - 1) & UNMASKED_CHAR & String.Mid$(sText, iPosNext + 1))
      Endif
    Endif
  Endif
  
  Object.Lock(Me)
  If sText <> sTextOrg Then
    sText = MaskText(sText)
    If Me.Text <> sText Then 
      Me.Text = sText
      bChange = True
    Endif

    If IsRightAlign(iPos) Then
      While iPos < Me.Length 
        If String.Mid$(sText, iPos + 1, 1) <> " " Then Break
        Inc iPos
      Wend
    Endif
  Endif
  Object.Unlock(Me)
  
  GotoCursor(iPos)
  
  If bChange Then Raise Change
  
  'Me.Select(iPos, 1)

DO_NOTHING:
  
  Stop Event
  
End

' Private Function MaskChar_Read() As String
' 
'   Return $sMaskChar  
' 
' End
' 
' Private Sub MaskChar_Write(Value As String)
' 
'   Dim sText As String
'   Dim iPos As Integer
'   Dim sCar As String
'   Dim aPos As New Integer[]
' 
'   Value = String.Left(Value)
'   sText = Me.Text
'   
'   For iPos = 0 To $aMask.Max
'     sCar = $aMask[iPos]
'     If Not sCar Or If String.Mid$($sDefault, iPos + 1, 1) <> "_" Then Continue
'     If String.Mid$(sText, iPos + 1, 1) = GetDefaultCharacter(iPos) Then aPos.Add(iPos)
'   Next
'   
'   $sMaskChar = Value
'   UpdateMaskAndSeparator($sMaskOrg)
'   
'   For Each iPos In aPos
'     sText = String.Left(sText, iPos) & GetDefaultCharacter(iPos) & String.Mid$(sText, iPos + 2)
'   Next
'   
'   Me.Text = RTrim(sText)
'   Me.Pos = GetFirstCharacterPos()
' 
' End

Public Sub TextBox_GotFocus()
  
  If Not $sMaskOrg Then Return
  TextBox_Change
  GotoCursor($iPosFocus)
  
End

Public Sub TextBox_LostFocus()
  
  If Not $sMaskOrg Then Return
  TextBox_Change
  GotoCursor($iPosFocus)
  
End

Public Sub TextBox_Menu()
  
  If Not $sMaskOrg Then Return
  Stop Event
  
End

Public Sub TextBox_Change()
  
  If Not $sMaskOrg Then Return
  
  Object.Lock(Me)
  If Me.HasFocus Or If $bShowDefault Then
    If Me.Text = "" Then Me.Text = MakeDefault()
  Else
    If Me.Text = MakeDefault() Then Me.Text = ""
  Endif
  Object.Unlock(Me)
  
End

Private Function ShowDefault_Read() As Boolean

  Return $bShowDefault

End

Private Sub ShowDefault_Write(Value As Boolean)

  $bShowDefault = Value
  TextBox_Change

End

Private Sub IsValid(sText As String) As Boolean
  
  Dim I As Integer
  Dim sMask As String
  Dim sCar As String
  
  If Not $sMaskOrg Then Return True
  
  If String.Len(sText) > $aMask.Count Then Return False
  
  For I = 1 To String.Len(sText)
    
    sCar = String.Mid$(sText, I, 1)
    sMask = $aMask[I - 1]
    If sMask Then
      If sCar Not Like sMask Then Return False
    Else
      If sCar <> String.Mid$($sSeparator, I, 1) Then Return False
    Endif
    
  Next
  
  Return True
  
End


Public Sub Clear()
  
  If Me.HasFocus Then
    Me.Text = MakeDefault()
  Else
    Me.Text = ""
  Endif
  
End
