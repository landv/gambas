' Gambas class file

Export
Inherits UserControl

Property Read Count As Integer
Property Mode As Integer
Property ScrollBar As Integer
Property Border As Boolean
Property Sorted As Boolean
Property Read Current As _TreeView_Item
Property Key As String
Property Read Keys As String[]
Property Read Item As _TreeView_Item
Property Read Available As Boolean
Property Read Renaming As Boolean
Property Editable As Boolean
Property Compare As Integer
Property Selection As String[]

Property Read ClientWidth, ClientW As Integer
Property Read ClientHeight, ClientH As Integer
Property ScrollX As Integer
Property ScrollY As Integer
Property Read ScrollW, ScrollWidth As Integer
Property Read ScrollH, ScrollHeight As Integer

Event Click
Event Activate
Event Select
Event Expand
Event Collapse
Event Rename
Event Cancel
Event Compare(Key As String, OtherKey As String)
Event BeforeSort
Event Scroll

Static Private $iNoEvent As Integer

Private $hView As GridView
Private $cItem As New Collection
Private $hRoot As _TreeView_Item
Private $sLastKey As String
Private $hResizeColumnTimer As Timer
Private $sCursor As String
Private $sSaveCursor As String
Private $iLastRow As Integer = -2
Private $iCompare As Integer
Private $bEditable As Boolean
Private $hRenameBox As RenameBox
Private $sKeyRenaming As String
Private $iColRenaming As Integer
Private $bSorted As Boolean
Private $cSort As Collection
Private $bSortRoot As Boolean
Private $hSortTimer As Timer
Private $bNoRoot As Boolean
Private $iLock As Integer

Private $iSaveSelection As Integer
Private $aSaveSelection As String[]
Private $iDepthW As Integer
Private $bShowLines As Boolean

Public Sub _new()
  
  $hView = New GridView(Me) As "GridView"
  $hView.Columns.Count = 1
  $hView.Mode = Select.Single
  $hView.Grid = False
  $hView.AutoResize = True
  $hView.Name = Me.Name & ":gridview"
  $hView.Rows.H = GetDefaultItemHeight()
  $hView.Padding = Desktop.Scale \ 2
  
  Me.Proxy = $hView
  
  $bNoRoot = Me Is ListView
  GridView_Font
  
  $hRoot = New _TreeView_Item("", "") As "Item"
  
End

Public Sub _get((Key) As String) As _TreeView_Item
  
  If Not Key Then Error.Raise("Null key")
  If Not $cItem.Exist(Key) Then Error.Raise("Unknown item: " & Key)
  Return $cItem[Key]
  
End

Public Sub Clear()

  Cancel()
  $cItem.Clear
  If $cSort Then $cSort.Clear
  $bSortRoot = False
  $iLastRow = -2
  $sLastKey = ""
  $sCursor = ""
  $hRoot = New _TreeView_Item("", "") As "Item"
  $hView.Rows.Count = 0
  
End

Private Sub ResizeColumns()
  
  If Not $hView.AutoResize Then Return
  If Not $hResizeColumnTimer Then
    $hResizeColumnTimer = New Timer As "ResizeColumns"
    $hResizeColumnTimer.Trigger
  Endif
  
End

Public Sub _SortParent(sKey As String)
  
  If sKey Then
    $cSort[sKey] = True
  Else
    $bSortRoot = True
  Endif
  If Not $hSortTimer Then
    $hSortTimer = New Timer As "Sort"
    $hSortTimer.Trigger
  Endif
  
End


Public Sub _Add((Key) As String, Text As String, Optional (Picture) As Picture, Optional Parent As String, Optional After As String) As _TreeView_Item
  
  Dim hItem, hParent As _TreeView_Item
  
  If Not Key Then Error.Raise("Null key")
  If $cItem.Exist(Key) Then Error.Raise("Key already used: " & Key)
  If Parent And If Not $cItem.Exist(Parent) Then Error.Raise("Parent item does not exist: " & Parent)
  If After And If Not $cItem.Exist(After) Then Error.Raise("After item does not exist: " & After)
  
  hItem = New _TreeView_Item(Key, Parent) As "Item"
  
  $cItem[Key] = hItem
  
  If Parent Then
    hParent = $cItem[Parent]
  Else
    hParent = $hRoot
  Endif
  
  hParent._AddChild(Key)

  Inc $iLock
  
  hItem._Index = hParent.Count - 1
  hItem.Editable = $bEditable
  hItem.Text = Text
  hItem.Picture = Picture
  
  Dec $iLock

  If After Then 
    If _MoveItem(hItem, After, False) Then _UpdateItemHeight(hItem)
  Else
    _UpdateItemHeight(hItem, True)
  Endif
  
  ResizeColumns
  
  If $bSorted Then _SortParent(Parent)
  
  $sCursor = Key
  
  _RefreshView
  
  Return hItem
  
End

Public Sub _GetParentItem(hItem As _TreeView_Item) As _TreeView_Item
  
  If hItem.ParentKey Then
    Return $cItem[hItem.ParentKey]
  Else If Not hItem._IsRoot() Then
    Return $hRoot
  Endif
  
End

Private Sub RemoveRec((Key) As String, Optional bDoNotDestroy As Boolean)
  
  Dim hItem As _TreeView_Item
  Dim hParent As _TreeView_Item
  Dim sKey As String

  hItem = $cItem[Key]
  
  If Not bDoNotDestroy And If hItem.Count Then
    For Each sKey In hItem._GetChildren().Copy()
      RemoveRec(sKey)
    Next
  Endif
  
  hParent = _GetParentItem(hItem)
  
  hParent._RemoveChild(hItem)
  While hParent.Expanded 
    Dec hParent._Rows
    If hParent._IsRoot() Then Break
    hParent = $cItem[hParent.ParentKey]
    If Not hParent Then hParent = $hRoot
  Wend
  
  If Not bDoNotDestroy Then $cItem.Remove(Key)
  
End


Public Sub Remove((Key) As String)
  
  Dim sCurrent As String
  Dim iRow As Integer
  Dim hItem As _TreeView_Item
  
  If Not Key Then Error.Raise("Null key")
  
  hItem = $cItem[Key]
  
  If Not hItem Then Error.Raise("Unknown item: " & Key)
  
  _SaveSelection
  
  iRow = _ItemToRow(hItem)
  
  sCurrent = Key_Read()
  
  RemoveRec(Key)
  
  _AddCount(0)
  
  _UpdateCurrent(sCurrent)
  
  ResizeColumns
  
  If iRow >= 0 Then UpdateRowHeight(Null, iRow, -1)
  
  _RestoreSelection
  _RefreshView
  
End

Public Sub _ReparentItem(hItem As _TreeView_Item, Parent As String)
  
  Dim hParent, hCheck As _TreeView_Item
  Dim sKey As String
  Dim sCurrent As String
  Dim bExpanded As Boolean
  
  If Not Parent Then
    hParent = $hRoot
  Else
    hParent = $cItem[Parent]
    If Not hParent Then Error.Raise("Unknown parent item: " & Parent)
  Endif
  
  If hItem.ParentKey = Parent Then Return
  
  sCurrent = Key_Read()
  
  hCheck = hParent
  While hCheck
    If hCheck = hItem Then Error.Raise("New parent cannot be a child item")
    sKey = hCheck.ParentKey
    If Not sKey Then Break
    hCheck = $cItem[sKey]
  Wend
  
  Inc $iLock

  bExpanded = hItem.Expanded
  hItem.Expanded = False
  sKey = hItem.Key
  
  RemoveRec(sKey, True)
  _AddCount(0)
  _GetParentItem(hItem)._ComputeGrandChildren()
  
  hParent._AddChild(sKey)
  
  hItem._Index = hParent.Count - 1
  hItem._SetParent(Parent)
  hItem._ComputeRows(1)
  hParent._ComputeGrandChildren()
  hItem.Expanded = bExpanded

  Dec $iLock
  
  _UpdateItemHeight(hItem, True)
  
  If $bSorted Then _SortParent(Parent)
  
  ResizeColumns
  _RefreshView
  
  _UpdateCurrent(sCurrent)  
  
End



Private Sub GetNextItem(hItem As _Treeview_Item) As _TreeView_Item
  
  Dim hParent As _TreeView_Item
  Dim aChildren As String[]
  Dim iPos As Integer
  
  If hItem.Count And If hItem.Expanded Then
    aChildren = hItem._GetChildren()
    Return $cItem[aChildren[0]]
  Endif
  
  Do
    hParent = _GetParentItem(hItem)
    aChildren = hParent._GetChildren()
    iPos = hItem._Index 'aChildren.Find(hItem.Key)
    If iPos < aChildren.Max Then Return $cItem[aChildren[iPos + 1]]
    If hParent._IsRoot() Then Return
    hItem = hParent
  Loop
  
End

Private Sub GetPreviousItem(hItem As _Treeview_Item) As _TreeView_Item
  
  Dim hParent As _TreeView_Item
  Dim aChildren As String[]
  
  If hItem._Index = 0 Then Return $cItem[hItem.ParentKey]
  
  hParent = _GetParentItem(hItem)
  aChildren = hParent._GetChildren()
  hItem = $cItem[aChildren[hItem._Index - 1]]
  
  Do
    If Not hItem.Expanded Or If hItem.Count = 0 Then Return hItem
    hItem = $cItem[hItem._GetChildren()[hItem.Count - 1]]
  Loop

End

Private Sub RowToItem(iRow As Integer) As _TreeView_Item
  
  Dim hParent As _TreeView_Item
  Dim hChild As _TreeView_Item
  Dim sKey As String
  Dim aChildren As String[]
  
  If iRow < 0 Or If iRow >= $hView.Rows.Count Then Return
  
  'Print iRow;; $iLastRow
  
  If $sLastKey Then hChild = $cItem[$sLastKey]
  
  If iRow = $iLastRow Then Return hChild
  
  If iRow = ($iLastRow + 1) Then
    $iLastRow = iRow
    hChild = GetNextItem(hChild)
    $sLastKey = hChild.Key
    Return hChild
  Endif
  
  If iRow = ($iLastRow - 1) Then
    $iLastRow = iRow
    hChild = GetPreviousItem(hChild)
    $sLastKey = hChild.Key
    Return hChild
  Endif
  
  hParent = $hRoot
  $iLastRow = iRow
  
  Do
    
    If hParent._GrandChildren = 0 Then
      
      aChildren = hParent._GetChildren()
      sKey = aChildren[iRow]
      $sLastKey = sKey
      Return $cItem[sKey]
      
    Else
    
      For Each sKey In hParent._GetChildren()
        hChild = $cItem[sKey]
        If iRow = 0 Then 
          $sLastKey = sKey
          Return hChild
        Endif
        If iRow < hChild._Rows Then
          Dec iRow
          hParent = hChild
          Break
        Endif
        iRow -= hChild._Rows
      Next
    
    Endif
    
  Loop
  
End

Public Sub _ItemToRow(hItem As _TreeView_Item) As Integer
  
  Dim hParent As _TreeView_Item
  Dim iRow As Integer
  Dim sItemKey As String
  Dim sKey As String
  Dim iPos As Integer
  
  If Not hItem Then Debug System.Backtrace.Join(" ")
  
  If hItem._IsRoot() Then Return -1
  
  sItemKey = hItem.Key
  hParent = _GetParentItem(hItem)
  
  If hParent._IsRoot() Then
    iRow = -1
  Else
    If Not hParent.Expanded Then Return -1
    iRow = _ItemToRow(hParent)
    If iRow < 0 Then Return iRow
  Endif
  
  Inc iRow
  
  If hParent._GrandChildren = 0 Then
  
    iPos = hParent._GetChildren().Find(sItemKey)
    If iPos >= 0 Then
      iRow += iPos
      Return iRow
    Endif
  
  Else
    
    For Each sKey In hParent._GetChildren()
      If sKey = sItemKey Then 
        'Debug sKey; " -> "; iRow
        Return iRow
      Endif
      hItem = $cItem[sKey]
      iRow += hItem._Rows
    Next
    
  Endif
  
  Return -1
  
End

Public Sub _GetItemX(hItem As _TreeView_Item) As Integer
  
  Dim X As Integer
  
  X = hItem._Depth * $iDepthW
  If Not $bNoRoot Then X += $iDepthW
  Return X

End

Private Sub GetDefaultItemHeight() As Integer
  
  Return Me.Font.Height + (Desktop.Scale \ 4) * 2 + 2
  
End

Public Sub GridView_Data(Row As Integer, (Column) As Integer)
  
  Dim hItem As _TreeView_Item = RowToItem(Row)
  If Not hItem Then Return
  
  $hView.Data.Background = hItem.Background
  
End

Public Sub GridView_Draw(X As Integer, Y As Integer, W As Integer, H As Integer, Row As Integer, Column As Integer)
  
  Dim hItem As _TreeView_Item = RowToItem(Row)
  Dim sText As String
  Dim XA As Float
  Dim YA As Float
  Dim WA As Float
  Dim HA As Float
  Dim bHasNext As Boolean
  Dim hParent As _TreeView_Item
  
  If Not hItem Then Return
  
  If Column = 0 Then
  
    If System.RightToLeft Then

      W -= hItem._Depth * $iDepthW + $iDepthW
      
      If Not $bNoRoot Then
      
        Paint.Save
        
        If $bShowLines And If hItem._Depth Then
          
          Paint.Background = Color.SetAlpha(Color.LightForeground, 128)
          
          bHasNext = GetSibling(hItem.Key, 1)
          
          If hItem.Count Then
            Paint.MoveTo(X + W + $iDepthW, Y + H / 2)
          Else
            Paint.MoveTo(X + W + $iDepthW / 4, Y + H / 2)
          Endif
          Paint.LineTo(X + W + $iDepthW + $iDepthW / 2, Y + H / 2)
          Paint.RelMoveTo(0, -H)
          Paint.RelLineTo(0, H)
          If bHasNext Then Paint.RelLineTo(0, H)
          
          XA = X + W + $iDepthW + $iDepthW / 2
          hParent = hItem
          While hParent.ParentKey
            hParent = $cItem[hParent.ParentKey]
            XA += $iDepthW 
            If GetSibling(hParent.Key, 1) Then
              Paint.MoveTo(XA, Y - H / 2)
              Paint.RelLineTo(0, H * 2)
            Endif
          Wend
          
          Paint.AntiAlias = False
          Paint.LineWidth = 1
          Paint.Stroke
          Paint.AntiAlias = True
          
        Endif
      
        If hItem.Count Then
          ' If hItem.Expanded Then
          '   Style.PaintArrow(X + W + 2, Y + H \ 2 - 6, 12, 12, Align.Bottom)
          ' Else
          '   Style.PaintArrow(X + W + 2, Y + H \ 2 - 6, 12, 12, Align.Left)
          ' Endif
          
          XA = X + W + $iDepthW / 4
          YA = Y + $iDepthW / 4
          WA = $iDepthW / 2
          HA = H - $iDepthW / 2
          Paint.Arrow(XA, YA, WA, HA, If(hItem.Expanded, Align.Bottom, Align.Left))
          Paint.Background = Color.SetAlpha(Style.ForegroundOf($hView), 64)
          Paint.LineWidth = $iDepthW / 12
          Paint.LineCap = Paint.LineCapRound
          Paint.Stroke
          
        Endif
        
        Paint.Restore
        
      Endif
      
      If hItem.Picture Then
        W -= hItem.Picture.W
        Paint.DrawPicture(hItem.Picture, X + W, Y + (H - hItem.Picture.H) / 2)
        W -= Desktop.Scale \ 2
      Endif

    Else
  
      X += hItem._Depth * $iDepthW
      
      If Not $bNoRoot Then
      
        Paint.Save
        
        If $bShowLines And If hItem._Depth Then
          
          Paint.Background = Color.SetAlpha(Color.LightForeground, 128)
          
          bHasNext = GetSibling(hItem.Key, 1)
          
          If hItem.Count Then
            Paint.MoveTo(X, Y + H / 2)
          Else
            Paint.MoveTo(X + $iDepthW - $iDepthW / 4, Y + H / 2)
          Endif
          Paint.LineTo(X - $iDepthW / 2, Y + H / 2)
          Paint.RelMoveTo(0, -H)
          Paint.RelLineTo(0, H)
          If bHasNext Then Paint.RelLineTo(0, H)
          
          XA = X - $iDepthW / 2
          hParent = hItem
          While hParent.ParentKey
            hParent = $cItem[hParent.ParentKey]
            XA -= $iDepthW 
            If GetSibling(hParent.Key, 1) Then
              Paint.MoveTo(XA, Y - H / 2)
              Paint.RelLineTo(0, H * 2)
            Endif
          Wend
          
          Paint.AntiAlias = False
          Paint.LineWidth = 1
          Paint.Stroke
          Paint.AntiAlias = True
          
        Endif
      
        If hItem.Count Then
          Paint.Background = Color.LightForeground
          XA = X + $iDepthW / 4
          YA = Y + $iDepthW / 4
          WA = $iDepthW / 2
          HA = H - $iDepthW / 2
          Paint.Arrow(XA, YA, WA, HA, If(hItem.Expanded, Align.Bottom, Align.Right))
          Paint.Background = Color.SetAlpha(Style.ForegroundOf($hView), 64)
          Paint.LineWidth = $iDepthW / 12
          Paint.LineCap = Paint.LineCapRound
          Paint.Stroke
        Endif
        
        Paint.Restore
        
        X += $iDepthW
        
      Endif
      
      If hItem.Picture Then
        Paint.DrawPicture(hItem.Picture, X, Y + (H - hItem.Picture.H) / 2)
        X += hItem.Picture.W + Desktop.Scale \ 2
      Endif
    
    Endif
    
    If hItem.Foreground <> Color.Default Then Paint.Background = hItem.Foreground
    If hItem.Font Then Paint.Font = hItem.Font
    
    'Draw.Text(hItem.Text & " (" & hItem._Index & ") [" & hItem._Rows & "] {" & hItem._GrandChildren & "}", X, Y, W, H, $hView.Columns[Column].Alignment)
    sText = hItem.RichText
    If sText Then
      Paint.DrawRichText(sText, X, Y, W, H, Align.Normal)
    Else
      Paint.DrawText(hItem.Text, X, Y, W, H, Align.Normal)
    Endif
    
  Else
    
    If hItem.Foreground <> Color.Default Then Paint.Background = hItem.Foreground
    Paint.DrawText(hItem[Column], X, Y, W, H, $hView.Columns[Column].Alignment)
    
  Endif
  
  Stop Event
  
End

Public Sub _AddCount(iCount As Integer)
  
  $hRoot._Rows += iCount
  $hView.Rows.Count = $hRoot._Rows
  $iLastRow = -2
  $sLastKey = ""
  
End

Public Sub GridView_Activate()
  
  Dim hItem As _TreeView_Item = RowToItem($hView.Row)
  Dim bCancel As Boolean
  Dim sCursor As String
  
  If Not hItem Then Return ' The item may have been destroyed during the click event
  
  sCursor = $sCursor
  SetCursor(hItem.Key)
  bCancel = Raise Activate
  $sCursor = sCursor
  
  If bCancel Then Return
  hItem.Expanded = Not hItem.Expanded
  
End

Public Sub GridView_MouseDown()
  
  Dim iRow As Integer = $hView.RowAt(Mouse.Y)
  Dim hItem As _TreeView_Item = RowToItem(iRow)
  Dim X As Integer

  If Not hItem Then Return

  If Mouse.Right Then
    $hView.Rows[iRow].Selected = True
  Endif

  If hItem.Count = 0 Then Return
  If $bNoRoot Then Return
  
  If System.RightToLeft Then
    With $hView.Columns[0]
      X = .X + .W - hItem._Depth * $iDepthW - $iDepthW
    End With
  Else
    X = hItem._Depth * $iDepthW
  Endif
  
  X -= $hView.ScrollX
  
  If Mouse.X >= X And If Mouse.X < X + $iDepthW Then
    hItem.Expanded = Not hItem.Expanded
  Endif
  
End

Public Sub GridView_KeyPress()
  
  Dim hItem As _TreeView_Item
  
  If Key.Code = Key.F2 Then 
    hItem = Current_Read()
    If hItem Then hItem.Rename
  Else If Key.Text = "+" Then
    hItem = Current_Read()
    If hItem Then hItem.Expanded = True
  Else If Key.Text = "-" Then
    hItem = Current_Read()
    If hItem Then hItem.Expanded = False
  Endif
  
End


Private Function Count_Read() As Integer

  Return $cItem.Count

End

Private Function Mode_Read() As Integer

  Return $hView.Mode

End

Private Sub Mode_Write(Value As Integer)

  $hView.Mode = Value

End

Private Function ScrollBar_Read() As Integer

  Return $hView.Scrollbar

End

Private Sub ScrollBar_Write(Value As Integer)

  $hView.Scrollbar = Value
  If Not Me Is ColumnView Then
    If $hView.ScrollBar And Scroll.Horizontal Then
      $hView.AutoResize = False
    Else
      $hView.AutoResize = True
    Endif
  Endif

End

Private Function Border_Read() As Boolean

  Return $hView.Border

End

Private Sub Border_Write(Value As Boolean)

  $hView.Border = Value

End

Private Function Sorted_Read() As Boolean

  Return $bSorted

End

Public Sub _RaiseCompare(sKey As String, sOtherKey As String) As Integer

  Dim bCancel As Boolean
  
  bCancel = Raise Compare(sKey, sOtherKey)
  Return bCancel
  
End


Private Sub SortItem(hItem As _TreeView_Item)
  
  Dim aChildren As String[]
  Dim aItem As _TreeView_Item[]
  Dim I As Integer
  Dim hTree As _TreeView
  
  If hItem.Count = 0 Then Return
  
  aChildren = hItem._GetChildren()
  aItem = New _TreeView_Item[aChildren.Count]
  For I = 0 To aItem.Max
    aItem[I] = $cItem[aChildren[I]]
  Next
  
  hTree = _TreeView_Item._Tree
  'System._Breakpoint
  If Object.CanRaise(Me, "Compare") Then
    _TreeView_Item._Tree = Me
  Else
    _TreeView_Item._Tree = Null
  Endif
  
  aItem.Sort(If($hView.Columns.Ascending, gb.Ascent, gb.Descent))
  
  _TreeView_Item._Tree = hTree
  
  For I = 0 To aItem.Max
    aChildren[I] = aItem[I].Key
    aItem[I]._Index = I
  Next
  
  _RefreshView
  
  For I = 0 To aItem.Max
    _UpdateItemHeight(aItem[I])
  Next
  
End

Private Sub SortItemRec(hParent As _TreeView_Item)
  
  Dim sKey As String
  Dim hItem As _TreeView_Item
  
  If hParent.Count = 0 Then Return
  SortItem(hParent)
  For Each sKey In hParent._GetChildren()
    hItem = $cItem[sKey]
    If hItem.Count Then SortItemRec(hItem)
  Next
  
End



Private Sub Sorted_Write(Value As Boolean)

  $hView.Sorted = Value
  $bSorted = Value
  If $bSorted Then
    $cSort = New Collection
    GridView_Sort
  Else
    $cSort = Null
  Endif
  $bSortRoot = False

End

Public Sub ResizeColumns_Timer()

  $hResizeColumnTimer = Null
  
  If $cItem.Count = 0 Then Return
  If Not $hView.AutoResize Then Return
  
  If $hView.Columns.Count = 1 Then
    If ($hView.ScrollBar And Scroll.Horizontal) = 0 Then Return
  Endif
  
  GridView_ColumnSize(0)
  
End

Private Function Current_Read() As _TreeView_Item

  Return RowToItem($hView.Row)

End

Private Function Key_Read() As String

  Dim hItem As _TreeView_Item = Current_Read()
  If hItem Then Return hItem.Key

End

Private Sub Key_Write(Value As String)

  Dim iRow As Integer
  
  If Not Value Then 
    $hView.Row = -1
    Return
  Endif
  
  Try iRow = _ItemToRow($cItem[Value])
  If Error Then
    Debug Error.Where; ": "; Error.Text
    Return
  Endif
  Try $hView.Row = iRow
  If Error Then $hView.Row = -1

End

Public Sub _UpdateCurrent(sKey As String)

  If Not $cItem.Exist(sKey) Then Return
  Inc $iNoEvent
  Key_Write(sKey)
  Dec $iNoEvent
  
End


Public Sub GridView_Select()
  
  Dim sCursor As String
  
  If $iNoEvent Then Return
  If $hView.Row < 0 Then Return
  
  sCursor = $sCursor
  SetCursor(RowToItem($hView.Row).Key)
  Raise Select
  $sCursor = sCursor
  
End

' Public Sub ResizeRows_Timer()
'   
'   Dim iRow As Integer
'   Dim hItem As _TreeView_Item
'   Dim PH As Integer
'   
'   $hResizeRowsTimer = Null
'   
'   For Each hItem In $cResizeRows
'     iRow = $cResizeRows.Key
'     PH = _GetItemHeight(hItem)
'     If PH <> $hView.Rows[iRow].H Then
'       $hView.Rows[iRow].H = PH
'     Endif
'   Next
'   
'   $cResizeRows.Clear
'   
' End

Public Sub Exist((Key) As String) As Boolean
  
  Return $cItem.Exist(Key)
  
End

Public Sub GridView_Click()
  
  Dim sSave As String = $sCursor
  MoveCurrent()
  Raise Click
  $sCursor = sSave
  
End

Private Function Item_Read() As _TreeView_Item

  Return $cItem[$sCursor]

End

Public Sub _RaiseExpand(sKey As String, bExpand As Boolean)
  
  Dim sCursor As String = $sCursor
  
  $sCursor = sKey
  
  If bExpand Then
    Raise Expand
  Else
    Raise Collapse
  Endif
  
  $sCursor = sCursor
  
  ResizeColumns
  
End

Public Sub _EnsureVisible(hItem As _TreeView_Item, Optional bChild As Boolean)
  
  Dim iRow As Integer
  
  SetItemVisible(hItem)
  iRow = _ItemToRow(hItem)
  
  If bChild And If hItem._Rows > 1 Then 
    iRow = Min(iRow + $hView.RowAt($hView.ClientH) - $hView.RowAt($hView.Columns.Height) - 2, iRow + hItem._Rows - 1)
  Endif
  
  If iRow >= 0 Then $hView[iRow, 0].EnsureVisible
  
End

Private Sub SetCursor(sKey As String) As Boolean
  
  If Not sKey Then $sSaveCursor = $sCursor
  $sCursor = sKey
  Return Not sKey
  
End


Public Sub MoveFirst() As Boolean
  
  Dim sKey As String
  
  Try sKey = $hRoot._GetChildren()[0]
  Return SetCursor(sKey)
  
End

Public Sub MoveLast() As Boolean
  
  Dim aChildren As String[]
  Dim sKey As String
  
  aChildren = $hRoot._GetChildren()
  Try sKey = aChildren[aChildren.Max]
  Return SetCursor(sKey)
  
End

Public Sub MoveBack() As Boolean

  Dim sKey As String
  
  sKey = $sSaveCursor
  $sSaveCursor = ""
  Return SetCursor(sKey)
  
End

Public Sub MoveCurrent() As Boolean
  
  Return SetCursor(Key_Read())
  
End

Public Sub MoveTo((Key) As String) As Boolean
  
  If Not $cItem.Exist(Key) Then Key = ""
  Return SetCursor(Key)
  
End

Public Sub MoveAbove() As Boolean
  
  Dim sKey As String
  Dim hItem As _TreeView_Item
  
  hItem = $cItem[$sCursor]
  Try sKey = GetPreviousItem(hItem).Key
  Return SetCursor(sKey)
  
End

Public Sub MoveBelow() As Boolean
  
  Dim sKey As String
  Dim hItem As _TreeView_Item
  
  hItem = $cItem[$sCursor]
  Try sKey = GetNextItem(hItem).Key
  Return SetCursor(sKey)
  
End

Public Sub MoveChild() As Boolean
  
  Dim sKey As String
  
  Try sKey = $cItem[$sCursor]._GetChildren()[0]
  Return SetCursor(sKey)
  
End

Private Sub GetSibling(sKey As String, Optional iAdd As Integer) As String
  
  Dim hItem, hParent As _TreeView_Item
  Dim aChildren As String[]
  
  If Not sKey Then Return
  
  hItem = $cItem[sKey]
  hParent = _GetParentItem(hItem)
  
  aChildren = hParent._GetChildren() 
  'Try Return aChildren[aChildren.Find(hItem.Key) + iAdd]
  Try Return aChildren[hItem._Index + iAdd]
  
End

Public Sub MoveNext() As Boolean
  
  Return SetCursor(GetSibling($sCursor, 1))
  
End

Public Sub MovePrevious() As Boolean
  
  Return SetCursor(GetSibling($sCursor, -1))
  
End

Public Sub MoveParent() As Boolean
  
  Dim sKey As String
  
  Try sKey = $cItem[$sCursor].ParentKey
  Return SetCursor(sKey)
  
End


Private Function ClientWidth_Read() As Integer

  Return $hView.ClientW

End

Private Function ClientHeight_Read() As Integer

  Return $hView.ClientH

End

Private Function Available_Read() As Boolean

  Return $sCursor

End

Public Sub SelectAll()
  
  $hView.SelectAll
  
End

Public Sub UnselectAll()
  
  $hView.UnselectAll
  
End

Public Sub FindAt((X) As Integer, Y As Integer) As Boolean
  
  Dim iRow As Integer = $hView.RowAt(Y)

  If iRow < 0 Then Return True
  Return SetCursor(RowToItem(iRow).Key)
  
End

Public Sub _MoveItem(hItem As _TreeView_Item, sKey As String, bBefore As Boolean) As Boolean
  
  Dim hParent As _TreeView_Item = _GetParentItem(hItem)
  Dim aChildren As String[]
  Dim iPos, iPosKey, iNewPos As Integer
  Dim iStart, I As Integer
  
  If $bSorted Then Return

  aChildren = hParent._GetChildren()
  
  'iPos = aChildren.Find(hItem.Key)
  iPos = hItem._Index
  If iPos < 0 Then Return
  
  If sKey Then
    iPosKey = $cItem[sKey]._Index 'aChildren.Find(sKey)
    If iPosKey < 0 Then Return
    If iPos <= iPosKey Then Dec iPosKey
  Endif
  
  If sKey Then
    If Not bBefore Then
      iNewPos = iPosKey + 1
    Else
      iNewPos = iPosKey 
    Endif
  Else
    If bBefore Then
      iNewPos = aChildren.Count
    Else
      iNewPos = 0
    Endif
  Endif
  
  If iPos = iNewPos Then Return True
  
  aChildren.Remove(iPos)
  aChildren.Add(hItem.Key, iNewPos)
  
  iStart = Min(iPos, iNewPos)
  For I = iStart To aChildren.Max
    hItem = $cItem[aChildren[I]]
    hItem._Index = I
    _UpdateItemHeight(hItem)
  Next
  
  _RefreshView
  
End

Public Sub _IsItemSelected(hItem As _TreeView_Item) As Boolean
  
  Dim iRow As Integer = _ItemToRow(hItem)
  Return $hView.Rows[iRow].Selected
  
End

Public Sub _SetItemSelected(hItem As _TreeView_Item, bSelected As Boolean)
  
  Dim iRow As Integer
  
  If $hView.Mode = Select.Single Then SetItemVisible(hItem)
  
  iRow = _ItemToRow(hItem)
  $hView.Rows[iRow].Selected = bSelected
  
End

Private Function Renaming_Read() As Boolean

  Return $hRenameBox

End

Private Function Editable_Read() As Boolean

  Return $bEditable

End

Private Sub Editable_Write(Value As Boolean)

  $bEditable = Value

End

Private Function Compare_Read() As Integer

  Return $iCompare

End

Private Sub Compare_Write(Value As Integer)

  $iCompare = Value

End

Private Sub UpdateRenameBox() As Boolean

  Dim hItem As _TreeView_Item
  Dim X As Integer
  Dim W As Integer
  
  If Not $hRenameBox Then Return
  
  hItem = $cItem[$sKeyRenaming]
  
  '' TODO: System.RightToLeft
  
  If $iColRenaming = 0 Then
    X = hItem.X - $hView.ScrollX
    If hItem.Picture Then X += hItem.Picture.W + Desktop.Scale \ 2
    W = Min($hView.ClientW, $hView.Columns[0].Width) - X
  Else
    X = $hView.Columns[$iColRenaming].X - $hView.ScrollX
    W = Min($hView.ClientW - X, $hView.Columns[$iColRenaming].Width)
  Endif
  
  If W < 32 Then 
    Cancel
    Return
  Endif
  
  $hRenameBox.Move(X, hItem.Y, W, hItem.H)

End

Public Sub _Rename(hItem As _TreeView_Item, iCol As Integer)
  
  Dim X As Integer
  Dim SX As Integer
  
  If iCol < 0 Or If iCol >= $hView.Columns.Count Then Error.Raise("Out of bounds")
  
  _EnsureVisible(hItem)
  Wait
  Key_Write(hItem.Key)
  
  Do
    X = hItem.X 
    If iCol Then X += $hView.Columns[iCol].X
    SX = Max(0, X - $hView.ClientW - 32)
    If SX = $hView.ScrollX Then Break
    $hView.ScrollX = SX
  Loop
  
  $hRenameBox = New RenameBox(Me, $hView.Padding, False) As "Editor"
  $hRenameBox.Text = hItem[iCol]
  $hRenameBox.SetFocus
  
  $sKeyRenaming = hItem.Key
  $iColRenaming = iCol
  
  UpdateRenameBox
  
End

Private Sub Cancel(Optional bOK As Boolean)
  
  Dim sCursor As String 
  Dim bStop As Boolean
  Dim hItem As _TreeView_Item
  
  If Not $hRenameBox Then Return
  
  $hRenameBox.Delete
  $hRenameBox = Null
  $hView.SetFocus

  sCursor = $sCursor
  $sCursor = $sKeyRenaming
  If bOK Then
    bStop = Raise Rename
  Else
    Raise Cancel
  Endif
  $sCursor = sCursor
  
  hItem = $cItem[$sKeyRenaming]
  $sKeyRenaming = ""
  If bStop Then _Rename(hItem, $iColRenaming)
  
End


Public Sub Editor_LostFocus()
  
  Cancel
  
End

Public Sub Editor_KeyPress()
  
  If Key.Code = Key.Escape Then 
    Cancel
    Stop Event
  Else If Key.Code = Key.Return Or If Key.Code = Key.Enter Then
    Try $cItem[$sKeyRenaming][$iColRenaming] = $hRenameBox.Text
    If Not Error Then Cancel(True)
    Stop Event
  Endif
  
End

Public Sub _RefreshView()
  
  $iLastRow = -2
  $sLastKey = ""
  $hView.Refresh
  
End

Public Sub Sort_Timer()
  
  $hSortTimer = Null
  If Not $cSort Then Return
  
  Raise BeforeSort
  
  _SaveSelection
  
  For Each $cSort
    SortItem($cItem[$cSort.Key])
  Next
  If $bSortRoot Then
    SortItem($hRoot)
  Endif
  $bSortRoot = False
  $cSort.Clear
  
  'If hItem Then _SetItemSelected(hItem, True)
  _RestoreSelection
  
End

Private Sub IsItemVisible(hItem As _TreeView_Item) As Boolean

  Dim hParent As _TreeView_Item
  
  hParent = _GetParentItem(hItem)
  If hParent._IsRoot() Then Return True
  If Not hParent.Expanded Then Return
  Return IsItemVisible(hParent)
  
End

Private Sub SetItemVisible(hItem As _TreeView_Item)
  
  Do
    hItem = _GetParentItem(hItem)
    If hItem._IsRoot() Then Break
    hItem.Expanded = True
  Loop
  
End


Public Sub GridView_Sort()

  Raise BeforeSort

  _SaveSelection
  
  SortItemRec($hRoot)
  
  _RestoreSelection
  _RefreshView
  
End

Public Sub GridView_Scroll()
  
  Cancel
  Raise Scroll
  
End

Public Sub GridView_Arrange()
  
  Cancel
  
End


Private Function Selection_Read() As String[]

  Dim aSel As New String[]
  Dim iRow As Integer
  
  For Each iRow In $hView.Rows.Selection
    aSel.Add(RowToItem(iRow).Key)
  Next
  
  Return aSel

End

Private Sub Selection_Write(Value As String[])

  Dim sKey As String
  Dim hItem As _TreeView_Item
  
  Inc $iNoEvent
  UnselectAll
  For Each sKey In Value
    If Not sKey Then Continue
    hItem = $cItem[sKey]
    If hItem Then hItem.Selected = True
  Next
  Dec $iNoEvent
  
  If $iNoEvent Then Return
  Raise Select

End

Public Sub _SaveSelection()
  
  If $iSaveSelection = 0 Then
    $aSaveSelection = Selection_Read()
  Endif
  
  Inc $iSaveSelection
  
End

Public Sub _RestoreSelection()
  
  Dec $iSaveSelection
  
  If $iSaveSelection = 0 Then 
    Inc $iNoEvent
    Inc $iSaveSelection
    Selection_Write($aSaveSelection)
    Dec $iSaveSelection
    Dec $iNoEvent
    $aSaveSelection = Null
  Endif
  
End

Private Function ScrollX_Read() As Integer

  Return $hView.ScrollX

End

Private Sub ScrollX_Write(Value As Integer)

  $hView.ScrollX = Value

End

Private Function ScrollY_Read() As Integer

  Return $hView.ScrollY

End

Private Sub ScrollY_Write(Value As Integer)

  $hView.ScrollY = Value

End

Private Function ScrollW_Read() As Integer

  Return $hView.ScrollW

End

Private Function ScrollH_Read() As Integer

  Return $hView.ScrollH

End

Public Sub Scroll(X As Integer, Y As Integer)
  
  $hView.Scroll(X, Y)
  
End

Public Sub GridView_ColumnSize(Column As Integer)
  
  Dim hItem As _TreeView_Item
  Dim W As Integer
  
  W = Me.Font.TextWidth($hView.Columns[Column].Text) + 8 + If($bSorted, $iDepthW, 0)
  
  If Column = 0 Then
    For Each hItem In $cItem
      If Not IsItemVisible(hItem) Then Continue
      W = Max(W, hItem._GetWidth() + _GetItemX(hItem))
    Next
  Else
    For Each hItem In $cItem
      If Not IsItemVisible(hItem) Then Continue
      W = Max(W, Me.Font.TextWidth(hItem[Column]))
    Next
  Endif
  
  $hView.Columns[Column].W = W + 8
  UpdateRenameBox
  
End

Private Sub UpdateRowHeight(hItem As _TreeView_Item, iStart As Integer, Optional iEnd As Integer)
  
  If iEnd = 0 Then
    iEnd = iStart
  Else If iEnd < 0 Then
    iEnd = $hView.Rows.Max
  Endif
  
  If hItem Then
    $hView.Rows[iStart].H = hItem._GetHeight()
    Inc iStart
  Endif
  
  While iStart <= iEnd
    $hView.Rows[iStart].H = RowToItem(iStart)._GetHeight()
    Inc iStart
  Wend
  
End


Public Sub _UpdateItemHeight(hItem As _TreeView_Item, Optional bNext As Boolean)

  Dim iRow As Integer

  If $iLock Then Return
  
  iRow = _ItemToRow(hItem)
  If iRow < 0 Then Return
  
  UpdateRowHeight(hItem, iRow, If(bNext, -1, 0))
  
End


Public Function _GetLayout() As Variant

  Dim hItem As _TreeView_Item
  Dim cLayout As New Collection

  For Each hItem In $cItem
    If hItem.Expanded Then cLayout[hItem.Key] = True
  Next
  
  Return cLayout

End

Public Sub _SetLayout(Value As Variant)

  Dim cLayout As Collection
  Dim hItem As _TreeView_Item
  
  Try cLayout = Value
  If Error Then Error.Raise("Bad layout")
  
  _SaveSelection
  For Each hItem In $cItem.Copy()
    hItem.Expanded = cLayout.Exist(hItem.Key)
  Next
  _RestoreSelection

End

Public Sub GridView_Font()

  $iDepthW = Me.Font.Height
  $hView.Rows.Height = GetDefaultItemHeight()
  UpdateRowHeight(Null, 0, -1)
  
End

Private Function Keys_Read() As String[]

  Dim aKeys As New String[]

  For Each $cItem
    aKeys.Add($cItem.Key)
  Next
  Return aKeys

End

Public Sub _Begin()
  
  Inc $iLock
  
End

Public Sub _End()
  
  Dec $iLock
  If $iLock = 0 Then
    UpdateRowHeight(Null, 0, -1)
  Endif
  
End

Public Sub _SetShowLines(bShowLines As Boolean)
  
  If $bShowLines = bShowLines Then Return
  $bShowLines = bShowLines
  $hView.Refresh
  
End

Public Sub _GetShowLines() As Boolean
  
  Return $bShowLines
  
End
