' Gambas class file

Export

Inherits UserControl

Class TableView

Public Const _Properties As String = "*,Border=True,Mode{Select.None;Single;Multiple}=None,Grid=True,Padding{Range:0;63}=2,ShowCursor=False,Header{GridView.None;Horizontal;Vertical;Both}=None,ScrollBar{Scroll.*}=Both,AutoResize=True,Resizable=True,Sorted"
Public Const _Group As String = "View"
Public Const _DefaultEvent As String = "Click"

Public Enum None, Horizontal, Vertical, Both

Property Background As Integer
Property Read Rows As _GridView_Rows
Property Read Columns As _GridView_Columns
Property Border As Boolean
Property Grid As Boolean
Property Mode As Integer
Property Read Data As _GridView_Data
Property Row As Integer
Property Column As Integer
Property Resizable As Boolean
Property ScrollBar As Integer
Property AutoResize As Boolean
Property Header As Integer
Property ShowCursor As Boolean
Property Read Current As _GridView_Cell
Property Sorted As Boolean
Property Padding As Integer

Property ScrollX As Integer
Property ScrollY As Integer
Property Read ScrollW, ScrollWidth As Integer
Property Read ScrollH, ScrollHeight As Integer

Property Read ClientX As Integer
Property Read ClientY As Integer
Property Read ClientW, ClientWidth As Integer
Property Read ClientH, ClientHeight As Integer

Event Data(Row As Integer, Column As Integer)
Event Change
Event Select
Event Click
Event Activate
Event Scroll
Event Font

Event ColumnClick(Column As Integer)
Event ColumnResize(Column As Integer)
Event ColumnSize(Column As Integer)

Event RowClick(Row As Integer)
Event RowResize(Row As Integer)
Event RowSize(Row As Integer)

'Event MouseDown
Event Sort
Event Draw(X As Integer, Y As Integer, Width As Integer, Height As Integer, Row As Integer, Column As Integer)

Public _DoNotDrawSelection As Boolean
Public _NoMouse As Boolean

Private $hView As ScrollArea
Private $bGrid As Boolean = True
Private $iMode As Integer
Private $iHeader As Integer
Private $bShowCursor As Boolean
Private $bAutoResize As Boolean = True
Private $iDefaultMouse As Integer '= Mouse.Default
Private $iBg As Integer = Color.Default

Private $iRow As Integer
Private $iCol As Integer

Private $hRows As _GridView_Rows
Private $hColumns As _GridView_Columns

Private $iFirstRow As Integer
Private $aRowY As New Integer[]

Private $cCells As New Collection
Private $hData As _GridView_Data

Private $cSpan As New Collection

Private $bResize As Boolean
Private $iRowResize As Integer = -1
Private $iColResize As Integer = -1
Private $iDimResize As Integer

Private $bMoveSelect As Boolean
Private $bMoveUnSelect As Boolean
Private $iMoveSelectRow As Integer = -1
Private $hMoveOldSelection As GridViewSelection
Private $bKeyEvent As Boolean
Private $bIgnoreMove As Boolean

Private $MX As Integer
Private $MY As Integer
Private $SX As Integer
Private $SY As Integer
Private $hTimerScroll As Timer

Private $bInCell As Boolean
Private $bInRow As Boolean

Private $hTimerEnsureVisible As Timer
Private $iRowEV As Integer = -1
Private $iColEV As Integer = -1

Private $bSorted As Boolean

Private $bHasDrawEvent As Boolean

Private $hObsClick As Observer
Private $iPadding As Integer = 2
Private $iTextHeight As Integer

Public Sub _new()
  
  $hRows = New _GridView_Rows As "Rows"
  $hColumns = New _GridView_Columns As "Columns"
  
  $hView = New ScrollArea(Me) As "ScrollArea"
  $hView.Background = Color.TextBackground
  $hView.Focus = True
  $hView.Tracking = True
  $hView.ScrollBar = Scroll.Both
  
  $bGrid = True
  $iRow = -1
  $iCol = 0
  
  Me.Proxy = $hView
  
  $hObsClick = New Observer(Me, True) As "GridViewClick"
  
End

' Public Sub _attach(Parent As Object, EventName As String)
'   
'   If Parent Then
'     $bHasDrawEvent = Object.CanRaise(Me, "Draw")
'   Endif
'   
' End


Private Sub GetCellKey(iRow As Integer, iCol As Integer) As String
  
  If iRow >= iCol Then
    Return CLong(iRow) * iRow + iCol * 2
  Else
    Return CLong(iCol) * iCol + iRow * 2 + 1
  Endif
  
End


Private Function Rows_Read() As _GridView_Rows

  Return $hRows

End

Private Function Columns_Read() As _GridView_Columns

  Return $hColumns

End

Public Sub _IsRowSelected(iRow As Integer) As Boolean
  
  Select Case $iMode
    Case Select.None
      Return
    Case Select.Single
      Return iRow = $iRow
    Case Select.Multiple
      Return $hRows._IsSelected(iRow)
  End Select
  
End

Private Sub DrawAlignedPicture(hPict As Picture, X As Integer, Y As Integer, W As Integer, H As Integer, A As Integer)
  
  If Align.IsBottom(A) Then
    Y += H - hPict.H
  Else If Align.IsMiddle(A) Then
    Y += (H - hPict.H) / 2
  Endif
  
  If Align.IsRight(A) Then
    X += W - hPict.W
  Else If Align.IsCenter(A) Then
    X += (W - hPict.W) / 2
  Endif
  
  Paint.DrawPicture(hPict, X, Y)
  
End


Private Sub DrawCell(X As Integer, Y As Integer, W As Integer, H As Integer, iRow As Integer, iCol As Integer, hData As _GridView_Data, hRowBorder As Border)

  Dim hRect As Rect = Rect(X, Y, W, H)
  Dim hPict As Picture
  Dim A As Integer
  Dim iColor As Integer
  Dim bCancel As Boolean
  Dim iPadding As Integer

  Paint.Save
  
  With hData

    If W <= 0 Or If H <= 0 Then Goto DRAW_GRID
    
    iColor = .Background
    If iColor = Color.Default Then 
      iColor = $hColumns[iCol].Background
      If iColor = Color.Default Then
        iColor = Me.Background
        If iColor = Color.Default Then
          iColor = Color.TextBackground
        Endif
      Endif
    Endif
    
    Paint.FillRect(X, Y, W, H, iColor)
    
    If .Border
      hRect = .Border.GetRect(RectF(X, Y, W, H), True)
      X = hRect.X
      Y = hRect.Y
      W = hRect.W
      H = hRect.H
    Endif
    
    If hRowBorder Then
      With hRowBorder
        Y += .TopPadding + .TopWidth
        H -= .TopPadding + .TopWidth + .BottomPadding + .BottomWidth
        If iCol = 0 Then 
          X += .LeftPadding + .LeftWidth
          W -= .LeftPadding + .LeftWidth
        Endif
        If iCol = $hColumns.Max Then
          W -= .RightPadding + .RightWidth
        Endif
      End With
    Endif

    iPadding = Max($iPadding, .Padding)
    
    If iPadding Then
      X += iPadding
      Y += iPadding
      W -= iPadding * 2
      H -= iPadding * 2
    Endif
    
    If W <= 0 Or If H <= 0 Then Goto DRAW_GRID
    
    'Paint.FillRect(X, Y, W, H, Color.SetAlpha(Color.Red, 240))
    
    iColor = .Foreground
    If iColor = Color.Default Then 
      iColor = Me.Foreground
      If iColor = Color.Default Then
        iColor = Style.ForegroundOf(Me)
      Endif
    Endif
    
    Paint.Background = iColor
    
    If .Font And If .Font.Modified Then 
      Paint.Font = .Font
    Endif

    If $bHasDrawEvent Then
      bCancel = Raise Draw(X, Y, W, H, iRow, iCol)
      If bCancel Then Goto DRAW_GRID
    Endif
    
    hPict = .Picture

    If hPict Then
    
      If Not .Text And If Not .RichText Then
        
        DrawAlignedPicture(hPict, X, Y, W, H, .Alignment)
        
      Else
        
        A = .Alignment
        If Align.IsMiddle(A) Then
          A = Align.Normal
        Else If Align.IsTop(A) Then
          A = Align.TopNormal
        Else If Align.IsBottom(A) Then
          A = Align.BottomNormal
        End If
      
        DrawAlignedPicture(hPict, X, Y, W, H, A)
        
        W -= hPict.W + iPadding
        If Not System.RightToLeft Then X += hPict.W + iPadding
        
      Endif
      
      If W <= 0 Then Goto DRAW_GRID
      
    Endif
    
    Inc X
    W -= 2
    
    If .Text Then
      If .WordWrap Then
        Paint.DrawRichText(Replace(Html(.Text), "\n", "<br>"), X, Y, W, H, .Alignment)
      Else
        Paint.DrawText(.Text, X, Y, W, H, .Alignment)
      Endif
    Else If .RichText Then
      If .WordWrap Then
        Paint.DrawRichText(.RichText, X, Y, W, H, .Alignment)
      Else
        A = .Alignment
        If Align.IsLeft(A) Then
          Paint.DrawRichText(.RichText, X, Y, 4096, H, .Alignment)
        Else If Align.IsRight(A) Then
          Paint.DrawRichText(.RichText, X + W - 4096, Y, 4096, H, .Alignment)
        Else
          Paint.DrawRichText(.RichText, X + W \ 2 - 4096, Y, 4096, H, .Alignment)
        Endif
      Endif
    Endif
      
  End With
  
DRAW_GRID:

  iColor = Color.Merge(Color.LightForeground, $hView.Background)
  If $bGrid Then
    If System.RightToLeft Then
      If iCol > 0 Then Paint.FillRect(hRect.X, hRect.Y, 1, hRect.H, iColor)
    Else
      If iCol < $hColumns.Max Or If hRect.X + hRect.W < $hView.ClientW Then Paint.FillRect(hRect.X + hRect.W - 1, hRect.Y, 1, hRect.H, iColor)
    Endif
    If iRow < $hRows.Max Or If hRect.Y + hRect.H < $hView.ClientH Then Paint.FillRect(hRect.X, hRect.Y + hRect.H - 1, hRect.W, 1, iColor)
  Else If Me Is TableView Then
    If iRow = $hRows.Max Then
      If hRect.Y + hRect.H < $hView.ClientH Then Paint.FillRect(hRect.X, hRect.Y + hRect.H - 1, hRect.W, 1, iColor)
    Endif
    If System.RightToLeft Then
      If iCol = 0 Then 
        Paint.FillRect(hRect.X, hRect.Y, 1, hRect.H, iColor)
      Endif
    Else
      If iCol = $hColumns.Max Then
        If hRect.X + hRect.W < $hView.ClientW Then Paint.FillRect(hRect.X + hRect.W - 1, hRect.Y, 1, hRect.H, iColor)
      Endif
    Endif
  Endif
  
  Paint.Restore
  
End

Private Sub DrawText(sText As String, X As Integer, Y As Integer, W As Integer, H As Integer, iAlign As Integer, iPadding As Integer)
  
  X += iPadding
  Y += iPadding
  W -= iPadding * 2
  H -= iPadding * 2
  If W <= 0 Or If H <= 0 Then Return
  Paint.DrawText(sText, X, Y, W, H, iAlign)
  
End


Public Sub ScrollArea_Draw()
  
  Dim I, J, R, C, WA As Integer
  Dim XO, YO, XX, YY, X, Y, W, H As Integer
  Dim iRow, iRow2, iCol, iCol2 As Integer
  Dim hClip, hSaveClip As Rect
  Dim hRect As Rect
  Dim hData As _GridView_Data
  Dim F As Integer = _GetFrameWidth()
  Dim iGrid As Integer
  Dim aSpan As Short[]
  Dim bHasSpan As Boolean
  Dim iRowSpan, iColSpan As Integer
  Dim hSpan, hCursor As Rect
  Dim XS, YS As Integer
  Dim iSort As Integer
  Dim bAscent As Boolean
  Dim iStepCol As Integer
  Dim iBg As Integer
  Dim hRowBorder As Border
  Dim hTopRowBorder As Border
  Dim hBottomRowBorder As Border
  Dim hRowBorderRect As Rect
  Dim hRectF As RectF
  Dim iBgSel As Integer
  
  'Debug Me.Font.ToString();; Draw.Font.ToString()
  
  If $iBg <> Color.Transparent Then
    If $iBg = Color.Default Then 
      iBg = Color.TextBackground
    Else
      iBg = $iBg
    Endif
    Paint.FillRect(0, 0, Paint.W, Paint.H, iBg)
  Endif
  
  If $hView.HasFocus Then
    iBgSel = Color.SetAlpha(Color.SelectedBackground, &HA0)
  Else
    iBgSel = Color.SetAlpha(Color.SelectedBackground, &HC0)
  Endif
  
  If $hColumns.Count = 0 And If $hRows.Count = 0 Then Return
  
  iCol = $hColumns._FindColumnFromPos($hView.ScrollX)
  If iCol < 0 Then iCol = $hColumns.Max
  'Debug "iCol = "; iCol
  
  iRow = $hRows._FindRowFromPos($hView.ScrollY)
  iCol2 = -1
  iRow2 = -1
  
  iStepCol = If(System.RightToLeft, -1, 1)
  
  If System.RightToLeft Then
    XO = - $hView.ScrollX + F
  Else
    XO = $hRows.Width - $hView.ScrollX + F
  Endif
  XX = XO + $hColumns[iCol].X
  YO = $hColumns.Height - $hView.ScrollY + F
  YY = YO + $hRows._GetRowY(iRow)
  
  If $bGrid Then
    iGrid = Color.Merge(Color.LightForeground, Color.TextBackground)
  Else
    iGrid = Color.Merge(Color.LightForeground, Color.ButtonBackground)
  Endif
  
  hClip = Paint.ClipRect
  
  ' Headers use button colors
  
  Paint.Background = Color.ButtonForeground
  iBg = Color.ButtonBackground
  If Color.Distance(iBg, Color.TextBackground) < 0.1 Then
    iBg = Color.Background
  Endif
  
  ' Column headers
  
  iSort = $hColumns.Sort
  bAscent = $hColumns.Ascending
  
  H = $hColumns.Height + F
  If $iHeader And Horizontal Then Paint.FillRect(0, 0, Paint.W, H, iBg)
  X = XX
  
  If iCol >= 0 Then
    I = iCol
    Do
      If I < 0 Or If I >= $hColumns.Count Then Break
      If X >= $hView.ClientW Then Break
      iCol2 = I
      With $hColumns[I]
        If .W > 0 And If $iHeader And Horizontal Then

          ''If $bGrid Then Draw.FillRect(X - 1, F, 1, H - F, iGrid)
          If System.RightToLeft Then
            Paint.FillRect(X, F, 1, H - F, iGrid)
          Else
            Paint.FillRect(X - 1, F, 1, H - F, iGrid)
          Endif

          Paint.Save

          If iSort = I Then
            WA = Min(12, H - F)
            If WA < .Width Then Style.PaintArrow(X + .Width - WA - $iPadding, F, WA, H - F, If(bAscent, Align.Bottom, Align.Top))
            'Draw.ClipRect = hClip.Intersection(Rect(X, F, Max(0, .Width - WA - 2), H - F))
            'If Draw.ClipRect Then Draw.Text(.Text, X + 4, F, .Width - WA - 8, H - F, .Alignment)
            Paint.Rectangle(X, F, Max(0, .Width - WA - 2), H - F)
            Paint.Clip
            DrawText(.Text, X + 1, F, .Width - WA - $iPadding - 2, H - F - 2, .Alignment, Max(1, $iPadding))
          Else
            Paint.Rectangle(X + 1, F, .Width - 2, H - F)
            Paint.Clip
            DrawText(.Text, X + 1, F, .Width - 2, H - F - 2, .Alignment, Max(1, $iPadding))
          Endif

          Paint.Restore

        Endif
        X += .Width
      End With
      I += iStepCol
    Loop
  Endif

  If $iHeader And Horizontal Then 
    'Draw.ClipRect = hClip
    If $bGrid Then 
      If System.RightToLeft Then
        If X > 0 Then Paint.FillRect(X, F, 1, H - F, iGrid)
      Else
        If X < $hView.ClientW Then Paint.FillRect(X - 1, F, 1, H - F, iGrid)
      Endif
    Endif
  Endif
    
  ' Row headers

  $iFirstRow = iRow
  $aRowY.Clear

  W = $hRows.Width + F
  If $iHeader And Vertical Then 
    If System.RightToLeft Then
      Paint.FillRect($hView.ClientW - W, 0, W, Paint.H, iBg)
    Else
      Paint.FillRect(0, 0, W, Paint.H, iBg)
    Endif
  Endif
  Y = YY
  If System.RightToLeft Then
    X = $hView.ClientW - $hRows.Width - F
  Else
    X = F
  Endif
  
  If iRow >= 0 Then
    For I = iRow To $hRows.Count - 1
      
      If Y >= $hView.ClientH Then Break
      $aRowY.Add(Y - F)
      iRow2 = I
      'Draw.Style.Separator(F, Y, W - F, 2)
      H = $hRows._GetRowHeight(I)
      If H > 0 And If $iHeader And Vertical Then
        Paint.FillRect(X, Y - 1, W - F, 1, iGrid)
        Paint.Save
        Paint.Rectangle(X, Y + 1, W - F, H - 3)
        Paint.Clip
        If I = $iRow Then Paint.Font.Bold = True
        DrawText($hRows._GetRowText(I), X, Y + 2, W - F, H - 3, Align.Center, $iPadding)
        If I = $iRow Then Paint.Font.Bold = False
        Paint.Restore
      Endif
      
      'Draw.Style.Handle(W - 2, Y, 2, H, True)
      Y += H
    Next
  Endif

  $aRowY.Add(Y - F)
  
  If $iHeader And Vertical Then 
    'Draw.ClipRect = hClip
    If $bGrid Then 
      If Y < $hView.ClientH Then Paint.FillRect(F, Y - 1, W - F, 1, iGrid)
    Endif
  Endif

  ' Top-left frame
  
  If $iHeader = Both Then 
    If System.RightToLeft Then
      Paint.FillRect($hView.ClientW - $hRows.Width - F, 0, $hRows.Width + F, $hColumns.Height + F, iBg)
    Else
      Paint.FillRect(0, 0, $hRows.Width + F, $hColumns.Height + F, iBg)
    Endif
  Endif
  
  ' Header limits
  
  If $iHeader And Horizontal Then Paint.FillRect(0, $hColumns.Height + F - 1, $hView.ClientW, 1, Color.Merge(Color.LightForeground, Color.ButtonBackground))
  If $iHeader And Vertical Then 
    If System.RightToLeft Then
      Paint.FillRect($hView.ClientW - $hRows.Width - F, 0, 1, $hView.ClientH, Color.Merge(Color.LightForeground, Color.ButtonBackground))
    Else
      Paint.FillRect($hRows.Width + F - 1, 0, 1, $hView.ClientH, Color.Merge(Color.LightForeground, Color.ButtonBackground))
    Endif
  Endif
  
  If $hColumns.Count = 0 Or If $hRows.Count = 0 Then Return
  If iRow < 0 Or If iRow2 < 0 Then Return
  
  ' Cells
  
  hRect = New Rect(0, 0, $hView.ClientW, $hView.ClientH)
  hRect.Adjust(F)
  If System.RightToLeft Then
    hRect.Adjust(0, $hColumns.Height, $hRows.Width, 0)
  Else
    hRect.Adjust($hRows.Width, $hColumns.Height, 0, 0)
  Endif
  hClip = hRect.Intersection(Paint.ClipRect)
  If Not hClip Then Return
  
  Paint.Save
  Paint.ResetClip
  Paint.Rectangle(hClip.X, hClip.Y, hClip.W, hClip.H)
  Paint.Clip
  
  $bHasDrawEvent = Object.CanRaise(Me, "Draw")
  
  hSaveClip = hClip.Copy()
  'Draw.ClipRect = hClip
  
  Y = YY
  
  For I = iRow To iRow2

    H = $aRowY[I - iRow + 1] + F - Y
    X = XX

    ' Row border
    
    hRowBorder = $hRows._GetRowBorder(I)
    
    If hRowBorder Then
      
      If I > 0 Then 
        hTopRowBorder = $hRows._GetRowBorder(I - 1)
      Else
        hTopRowBorder = Null
      Endif
      
      If I < $hRows.Max Then 
        hBottomRowBorder = $hRows._GetRowBorder(I + 1)
      Else
        hBottomRowBorder = Null
      Endif
    
      Paint.Save
      hRectF = RectF(XO + $hColumns[0].X, Y, $hColumns[$hColumns.Max].X + $hColumns[$hColumns.Max].W - $hColumns[0].X, H) 
      hRowBorder.Clip(hRectF, hTopRowBorder, hBottomRowBorder)
      hRowBorderRect = hRowBorder.GetRect(hRectF, False, hTopRowBorder, hBottomRowBorder)
      
      If Not hRowBorderRect Then 
        Paint.Restore
        Goto NEXT_ROW
      Endif
      
    Else
      
      hRowBorderRect = Null
      
    Endif
    
    For J = iCol To iCol2 Step iStepCol
      
      W = $hColumns[J].Width
      
      R = I
      C = J
      
      bHasSpan = HasSpan(I, J)
      
      If bHasSpan Then
        
        aSpan = _GetSpan(I, J)
        iRowSpan = aSpan[0]
        iColSpan = aSpan[1]
        
        'Draw.ClipRect = hClip
        'Draw.Foreground = Color.Green
        'Draw.Text(iRowSpan & " / " & iColSpan, X, Y, $hColumns[J].Width, H, Align.Center)
        
        If iRowSpan < 0 Then R += iRowSpan
        If iColSpan < 0 Then C += iColSpan

        If (iRowSpan < 0 Or iColSpan < 0) And If R >= iRow And If C >= iCol Then Goto NEXT_CELL

        aSpan = _GetSpan(R, C)
        iRowSpan = aSpan[0]
        iColSpan = aSpan[1]
        
      ' Else
      '   
      '   iRowSpan = 0
      '   iColSpan = 0
        
        ' Draw.ClipRect = hClip
        ' Draw.Foreground = Color.Green
        ' Draw.Text(iRowSpan & " / " & iColSpan, X, Y, $hColumns[J].Width, H, Align.Center)
        
      Endif
      
      If bHasSpan Then
      
        XS = XO + $hColumns[C].X
        YS = YO + $hRows._GetRowY(R)
        hSpan = Rect(XS, YS, XO + $hColumns[C + iColSpan].X + $hColumns[C + iColSpan].W - XS, YO + $hRows._GetRowY(R + iRowSpan) + $hRows._GetRowHeight(R + iRowSpan) - YS)
        
      Else
      
        hSpan = Rect(X, Y, W, H)
        
      Endif
      
      If hRowBorderRect Then 
        hSpan = hSpan.Intersection(hRowBorderRect)
        If Not hSpan Then Goto NEXT_CELL
      Endif
      
      If Not hClip.Intersection(hSpan) Then Goto NEXT_CELL
      
      hData = _GetCellData(R, C)
      
      Paint.Save
      
      If hData.Border Then 'hSpan = hData.Border.GetRect(RectF(hSpan.X, hSpan.Y, hSpan.W, hSpan.H), True)
        hData.Border.Clip(RectF(hSpan.X, hSpan.Y, hSpan.W, hSpan.H))
      Endif
        
      Paint.Rectangle(hSpan.X, hSpan.Y, hSpan.W, hSpan.H)
      Paint.Clip
      
      DrawCell(hSpan.X, hSpan.Y, hSpan.W, hSpan.H, R, C, hData, hRowBorder)
      
      If hData.Border Then 
        hData.Border.Paint(RectF(hSpan.X, hSpan.Y, hSpan.W, hSpan.H))
      Endif
      
      If Not hRowBorder Then
        If $iMode And If Not _DoNotDrawSelection Then
          If _IsRowSelected(I) Then
            Paint.FillRect(0, Y, Paint.W, H, iBgSel)
          Endif
        Endif
      Endif
      
      Paint.Restore
      
    NEXT_CELL:
      
      If I = $iRow And If J = $iCol Then
        If System.RightToLeft Then
          hCursor = Rect(X + 1, Y, Max(0, W - 1), Max(0, H - 1))
          If J = 0 Then Inc hCursor.Left
        Else
          hCursor = Rect(X, Y, Max(0, W - 1), Max(0, H - 1))
          If J = $hColumns.Max Then Inc hCursor.Right
        Endif
        'If I = $hRows.Max Then Dec hCursor.Bottom
        ' Paint.Begin(Draw.Device)
        ' Paint.ClipRect = hClip
        ' Paint.Brush = Paint.Color(Color.SetAlpha(Color.SelectedBackground, 192))
        ' Paint.Rectangle(X, Y, W, H)
        ' Paint.Stroke
        ' Paint.End
      Endif
      
      X += W
      
    Next
    
    If hRowBorder Then
      
      If $iMode And If Not _DoNotDrawSelection Then
        If _IsRowSelected(I) Then
          Paint.FillRect(0, Y, Paint.W, H, Color.SetAlpha(Color.SelectedBackground, 192))
        Endif
      Endif
      
      Paint.Restore
      hRowBorder.Paint(RectF(XO + $hColumns[0].X, Y, $hColumns[$hColumns.Max].X + $hColumns[$hColumns.Max].W - $hColumns[0].X, H), hTopRowBorder, hBottomRowBorder)
    Endif
    
  NEXT_ROW:
    
    Y += H
    
  Next
  
  If hCursor Then
    If $bShowCursor Then
      'Paint.FillRect(hSpan.X, hSpan.Y, hSpan.W, hSpan.H, Color.SetAlpha(Color.SelectedBackground, 192))
      'Draw.ClipRect = hClip
      Paint.Background = Color.LightBackground 'iGrid 'Color.LightForeground
      Paint.LineCap = Paint.LineCapSquare
      Paint.LineWidth = 1.5
      Paint.Rectangle(hCursor.X, hCursor.Y, hCursor.W, hCursor.H)
      Paint.Stroke
    Endif
  Endif
  
  $hData = Null
  
  ' Sorted column
  
  If $bSorted And If $hColumns.Count > 1 And If iSort >= 0 And If iSort < $hColumns.Count Then
    
    'Paint.Begin(Draw.Device)
    Paint.ClipRect = hClip
    With $hColumns[iSort]
      Paint.FillRect(XO + .X, $hColumns.H + F, .W, $hView.ClientH - $hColumns.H - F * 2, Color.SetAlpha(Style.ForegroundOf(Me), 252))
    End With

    'Paint.End
    
  Endif

  ' Row selection

  ' If $iMode And If Not _DoNotDrawSelection Then
  ' 
  '   Y = YY
  '   X = XX
  '   
  '   'Paint.Begin(Draw.Device)
  '   'Paint.ClipRect = hSaveClip
  '   Paint.Brush = Paint.Color(Color.SetAlpha(Color.SelectedBackground, 192))
  '   
  '   For I = iRow To iRow2
  ' 
  '     H = $aRowY[I - iRow + 1] + F - Y
  '     
  '     If _IsRowSelected(I) Then
  '       'Paint.Rectangle(X, Y, $hColumns._GetWidth(), H)
  '       Paint.Rectangle(F, Y, $hView.ClientW - F * 2, H - If($bGrid, 1, 0))
  '       Paint.Fill
  '     Endif
  '     
  '     Y += H
  '     
  '   Next
  '   
  '   'Paint.End
  '   
  ' Endif
  
  Paint.Restore

  ' If Me.HasFocus And If Not $hView.Border Then
  '   Draw.ClipRect = Null
  '   Draw.Foreground = Color.LightBackground 'Color.LightForeground
  '   Draw.Rect($hView.ClientX, $hView.ClientY, $hView.ClientW, $hView.ClientH)
  ' Endif

End

Private Function Border_Read() As Boolean

  Return $hView.Border

End

Private Sub Border_Write(Value As Boolean)

  If $hView.Border = Value Then Return
  $hView.Border = Value
  ScrollArea_Arrange

End

Public Sub _GetFrameWidth() As Integer
  
  'If $hView.Border Then Return 1 'Return Style.FrameWidth
  
End


Public Sub _ResizeContents()
  
  Dim F As Integer = _GetFrameWidth()
  
  ' Debug $hRows._GetHeight(); " / "; $hRows.Count;;
  ' If $hRows.Count Then Error $hRows[0].H * $hRows.Count;
  ' Error
  
  $hView.ResizeContents($hColumns._GetWidth() + $hRows.Width + F * 2, $hRows._GetHeight() + $hColumns.Height + F * 2)
  $hView._SetShadowOffset($hColumns.H, 0, If(System.RightToLeft, 0, $hRows.W), If(System.RightToLeft, $hRows.W, 0))
  
End

Private Function Grid_Read() As Boolean

  Return $bGrid

End

Private Sub Grid_Write(Value As Boolean)

  $bGrid = Value
  $hView.Refresh

End

Private Function Mode_Read() As Integer

  Return $iMode

End

Private Sub Mode_Write(Value As Integer)

  If Value = $iMode Then Return

  Select Case Value
    Case Select.None, Select.Multiple, Select.Single
      $hRows.UnSelectAll
      $iMode = Value
  End Select
  
  $hView.Refresh

End

Public Sub ScrollArea_Enter()
  
  $iDefaultMouse = Me.Mouse
  
End

Public Sub ScrollArea_Leave()
  
  Me.Mouse = $iDefaultMouse
  
End

Private Sub InRowHeader(X As Integer) As Boolean
  
  If $hRows.Width = 0 Then Return
  
  If System.RightToLeft Then
    Return X >= $hView.ClientW - $hRows.Width
  Else
    Return X < $hRows.Width
  Endif
  
End


Public Sub ScrollArea_MouseMove()
  
  Dim I, MX, MY, X, Y, iRow, iCol As Integer
  Dim iMouse As Integer
  Dim F As Integer = _GetFrameWidth()
  Dim bInRowHeader As Boolean
  Dim HW As Integer

  If Me.Design Then Return
  If Not Me.Enabled Then Return
  If $bIgnoreMove Then Return
  If _NoMouse Then Return

  If $hRows.Count = 0 And If $hColumns.Count = 0 Then Return
  
  If $bInCell And If Mouse.Left And If Not $hTimerScroll Then
    $hTimerScroll = New Timer As "TimerScroll"
    $hTimerScroll.Delay = 50
    $hTimerScroll.Start
  Endif

  MX = Mouse.X - F
  MY = Mouse.Y - F
  
  $bInCell = False
  $bInRow = False
  
  If $bResize Then
    If $iRowResize >= 0 Then
      $hRows._SetRowHeight($iRowResize, Max(1, $iDimResize + MY - $MY))
    Else If $iColResize >= 0 Then
      'Debug "Resize "; $iColResize; ": "; $hColumns[$iColResize].Width;; "->";; Max(1, $iDimResize + MX - $MX)
      If System.RightToLeft Then
        $hColumns[$iColResize].Width = Max(1, $iDimResize + $MX - MX)
      Else
        $hColumns[$iColResize].Width = Max(1, $iDimResize + MX - $MX)
      Endif
      'Debug "ScrollX = "; Me.ScrollX
    Endif
    Return
  Endif
  
  iMouse = $iDefaultMouse 'Mouse.Default
  
  $iRowResize = -1
  $iColResize = -1
  HW = (Desktop.Scale * 3) \ 4
  
  bInRowHeader = InRowHeader(MX)
  
  If bInRowHeader Then
    
    If $hRows.Resizable Then
      For I = 0 To $aRowY.Max
        If MY >= ($aRowY[I] - HW) And If MY <= ($aRowY[I] + HW) Then
          If I + $iFirstRow Then
            iMouse = Mouse.SizeS
            $iRowResize = I + $iFirstRow - 1
            $iDimResize = $hRows._GetRowHeight($iRowResize)
          Endif
          Break
        Endif
      Next
    Endif
    
  Else If MY < $hColumns.Height Then
    
    If $hColumns.Resizable Then
      
      X = MX + $hView.ScrollX
      If Not System.RightToLeft Then X -= $hRows.Width
      
      If System.RightToLeft Then
        ' For I = $hColumns.Count - 2 DownTo 0
        '   With $hColumns[I]
        '     If $hColumns[I + 1].Resizable And If X >= (.X - 1) And If X <= (.X + 2) Then
        '       iMouse = Mouse.SizeE
        '       $iColResize = I + 1
        '       $iDimResize = $hColumns[$iColResize].Width
        '       Break
        '     Endif
        '   End With
        ' Next
        For I = 1 To $hColumns.Count - 1
          With $hColumns[I]
            If $hColumns[I].Resizable And If X >= (.X - HW) And If X <= (.X + HW) Then
              iMouse = Mouse.SizeE
              $iColResize = I
              $iDimResize = $hColumns[$iColResize].Width
              Break
            Endif
          End With
        Next
      Else
        For I = 1 To $hColumns.Count - 1
          With $hColumns[I]
            If $hColumns[I - 1].Resizable And If X >= (.X - HW) And If X <= (.X + HW) Then
              iMouse = Mouse.SizeE
              $iColResize = I - 1
              $iDimResize = $hColumns[$iColResize].Width
              Break
            Endif
          End With
        Next
      Endif
      
      If System.RightToLeft Then
        If $iColResize < 0 And If $hColumns[0].Resizable And If X >= ($hColumns._GetWidth() - HW) And If X <= ($hColumns._GetWidth() + HW) Then
          iMouse = Mouse.SizeE
          $iColResize = 0
          $iDimResize = $hColumns[$iColResize].Width
        Endif
      Else
        If $iColResize < 0 And If $hColumns[$hColumns.Count - 1].Resizable And If X >= ($hColumns._GetWidth() - HW) And If X <= ($hColumns._GetWidth() + HW) Then
          iMouse = Mouse.SizeE
          $iColResize = $hColumns.Count - 1
          $iDimResize = $hColumns[$iColResize].Width
        Endif
      Endif
      
    Endif
    
  Endif
    
  If Mouse.Button = 0 And If $hView.Mouse <> iMouse Then $hView.Mouse = iMouse
  
  'If $iColResize >= 0 Then Debug "Resize?";; $iColResize
  
  If $iRowResize >= 0 Or If $iColResize >= 0 Then Return
  
  iRow = -1
  iCol = -1
  
  X = MX
  Y = MY
  $SX = X
  $SY = Y
  
  If Not System.RightToLeft Then X -= $hRows.W
  
  If Mouse.Left Or If Mouse.Right Then
    
    If Y >= $hColumns.Height Then
      For I = 1 To $aRowY.Max
        If Y < $aRowY[I] Then
          iRow = I + $iFirstRow - 1
          Break
        Endif
      Next
    Endif
    
    If Y < 0 Or If Y >= $hColumns.Height Then
      If iRow < 0 Then 
        iRow = $hRows._FindRowFromPos(Y - $hColumns.Height + $hView.ScrollY)
      Endif
    Endif
    
    If Not bInRowHeader Then
      
      X += $hView.ScrollX
      iCol = $hColumns._FindColumnFromPos(X)
      
    Endif
    
  Endif
  
  If iRow >= 0 Then
    
    $bInRow = True
    
    If iCol >= 0 Then $bInCell = True
    
    MoveTo(iRow, iCol)

  Endif
    
End

Public Sub TimerScroll_Timer()
  
  Dim X As Integer = $SX - If(System.RightToLeft, 0, $hRows.W) + $hView.ScrollX
  Dim Y As Integer = $SY - $hColumns.Height + $hView.ScrollY
  Dim iCol As Integer
  Dim iRow As Integer 
  
  If Drag.Pending Then
    $hTimerScroll.Stop
    Return
  Endif
  
  If InRowHeader($SX) Then
    iCol = -1
  Else
    iCol = $hColumns._FindColumnFromPos(X)
    If iCol < 0 Then iCol = If(System.RightToLeft, 0, $hColumns.Count - 1)
  Endif
  
  If Y < 0 Then
    iRow = 0
  Else
    iRow = $hRows._FindRowFromPos(Y)
    If iRow < 0 Then iRow = $hRows.Count - 1
  Endif
  
  MoveTo(iRow, iCol)
  
End

Public Sub _EnsureVisibleScroll(X As Integer, Y As Integer)
  
  $hView.EnsureVisible($hView.ScrollX + X - 16 - $hColumns.W, $hView.ScrollY + Y - 16 - $hRows.H, 32, 32)
  
End


Public Sub ScrollArea_MouseDrag()
  
  If Me.Design Then Return
  If Not Me.Enabled Then Return
  If _NoMouse Then Return
  
  $bIgnoreMove = False
  If $bResize Or If $bMoveSelect Then 
    Stop Event
    Return
  Endif
  
  If Not $hTimerScroll Then
    $hTimerScroll = New Timer As "TimerScroll"
    $hTimerScroll.Delay = 50
    $hTimerScroll.Start
  Endif
  
End

Public Sub ScrollArea_MouseDown()
  
  Dim I, iOldRow As Integer
  Dim bCancel As Boolean
  Dim F As Integer = _GetFrameWidth()
  
  $MX = Mouse.X - F
  $MY = Mouse.Y - F
  
  If Me.Design Then Return
  If Not Me.Enabled Then Return
  If _NoMouse Then Return
  
  Me.SetFocus
  
  iOldRow = $iRow
  
  $bIgnoreMove = False

  ScrollArea_MouseMove
  
  $bIgnoreMove = True

  If $iRowResize >= 0 Or If $iColResize >= 0 Then
    $bResize = True
    Return
  Endif
  
  If $iMode = Select.Multiple Then
    If $bInRow Then
      If Mouse.Control Then
        If $hRows._IsSelected($iRow) Then
          $hRows.UnSelect($iRow, 1)
          $iMoveSelectRow = $iRow
          $hMoveOldSelection = $hRows._SaveSelection()
          $bMoveUnSelect = True
        Else
          $hRows.Select($iRow, 1)
          $iMoveSelectRow = $iRow
          $hMoveOldSelection = $hRows._SaveSelection()
          $bMoveSelect = True
        Endif
      Else If Mouse.Shift And If iOldRow >= 0 Then 
        $hRows._GetSel().UnSelectAll
        $hRows.Select(iOldRow, 1)
        $iMoveSelectRow = iOldRow
        $hMoveOldSelection = $hRows._SaveSelection()
        $bMoveSelect = True
        Dec $iRow
        MoveTo($iRow + 1, -1)
      Else If Not _IsRowSelected($iRow) Then
        $hRows._GetSel().UnSelectAll
        $hRows.Select($iRow, 1)
        $iMoveSelectRow = $iRow
        $hMoveOldSelection = $hRows._SaveSelection()
        $bMoveSelect = True
      Else
        $iMoveSelectRow = $iRow
      Endif
    Endif
  Endif
  
  If $bInCell Then
    
  Else If Mouse.X < $hRows.Width And If Mouse.Y > $hColumns.H Then
    I = $hRows._FindRowFromPos(Mouse.Y - $hColumns.Height + $hView.ScrollY)
    If I >= 0 Then 
      'bCancel = Raise MouseDown
      'If Not bCancel Then Raise RowClick(I)
      
      Raise RowClick(I)
      'Stop Event
    Endif
  Else If Mouse.Y < $hColumns.Height And If Mouse.X > $hRows.W Then
    I = $hColumns._FindColumnFromPos(Mouse.X - $hRows.Width + $hView.ScrollX)
    If I >= 0 Then 
      'bCancel = Raise MouseDown
      'If Not bCancel Then
        bCancel = Raise ColumnClick(I)
        If Not bCancel Then
          If $bSorted Then
            If $hColumns.Sort = I Then
              $hColumns.Ascending = Not $hColumns.Ascending
            Else
              $hColumns.Sort = I
              $hColumns.Ascending = True
            Endif
          Endif
        Endif
      'Endif
      'Stop Event
    Endif
  Endif
  
End

' Public Sub ScrollArea_Menu()
'   
'   Debug
'   
' End

Private Sub AfterMouseUp()

  If Me.Design Then Return
  If _NoMouse Then Return
  
  $bResize = False
  $bMoveSelect = False
  $bMoveUnSelect = False
  $hMoveOldSelection = Null
  $iMoveSelectRow = -1
  $bIgnoreMove = False
  
  If $hTimerScroll Then
    $hTimerScroll.Stop
    $hTimerScroll = Null
  Endif
  
End


Public Sub ScrollArea_MouseUp()
  
  AfterMouseUp
  
End

Public Sub ScrollArea_DragLeave()
  
  AfterMouseUp
  
End


Public Sub ScrollArea_GotFocus()
  
  $hView.Refresh
  
End

Public Sub ScrollArea_LostFocus()
  
  AfterMouseUp
  $hView.Refresh
  
End


Public Sub ScrollArea_DblClick()
  
  'Debug $bInCell
  
  If Me.Design Then Return
  If _NoMouse Then Return
  
  If $bInCell Then 
    Raise Activate
  Else If $iColResize >= 0 Then
    $hColumns[$iColResize].Width = -1
  Else If $iRowResize >= 0 Then
    $hRows[$iRowResize].Height = -1
  Endif
  
End


Private Function Data_Read() As _GridView_Data

  Return $hData

End

Public Sub _CheckCell(iRow As Integer, iColumn As Integer) 
  
  If iRow < 0 Or If iRow >= $hRows.Count Then Error.Raise("Bad row index")
  If iColumn < 0 Or If iColumn >= $hColumns.Count Then Error.Raise("Bad column index")
  
End

Public Sub _CheckCurrent()
  
  MoveTo(Min($iRow, $hRows.Count - 1), Min($iCol, $hColumns.Count - 1))
  
End


Public Sub _GetCellData(iRow As Integer, iColumn As Integer, Optional bCreate As Boolean) As _GridView_Data

  Dim hData As _GridView_Data

  hData = $cCells[GetCellKey(iRow, iColumn)]
  If Not hData Then
    If bCreate Then
      hData = New _GridView_Data As "GridViewData"
      hData.Font = Me.Font.Copy()
      hData.Font.Modified = False
      hData.Alignment = $hColumns[iColumn].Alignment
      $cCells[GetCellKey(iRow, iColumn)] = hData
    Else
      $hData = New _GridView_Data As "GridViewData"
      $hData.Font = Me.Font.Copy()
      $hData.Font.Modified = False
      $hData.Alignment = $hColumns[iColumn].Alignment
      Raise Data(iRow, iColumn)
      hData = $hData
    Endif
  Endif
  
  Return hData
  
End


Public Sub _get(Row As Integer, Column As Integer) As _GridView_Cell
  
  Dim hCell As _GridView_Cell
  
  hCell = New _GridView_Cell
  hCell._Row = Row
  hCell._Column = Column
  hCell._View = Me
  Return hCell
  
End

Public Sub MoveTo(Row As Integer, Column As Integer)
  
  Dim S, L As Integer
  
  If Column < 0 Then Column = $iCol
  
  If Row < 0 Then
    If $iRow < 0 Then Return
    Row = -1
  Else If Row = $iRow And If Column = $iCol Then
    Return
  Else If Row >= $hRows.Count Or If Column < 0 Or If Column >= $hColumns.Count Then
    Return
  Endif
  
  $iRow = Row
  $iCol = Column
  
  If $iRow >= 0 And If $iCol < 0 Then $iCol = 0
  
  If $iRow >= 0 And If $iCol >= 0 Then _EnsureVisible($iRow, $iCol)
  $hView.Refresh

  Raise Change
  If $iMode = Select.Single Then 
    Raise Select
  Else If $bMoveSelect Or $bMoveUnSelect Then
    If $hMoveOldSelection Then
      $hRows._RestoreSelection($hMoveOldSelection)
      S = Min($iRow, $iMoveSelectRow)
      L = Max($iRow, $iMoveSelectRow) - Min($iRow, $iMoveSelectRow) + 1
      If $bMoveSelect Then
        $hRows.Select(S, L)
      Else
        $hRows.UnSelect(S, L)
      Endif
    Endif
  Else If $bKeyEvent And If $iMode = Select.Multiple Then
    $hRows._GetSel().UnSelectAll
    $hRows.Select($iRow, 1)
  Endif
  
End

Private Function Row_Read() As Integer

  Return $iRow

End

Private Sub Row_Write(Value As Integer)

  MoveTo(Value, $iCol)

End

Private Function Column_Read() As Integer

  If $iRow < 0 Then Return -1
  Return $iCol

End

Private Sub Column_Write(Value As Integer)

  MoveTo($iRow, Value)

End


' Private Sub EnsureRowVisible(iRow As Integer)
'   
'   'Debug iRow; ": "; $hView.ScrollX, $hRows._GetRowY(iRow), $hView.ClientW, $hRows._GetRowHeight(iRow)
'   Dim F As Integer = GetFrameWidth()
'   
'   $hView.EnsureVisible($hView.ScrollX - F, $hRows._GetRowY(iRow) - F, $hView.ClientW + F * 2, $hRows._GetRowHeight(iRow) + $hColumns.Height + F * 2)
'   
' End

Public Sub _EnsureVisible(iRow As Integer, iCol As Integer)
  
  If Not $hTimerEnsureVisible Then $hTimerEnsureVisible = New Timer As "TimerEnsureVisible"
  If $iRowEV < 0 Then $hTimerEnsureVisible.Trigger
  
  $iRowEV = iRow
  $iColEV = iCol
  
  'Debug iRow;; iCol
  
End

Public Sub TimerEnsureVisible_Timer()
  
  Dim iRowEV As Integer = $iRowEV
  Dim F As Integer = _GetFrameWidth()
  
  $iRowEV = -1

  With $hColumns[$iColEV]
    $hView.EnsureVisible(.X, $hRows._GetRowY(iRowEV) + F, Min($hView.ClientW - $hRows.W, .Width + $hRows.Width), $hRows._GetRowHeight(iRowEV) + $hColumns.Height + F)
  End With
  
Catch
  
End

Public Sub _SelectRow(iRow As Integer, bSelect As Boolean)
  
  If $iMode = Select.Single Then
    If bSelect Then
      If $iRow <> iRow Then
        Row_Write(iRow)
      Endif
    Else If $iRow >= 0 Then
      Row_Write(-1)
    Endif
  Endif
  
End

Public Sub Clear()
  
  $cCells.Clear
  $hRows._Clear
  $iRow = -1
  $iCol = 0
  _ResizeContents
  $hView.Refresh
  
End

Public Sub _ClearCell(iRow As Integer, iCol As Integer)
  
  $cCells.Remove(GetCellKey(iRow, iCol))
  
End

Private Function Resizable_Read() As Boolean

  Return $hColumns.Resizable

End

Private Sub Resizable_Write(Value As Boolean)

  $hColumns.Resizable = Value

End

Private Function ScrollX_Read() As Integer

  Return $hView.ScrollX

End

Private Sub ScrollX_Write(Value As Integer)

  $hView.ScrollX = Value

End

Private Function ScrollY_Read() As Integer

  Return $hView.ScrollY

End

Private Sub ScrollY_Write(Value As Integer)

  $hView.ScrollY = Value

End


Private Function ScrollW_Read() As Integer

  Return $hView.ScrollW

End

Private Function ScrollH_Read() As Integer

  Return $hView.ScrollH

End

Private Function ClientX_Read() As Integer

  Return $hView.ClientX + _GetFrameWidth()

End

Private Function ClientY_Read() As Integer

  Return $hView.ClientY + _GetFrameWidth()

End

Private Function ClientW_Read() As Integer

  Return $hView.ClientW - _GetFrameWidth() * 2

End

Private Function ClientH_Read() As Integer

  Return $hView.ClientH - _GetFrameWidth() * 2

End

Public Sub ScrollArea_Scroll()
  
  Raise Scroll
  
End

Public Sub _RaiseSelect()
  
  $hView.Refresh
  Raise Select
  
End

Public Sub Select(Optional Start As Integer = 0, Optional Length As Integer = 1)
  
  $hRows.Select(Start, Length)
  
End

Public Sub SelectAll()
  
  $hRows.SelectAll
  
End

Public Sub UnselectAll()
  
  $hRows.UnSelectAll
  
End

Private Function Scrollbar_Read() As Integer

  Return $hView.ScrollBar

End

Private Sub Scrollbar_Write(Value As Integer)

  $hView.ScrollBar = Value

End

Private Function AutoResize_Read() As Boolean

  Return $bAutoResize

End

Private Sub AutoResize_Write(Value As Boolean)

  $bAutoResize = Value
  $hColumns._Layout

End

Private Function Header_Read() As Integer

  Return $iHeader

End

Private Sub Header_Write(Value As Integer)

  Value = Value And 3

  $iHeader = Value
  $hColumns._Layout
  $hView.Refresh

End

Public Sub ScrollArea_KeyPress()
  
  Dim iRow As Integer
  Dim bStop As Boolean
  Dim iCode As Integer
  
  $bKeyEvent = True
  
  If $iMode = Select.Multiple Then
    $bMoveSelect = Key.Shift
    If $bMoveSelect And If $iMoveSelectRow < 0 Then
      $iMoveSelectRow = $iRow
      $hMoveOldSelection = $hRows._SaveSelection()
    Endif
  Endif
  
  iCode = Key.Code
  If System.RightToLeft Then
    If iCode = Key.Left Then
      iCode = Key.Right
    Else If iCode = Key.Right Then
      iCode = Key.Left
    Endif
  Endif
  
  Select iCode
    
    Case Key.Up, Key.Down, Key.Left, Key.Right, Key.Home, Key.End, Key.PageUp, Key.PageDown
      bStop = Raise KeyPress
      If bStop Then 
        Stop Event
        Goto _RETURN
      Endif
    
  End Select
  
  Select iCode
    
    Case Key.Up
      If $iRow > 0 Then MoveTo($iRow - 1, $iCol)
      Stop Event
      
    Case Key.Down
      If $iRow < ($hRows.Count - 1) Then MoveTo($iRow + 1, $iCol)
      Stop Event
      
    Case Key.Left
      If $iRow >= 0 Then
        If $iCol > 0 Then
          MoveTo($iRow, $iCol - 1)
        Else If $iRow > 0 Then
          MoveTo($iRow - 1, $hColumns.Count - 1)
        Endif
      Endif
      Stop Event
    
    Case Key.Right
      If $iRow >= 0 Then
        If $iCol < ($hColumns.Count - 1) Then 
          MoveTo($iRow, $iCol + 1)
        Else If $iRow < ($hRows.Count - 1) Then
          MoveTo($iRow + 1, 0)
        Endif
      Endif
      Stop Event
    
    Case Key.Home
      If Key.Control Or If Not $bShowCursor Then
        MoveTo(0, 0)
      Else
        MoveTo($iRow, 0)
      Endif
      Stop Event
    
    Case Key.End
      If Key.Control Or If Not $bShowCursor Then
        MoveTo($hRows.Count - 1, $hColumns.Count - 1)
      Else
        MoveTo($iRow, $hColumns.Count - 1)
      Endif
      Stop Event
      
    Case Key.PageUp
      iRow = $hRows._FindRowFromPos($hRows._GetRowY($iRow) + $hRows._GetRowHeight($iRow) - ($hView.ClientH - $hColumns.H - _GetFrameWidth() * 2))
      If iRow >= 0 Then 
        MoveTo(iRow, $iCol)
      Else
        MoveTo(0, $iCol)
      Endif
      Stop Event
      
    Case Key.PageDown
      iRow = $hRows._FindRowFromPos($hRows._GetRowY($iRow) + $hView.ClientH - $hColumns.H - _GetFrameWidth() * 2)
      If iRow >= 0 Then 
        MoveTo(iRow, $iCol)
      Else
        MoveTo($hRows.Count - 1, $iCol)
      Endif
      Stop Event
    
  End Select

_RETURN:

  $bKeyEvent = False
  
End

Private Sub MakeSpan(iRowSpan As Integer, iColSpan As Integer) As Integer
  
  Return Lsl(iRowSpan, 16) Or (iColSpan And &HFFFF&)
  
End

Private Sub UnmakeSpan(iSpan As Integer) As Short[]
  
  Return [CShort(Lsr(iSpan, 16)), CShort(iSpan And &HFFFF&)]
  
End


Public Sub _SetSpan(iRow As Integer, iCol As Integer, iRowSpan As Integer, iColSpan As Integer)
  
  Dim aOldSpan As Short[]
  Dim iOldRowSpan As Integer
  Dim iOldColSpan As Integer
  Dim I, J As Integer
  
  If iRow < 0 Or If iCol < 0 Or If iRow >= $hRows.Count Or If iCol >= $hColumns.Count Then Return
  
  If iRowSpan < -32768 Or If iRowSpan > 32767 Then Return
  If iColSpan < -32768 Or If iColSpan > 32767 Then Return

  If iRowSpan > 0 And If iColSpan < 0 Then iColSpan = 0
  If iColSpan > 0 And If iRowSpan < 0 Then iRowSpan = 0
  
  aOldSpan = _GetSpan(iRow, iCol)
  iOldRowSpan = aOldSpan[0]
  iOldColSpan = aOldSpan[1]
  
  If (iOldRowSpan < 0 Or iOldColSpan < 0) And If (iRowSpan <> 0 Or iColSpan <> 0) Then Return
  
  $cSpan.Remove(GetCellKey(iRow, iCol))
  
  If iOldColSpan > 0 Or If iOldRowSpan > 0 Then
    
    I = 1
    J = 0
    Do
      If I > iOldColSpan Then
        I = 0
        Inc J
        If J > iOldRowSpan Then Break
      Endif
      _SetSpan(iCol + I, iRow + J, 0, 0)
      Inc I
    Loop
    
  Endif

  If iRowSpan = 0 And If iColSpan = 0 Then Return
  
  $cSpan[GetCellKey(iRow, iCol)] = MakeSpan(iRowSpan, iColSpan)
  
  If iRowSpan >= 0 And If iColSpan >= 0 Then
    
    For I = 0 To iRowSpan
      For J = 0 To iColSpan
        If I = 0 And If J = 0 Then Continue
        _SetSpan(iRow + I, iCol + J, - I, - J)
      Next
    Next
    
  Endif
  
End

Private Sub HasSpan(iRow As Integer, iCol As Integer) As Boolean
  
  Return $cSpan.Exist(GetCellKey(iRow, iCol))
  
End


Public Sub _GetSpan(iRow As Integer, iCol As Integer) As Short[]
  
  Dim aSpan As New Short[2]
  Dim iSpan As Integer
  
  If iRow < 0 Or If iCol < 0 Or If iRow >= $hRows.Count Or If iCol >= $hColumns.Count Then Return aSpan
  Try iSpan = $cSpan[GetCellKey(iRow, iCol)]
  If iSpan = 0 Then Return aSpan
  aSpan = UnmakeSpan(iSpan)
  aSpan[0] = Min(aSpan[0], $hRows.Count - iRow - 1)
  aSpan[1] = Min(aSpan[1], $hColumns.Count - iCol - 1)
  Return aSpan
  
End


Private Function ShowCursor_Read() As Boolean

  Return $bShowCursor

End

Private Sub ShowCursor_Write(Value As Boolean)

  $bShowCursor = Value
  $hView.Refresh

End

Public Sub _GetCellWidth(iRow As Integer, iCol As Integer) As Integer
  
  Dim W, I As Integer

  If Not HasSpan(iRow, iCol) Then Return $hColumns[iCol].Width

  For I = iCol To iCol + Max(0, _GetSpan(iRow, iCol)[1])
    W += $hColumns[I].Width
  Next
  
  Return W
  
End

Public Sub _GetCellHeight(iRow As Integer, iCol As Integer) As Integer
  
  Dim H, I As Integer

  If Not HasSpan(iRow, iCol) Then Return $hRows._GetRowHeight(iRow)

  For I = iRow To iRow + Max(0, _GetSpan(iRow, iCol)[0])
    H += $hRows._GetRowHeight(I)
  Next
  
  Return H
  
End

Private Function Current_Read() As _GridView_Cell

  If $iRow < 0 Or If $iCol < 0 Then Return
  Return _get($iRow, $iCol)

End

Public Sub RowAt(Y As Integer) As Integer
  
  Y -= $hColumns.Height
  If Y < 0 Then Return -1
  
  Return $hRows._FindRowFromPos(Y + $hView.ScrollY)
  
End

Public Sub ColumnAt(X As Integer) As Integer

  X -= $hRows.Width + $hView.Proxy.X
  If X < 0 Then Return -1
  
  Return $hColumns._FindColumnFromPos(X + $hView.ScrollX)
  
End

Public Sub _GetVisibleWidth() As Integer
  
  Return $hView.ClientW - _GetFrameWidth() * 2 - $hRows.Width
  
End

Public Sub ScrollArea_Resize()
  
  'Debug $hView.ClientW
  $hColumns.Column__Refresh
  
End

Public Sub ScrollArea_Arrange()
  
  'Debug $hView.ClientW
  $hColumns.Column__Refresh
  
End

Private Sub MoveCell(iRowSrc As Integer, iColSrc As Integer, iRowDst As Integer, iColDst As Integer)
  
  Dim S, D As String
  
  S = GetCellKey(iRowSrc, iColSrc)
  D = GetCellKey(iRowDst, iColDst)
  
  $cCells[D] = $cCells[S]
  $cCells[S] = Null
  
  ' If HasSpan(iRowSrc, iColSrc) Then
  '   aSpan = _GetSpan(iRowSrc, iColSrc)
  '   _SetSpan(iRowSrc, iColSrc, 0, 0)
  '   _SetSpan(iRowDst, iColDst, aSpan[0], aSpan[1])
  ' Endif
  
End


Public Sub _RemoveRows(Start As Integer, Length As Integer)
  
  Dim I, J, D As Integer
  
  If Start < 0 Or If Start >= $hRows.Count Or Length <= 0 Or (Start + Length) > $hRows.Count Then Error.Raise("Bad argument")
  
  D = Start
  
  'For J = 0 To $hColumns.Max
  '  _SetSpan(D, J, 0, 0)
  'Next
  
  For I = Start + Length To $hRows.Max
    For J = 0 To $hColumns.Max
      MoveCell(I, J, D, J)
    Next
    Inc D
  Next
  
  $hRows._GetSel().RemoveRows(Start, Length)
  $hRows.Count -= Length
  
End

Public Sub _InsertRows(Start As Integer, Length As Integer)
  
  Dim I, J As Integer
  
  If Start < 0 Or If Length <= 0 Or If Start > $hRows.Count Then Error.Raise("Bad argument")
  
  For I = $hRows.Max DownTo Start
    For J = 0 To $hColumns.Max
      MoveCell(I, J, I + Length, J)
    Next
  Next
  
  $hRows._GetSel().InsertRows(Start, Length)
  $hRows.Count += Length
  
End

Public Sub _GetTextHeight() As Integer
  
  If $iTextHeight = 0 Then $iTextHeight = Me.Font.TextHeight(" ")
  Return $iTextHeight
  
End

' Private Function Mouse_Read() As Integer
' 
'   Return Super.Mouse
' 
' End
' 
' Private Sub Mouse_Write(Value As Integer)
' 
'   Super.Mouse = Value
'   $iDefaultMouse = Value
' 
' End

Public Sub _GetPreferredWidth(iCol As Integer) As Integer
  
  Dim PW, W, I As Integer
  Dim hData As _GridView_Data
  Dim hFont As Font
  Dim iColSpan As Integer
  Dim D As Integer
  Dim iPadding As Integer
  Dim fTime As Float
  Dim hBorder As Border
  Dim fDiff As Float
  Dim bBusy As Boolean
  Dim J As Integer
  
  PW = Me.Font.TextWidth($hColumns[iCol].Text) + $iPadding * 2 + If($bSorted, 16, 0)
  
  fTime = Timer
  
  For J = 0 To $hRows.Max Step 10000
    
    For I = J To Min($hRows.Max, J + 9999)
    
      hData = _GetCellData(I, iCol)
      
      If HasSpan(I, iCol) Then
        iColSpan = _GetSpan(I, iCol)[1]
        If iColSpan < 0 Then
          hData = _GetCellData(I, iCol + iColSpan)
          iColSpan = _GetSpan(I, iCol + iColSpan)[1]
        Endif
        D = iColSpan + 1
      Else
        D = 1
      Endif
      
      With hData
        
        iPadding = Max($iPadding, .Padding)
        W = iPadding * 2
        hFont = .Font
        If Not hFont Then hFont = Me.Font
        
        If .RichText Then
          If Not .WordWrap Then W += hFont.RichTextWidth(.RichText)
        Else If .Text Then
          If Not .WordWrap Then W += hFont.TextWidth(.Text)
        Endif
        
        If .Picture Then
          W += .Picture.Width
          If .Text Or If .RichText Then W += iPadding
        Endif
        
        hBorder = .Border
        
        If hBorder Then
          With hBorder
            W += .LeftPadding + .LeftWidth + .RightPadding + .RightWidth + .LeftMargin + .RightMargin
          End With
        Endif
        
        If iCol = 0 Or If iCol = $hColumns.Max Then
          hBorder = $hRows._GetRowBorder(I)
          If hBorder Then
            With hBorder
              If iCol = 0 Then W += .LeftPadding + .LeftMargin + .LeftWidth
              If iCol = $hColumns.Max Then W += .RightPadding + .RightMargin + .RightWidth
            End With
          Endif
        Endif
        
        PW = Max(PW, (W + D - 1) \ D)
        
      End With
      
    Next
    
    fDiff = Timer - fTime
    'Debug fDiff
    If fDiff > 1 Then
      If Not bBusy Then
        Inc Application.Busy
        bBusy = True
      Endif
      If fDiff > 5 Then Break
    Endif
    
  Next
  
  If bBusy Then Dec Application.Busy
  
  Return PW + 2
  
End

Public Sub _GetPreferredHeight(iRow As Integer) As Integer
  
  Dim PH, H, I, J, WC As Integer
  Dim hSpan As Short[]
  Dim hData As _GridView_Data
  Dim hFont As Font
  Dim iRowSpan, iColSpan As Integer
  Dim iCol As Integer
  Dim D As Integer
  Dim iPadding As Integer
  Dim WT As Float
  Dim hBorder As Border
  Dim hTopBorder As Border
  Dim hBottomBorder As Border
  
  PH = $hRows.Height
  
  For I = 0 To $hColumns.Max
    
    iCol = I
    
    If HasSpan(iRow, iCol) Then
      hSpan = _GetSpan(iRow, iCol)
      iRowSpan = hSpan[0]
      iColSpan = hSpan[1]
      If iRowSpan < 0 Then iRow += iRowSpan
      If iColSpan < 0 Then iCol += iColSpan
      hData = _GetCellData(iRow, iCol)
      hSpan = _GetSpan(iRow, iCol)
      iRowSpan = hSpan[0]
      iColSpan = hSpan[1]
      D = iRowSpan + 1
    Else
      D = 1
      iRowSpan = 0
      iColSpan = 0
      hData = _GetCellData(iRow, iCol)
    Endif

    WC = $hColumns[iCol].W
    For J = 1 To iColSpan
      WC += $hColumns[iCol + J].Width
    Next
    
    If Not hData Then Continue
    
    With hData
      
      iPadding = Max($iPadding, .Padding)
      H = iPadding * 2
      hFont = .Font
      If Not hFont Then hFont = Me.Font
      
      WT = WC - iPadding * 2 - 2

      hBorder = $hRows._GetRowBorder(iRow)
      If hBorder Then WT -= hBorder.LeftPadding + hBorder.RightPadding + hBorder.LeftMargin + hBorder.RightMargin + hBorder.LeftWidth + hBorder.RightWidth
      hBorder = .Border
      If hBorder Then WT -= hBorder.LeftPadding + hBorder.RightPadding + hBorder.LeftMargin + hBorder.RightMargin + hBorder.LeftWidth + hBorder.RightWidth
      
      If .RichText Then
        If .WordWrap Then
          H += hFont.RichTextHeight(.RichText, WT)
        Else
          H += hFont.RichTextHeight(.RichText)
        Endif
      Else If .Text Then
        If .WordWrap Then
          H += hFont.RichTextHeight(Replace(Html(.Text), "\n", "<br>"), WT)
        Else
          H += hFont.TextHeight(.Text)
        Endif
      Endif
      
      If .Picture Then
        H = Max(.Picture.H + iPadding * 2, H)
      Endif
      
      hBorder = $hRows._GetRowBorder(iRow)
      If iRow > 0 Then hTopBorder = $hRows._GetRowBorder(iRow - 1)
      If iRow < $hRows.Max Then hBottomBorder = $hRows._GetRowBorder(iRow + 1)
      
      If hBorder Then
        With hBorder
          H += .TopPadding + .TopWidth + .BottomPadding + .BottomWidth + .TopMargin + .BottomMargin
          If hTopBorder Then H = H - .TopMargin + Max(.TopMargin, hTopBorder.BottomMargin) / 2
          If hBottomBorder Then H = H - .BottomMargin + Max(.BottomMargin, hBottomBorder.TopMargin) / 2
        End With
      Endif
      
      hBorder = .Border
      
      If hBorder Then
        With hBorder
          H += .TopPadding + .TopWidth + .BottomPadding + .BottomWidth + .TopMargin + .BottomMargin
        End With
      Endif
      
      PH = Max(PH, (H + D - 1) \ D)
      
    End With
    
  Next
  
  Return PH
  
End

Public Sub _RaiseRowResize(iRow As Integer)
  
  Raise RowResize(iRow)
  
End

Public Sub _RaiseColumnResize(iCol As Integer)
  
  Raise ColumnResize(iCol)
  
End

Public Sub _RaiseSort()
  
  Raise Sort
  
End


Private Function Sorted_Read() As Boolean

  Return $bSorted

End

Private Sub Sorted_Write(Value As Boolean)

  $bSorted = Value
  If Not $bSorted Then
    $hColumns.Sort = -1
  Else
    $hColumns.Sort = 0
    $hColumns.Ascending = True
  Endif
  
  Me.Refresh

End

Public Sub Scroll(X As Integer, Y As Integer)
  
  $hView.Scroll(X, Y)
  
End

Public Sub _RaiseColumnSize(iCol As Integer) As Boolean

  Dim bCancel As Boolean
  
  If Not Object.CanRaise(Me, "ColumnSize") Then Return True
  bCancel = Raise ColumnSize(iCol)
  Return bCancel
  
End

Public Sub _RaiseRowSize(iRow As Integer) As Boolean

  Dim bCancel As Boolean
  
  If Not Object.CanRaise(Me, "RowSize") Then Return True
  bCancel = Raise RowSize(iRow)
  Return bCancel
  
End

Private Function Background_Read() As Integer

  Return $iBg

End

Private Sub Background_Write(Value As Integer)

  If $iBg = Value Then Return
  $iBg = Value
  $hView.Background = Value
  $hView.Refresh

End

Public Sub GridViewClick_MouseDown()
  
  If $bInCell Then Raise Click
  
End

Private Function Padding_Read() As Integer

  Return $iPadding

End

Private Sub Padding_Write(Value As Integer)

  If $iPadding = Value Then Return
  $iPadding = Value
  ScrollArea_Arrange
  $hView.Refresh

End

Public Sub ScrollArea_Font()
  
  'Debug Me.Name
  $iTextHeight = 0
  $hColumns._Layout
  '$hRows._Clear
  _ResizeContents
  Raise Font
  
End

Public Sub _RefreshRow(iRow As Integer)
  
  $hView.RefreshRect(0, $hRows._GetRowY(iRow), $hView.ScrollW, $hRows._GetRowHeight(iRow))
  
End

Public Sub AddColumn(Text As String, Optional Width As Integer, Alignment As Integer = Align.Normal) As _GridView_Column
  
  Dim hCol As _GridView_Column
  
  Inc $hColumns.Count
  
  hCol = $hColumns[$hColumns.Max]
  hCol.Text = Text
  If Width < 0 Then
    hCol.Expand = True
  Else If Width Then
    hCol.Width = Width
  Endif
  hCol.Alignment = Alignment
  
  Return hCol
  
End

