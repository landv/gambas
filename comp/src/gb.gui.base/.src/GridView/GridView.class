' Gambas class file

Export

Inherits UserControl

Public Const _Properties As String = "*,Border=True,Mode{Select.None;Single;Multiple}=None,Grid=True,ShowCursor=False,Header{GridView.None;Horizontal;Vertical;Both}=None,ScrollBar{Scroll.*}=Both,AutoResize=True,Resizable=True,Sorted"
Public Const _Group As String = "View"
Public Const _DefaultEvent As String = "Click"

Public Enum None, Horizontal, Vertical, Both

Property Background As Integer
Property Read Rows As _GridView_Rows
Property Read Columns As _GridView_Columns
Property Border As Boolean
Property Grid As Boolean
Property Mode As Integer
Property Read Data As _GridView_Data
Property Row As Integer
Property Column As Integer
Property Resizable As Boolean
Property ScrollBar As Integer
Property AutoResize As Boolean
Property Header As Integer
Property ShowCursor As Boolean
Property Read Current As _GridView_Cell
Property Font As Font
Property Sorted As Boolean

Property ScrollX As Integer
Property ScrollY As Integer
Property Read ScrollW, ScrollWidth As Integer
Property Read ScrollH, ScrollHeight As Integer

Property Read ClientX As Integer
Property Read ClientY As Integer
Property Read ClientW, ClientWidth As Integer
Property Read ClientH, ClientHeight As Integer

Event Data(Row As Integer, Column As Integer)
Event Change
Event Select
Event Click
Event Activate
Event Scroll

Event ColumnClick(Column As Integer)
Event ColumnResize(Column As Integer)
Event ColumnSize(Column As Integer)

Event RowClick(Row As Integer)
Event RowResize(Row As Integer)
Event RowSize(Row As Integer)

'Event MouseDown
Event Sort
Event Draw(X As Integer, Y As Integer, Width As Integer, Height As Integer, Row As Integer, Column As Integer)

Private $hView As ScrollArea
Private $bGrid As Boolean = True
Private $iMode As Integer
Private $iHeader As Integer
Private $bShowCursor As Boolean
Private $bAutoResize As Boolean = True
Private $iDefaultMouse As Integer '= Mouse.Default

Private $iRow As Integer
Private $iCol As Integer

Private $hRows As _GridView_Rows
Private $hColumns As _GridView_Columns

Private $iFirstRow As Integer
Private $aRowY As New Integer[]

Private $cCells As New Collection
Private $hData As _GridView_Data

Private $cSpan As New Collection

Private $bResize As Boolean
Private $iRowResize As Integer = -1
Private $iColResize As Integer = -1
Private $iDimResize As Integer

Private $bMoveSelect As Boolean
Private $bMoveUnSelect As Boolean
Private $iMoveSelectRow As Integer = -1
Private $hMoveOldSelection As GridViewSelection
Private $bKeyEvent As Boolean
Private $bIgnoreMove As Boolean

Private $MX As Integer
Private $MY As Integer
Private $SX As Integer
Private $SY As Integer
Private $hTimerScroll As Timer

Private $bInCell As Boolean
Private $bInRow As Boolean

Private $hTimerEnsureVisible As Timer
Private $iRowEV As Integer = -1
Private $iColEV As Integer = -1

Private $bSorted As Boolean

Private $bHasDrawEvent As Boolean

Private $hObsClick As Observer

Public Sub _new()
  
  $hRows = New _GridView_Rows As "Rows"
  $hColumns = New _GridView_Columns As "Columns"
  
  $hView = New ScrollArea(Me) As "ScrollArea"
  $hView.Background = Color.TextBackground
  $hView.Focus = True
  $hView.Tracking = True
  $hView.ScrollBar = Scroll.Both
  
  $bGrid = True
  $iRow = -1
  $iCol = 0
  
  Me.Proxy = $hView
  
  $hObsClick = New Observer(Me, True) As "GridViewClick"
  
End

' Public Sub _attach(Parent As Object, EventName As String)
'   
'   If Parent Then
'     $bHasDrawEvent = Object.CanRaise(Me, "Draw")
'   Endif
'   
' End


Private Sub GetCellKey(iRow As Integer, iCol As Integer) As String
  
  If iRow >= iCol Then
    Return CLong(iRow) * iRow + iCol * 2
  Else
    Return CLong(iCol) * iCol + iRow * 2 + 1
  Endif
  
End


Private Function Rows_Read() As _GridView_Rows

  Return $hRows

End

Private Function Columns_Read() As _GridView_Columns

  Return $hColumns

End

Public Sub _IsRowSelected(iRow As Integer) As Boolean
  
  Select Case $iMode
    Case Select.None
      Return
    Case Select.Single
      Return iRow = $iRow
    Case Select.Multiple
      Return $hRows._IsSelected(iRow)
  End Select
  
End

Private Sub DrawAlignedPicture(hPict As Picture, X As Integer, Y As Integer, W As Integer, H As Integer, A As Integer)
  
  If Align.IsBottom(A) Then
    Y = H - hPict.H
  Else If Align.IsMiddle(A) Then
    Y = Y + (H - hPict.H) / 2
  Endif
  
  If Align.IsRight(A) Then
    X = W - hPict.W
  Else If Align.IsCenter(A) Then
    X = X + (W - hPict.W) / 2
  Endif
  
  Paint.DrawPicture(hPict, X, Y)
  
End


Private Sub DrawCell(X As Integer, Y As Integer, W As Integer, H As Integer, (iRow) As Integer, iCol As Integer, hData As _GridView_Data)

  Dim hRect As Rect = Rect(X, Y, W, H)
  Dim hPict As Picture
  Dim A As Integer
  Dim iColor As Integer
  Dim bCancel As Boolean

  Draw.Save
  
  With hData

    iColor = .Background
    If iColor = Color.Default Then 
      iColor = $hColumns[iCol].Background
      If iColor = Color.Default Then
        iColor = Me.Background
        If iColor = Color.Default Then
          iColor = Color.TextBackground
        Endif
      Endif
    Endif
    
    Draw.FillRect(X, Y, W, H, iColor)
    
    If .Padding Then
      X += .Padding
      Y += .Padding
      W -= .Padding * 2
      H -= .Padding * 2
    Endif
    
    If W > 0 And If H > 0 Then
      
      If .Foreground = Color.Default Then
        Draw.Foreground = Me.Foreground
      Else
        Draw.Foreground = .Foreground
      Endif
      
      If .Font Then Draw.Font = .Font

      If $bHasDrawEvent Then
        bCancel = Raise Draw(X, Y, W, H, iRow, iCol)
        If bCancel Then Goto DRAW_GRID
      Endif
      
      hPict = .Picture
  
      If hPict Then
      
        If Not .Text And If Not .RichText Then
          
          DrawAlignedPicture(hPict, X, Y, W, H, .Alignment)
          
        Else
          
          If Align.IsMiddle(A) Then
            A = Align.Normal
          Else If Align.IsTop(A) Then
            A = Align.TopNormal
          Else If Align.IsBottom(A) Then
            A = Align.BottomNormal
          End If
        
          DrawAlignedPicture(hPict, X, Y, W, H, A)
          
          W -= hPict.W + .Padding
          If Not System.RightToLeft Then X += hPict.W + .Padding
          
        Endif
        
        If W <= 0 Then Goto DRAW_GRID
        
      Endif
        
      If .Text Then
        If .WordWrap Then
          Draw.RichText(Html(.Text), X, Y, W, H, .Alignment)
        Else
          Draw.Text(.Text, X, Y, W, H, .Alignment)
        Endif
      Else If .RichText Then
        If .WordWrap Then
          Draw.RichText(.RichText, X, Y, W, H, .Alignment)
        Else
          A = .Alignment
          If Align.IsLeft(A) Then
            Draw.RichText(.RichText, X, Y, 4096, H, .Alignment)
          Else If Align.IsRight(A) Then
            Draw.RichText(.RichText, X + W - 4096, Y, 4096, H, .Alignment)
          Else
            Draw.RichText(.RichText, X + W \ 2 - 4096, Y, 4096, H, .Alignment)
          Endif
        Endif
      Endif
      
    Endif
    
  End With
  
DRAW_GRID:

  If $bGrid Then
    Draw.Foreground = Color.Merge(Color.LightForeground, $hView.Background)
    Draw.Line(hRect.X + hRect.W - 1, hRect.Y, hRect.X + hRect.W - 1, hRect.Y + hRect.H - 1)
    Draw.Line(hRect.X, hRect.Y + hRect.H - 1, hRect.X + hRect.W - 1, hRect.Y + hRect.H - 1)
  Endif
  
  Draw.Restore

End

Public Sub ScrollArea_Draw()
  
  Dim I, J, R, C, WA As Integer
  Dim XO, YO, XX, YY, X, Y, W, H As Integer
  Dim iRow, iRow2, iCol, iCol2 As Integer
  Dim hClip, hSaveClip As Rect
  Dim hRect As Rect
  Dim hData As _GridView_Data
  Dim F As Integer = _GetFrameWidth()
  Dim iGrid As Integer
  Dim aSpan As Short[]
  Dim bHasSpan As Boolean
  Dim iRowSpan, iColSpan As Integer
  Dim hSpan, hCursor As Rect
  Dim XS, YS As Integer
  Dim iSort As Integer
  Dim bAscent As Boolean
  Dim iStepCol As Integer
  
  'Debug Me.Font.ToString();; Draw.Font.ToString()
  
  If $hColumns.Count = 0 And If $hRows.Count = 0 Then Return
  
  iCol = $hColumns._FindColumnFromPos($hView.ScrollX)
  iRow = $hRows._FindRowFromPos($hView.ScrollY)
  iCol2 = -1
  iRow2 = -1
  
  iStepCol = If(System.RightToLeft, -1, 1)
  
  XO = $hRows.Width - $hView.ScrollX + F
  XX = XO + $hColumns[iCol].X
  YO = $hColumns.Height - $hView.ScrollY + F
  YY = YO + $hRows._GetRowY(iRow)
  
  If $bGrid Then
    iGrid = Color.Merge(Color.LightForeground, Color.TextBackground)
  Else
    iGrid = Color.Merge(Color.LightForeground, Color.ButtonBackground)
  Endif
  
  hClip = Draw.ClipRect
  
  ' Headers use button colors
  
  Draw.Foreground = Color.ButtonForeground
  
  ' Vertical header
  
  iSort = $hColumns.Sort
  bAscent = $hColumns.Ascending
  
  H = $hColumns.Height + F
  If $iHeader And Horizontal Then Draw.FillRect(0, 0, Draw.W, H, Color.ButtonBackground)
  X = XX
  
  If iCol >= 0 Then
    I = iCol
    Do
      If I < 0 Or If I >= $hColumns.Count Then Break
      If X >= $hView.ClientW Then Break
      iCol2 = I
      With $hColumns[I]
        If .W > 0 And If $iHeader And Horizontal Then
          Draw.ClipRect = hClip.Intersection(Rect(X - 1, F, .Width + 1, H - F))
          'If $bGrid Then Draw.FillRect(X - 1, F, 1, H - F, iGrid)
          Draw.FillRect(X - 1, F, 1, H - F, iGrid)
          If iSort = I Then
            WA = Min(16, H - F)
            Draw.Style.Arrow(X + .Width - WA, F, WA, H - F, If(bAscent, Align.Bottom, Align.Top))
            Draw.ClipRect = hClip.Intersection(Rect(X, F, Max(0, .Width - WA - 2), H - F))
            If Draw.ClipRect Then Draw.Text(.Text, X + 4, F, .Width - WA - 8, H - F, .Alignment)
          Else
            Draw.Text(.Text, X + 4, F, .Width - 8, H - F, .Alignment)
          Endif
        Endif
        X += .Width
      End With
      I += iStepCol
    Loop
  Endif

  If $iHeader And Horizontal Then 
    Draw.ClipRect = hClip
    If $bGrid Then Draw.FillRect(X - 1, F, 1, H - F, iGrid)
  Endif
    
  ' Horizontal header

  $iFirstRow = iRow
  $aRowY.Clear

  W = $hRows.Width + F
  If $iHeader And Vertical Then Draw.FillRect(0, 0, W, Draw.H, Color.ButtonBackground)
  Y = YY
  
  If iRow >= 0 Then
    For I = iRow To $hRows.Count - 1
      
      If Y >= $hView.ClientH Then Break
      $aRowY.Add(Y - F)
      iRow2 = I
      'Draw.Style.Separator(F, Y, W - F, 2)
      H = $hRows._GetRowHeight(I)
      If H > 0 And If $iHeader And Vertical Then
        Draw.FillRect(F, Y - 1, W - F, 1, iGrid)
        Draw.ClipRect = hClip.Intersection(Rect(F, Y, W - F, H))
        If I = $iRow Then Draw.Font.Bold = True
        Draw.Text($hRows._GetRowText(I), F, Y + 2, W - F, H - 2, Align.Center)
        If I = $iRow Then Draw.Font.Bold = False
      Endif
      
      'Draw.Style.Handle(W - 2, Y, 2, H, True)
      Y += H
    Next
  Endif

  $aRowY.Add(Y - F)
  If $iHeader And Vertical Then 
    Draw.ClipRect = hClip
    If $bGrid Then Draw.FillRect(F, Y - 1, W - F, 1, iGrid)
  Endif

  ' Top-left frame
  
  If $iHeader = Both Then Draw.FillRect(0, 0, $hRows.Width + F, $hColumns.Height + F, Color.ButtonBackground)
  
  ' Header limits
  
  If $iHeader And Horizontal Then Draw.FillRect(0, $hColumns.Height + F - 1, $hView.ClientW, 1, Color.Merge(Color.LightForeground, Color.ButtonBackground))
  If $iHeader And Vertical Then Draw.FillRect($hRows.Width + F - 1, 0, 1, $hView.ClientH, Color.Merge(Color.LightForeground, Color.ButtonBackground))
  
  If $hColumns.Count = 0 Or If $hRows.Count = 0 Then Return
  If iRow < 0 Or If iRow2 < 0 Then Return
  
  ' Cells
  
  hRect = New Rect($hView.ClientX, $hView.ClientY, $hView.ClientW, $hView.ClientH)
  hRect.Adjust(F)
  hRect.Adjust($hRows.Width, $hColumns.Height, 0, 0)
  hClip = hRect.Intersection(Draw.ClipRect)
  If Not hClip Then Return
  
  $bHasDrawEvent = Object.CanRaise(Me, "Draw")
  
  hSaveClip = hClip.Copy()
  Draw.ClipRect = hClip
  
  Y = YY
  
  For I = iRow To iRow2

    H = $aRowY[I - iRow + 1] + F - Y
    X = XX
    
    For J = iCol To iCol2 Step iStepCol
      
      W = $hColumns[J].Width
      
      R = I
      C = J
      
      bHasSpan = HasSpan(I, J)
      
      If bHasSpan Then
        
        aSpan = _GetSpan(I, J)
        iRowSpan = aSpan[0]
        iColSpan = aSpan[1]
        
        'Draw.ClipRect = hClip
        'Draw.Foreground = Color.Green
        'Draw.Text(iRowSpan & " / " & iColSpan, X, Y, $hColumns[J].Width, H, Align.Center)
        
        If iRowSpan < 0 Then R += iRowSpan
        If iColSpan < 0 Then C += iColSpan

        If (iRowSpan < 0 Or iColSpan < 0) And If R >= iRow And If C >= iCol Then Goto NEXT_CELL

        aSpan = _GetSpan(R, C)
        iRowSpan = aSpan[0]
        iColSpan = aSpan[1]
        
      ' Else
      '   
      '   iRowSpan = 0
      '   iColSpan = 0
        
        ' Draw.ClipRect = hClip
        ' Draw.Foreground = Color.Green
        ' Draw.Text(iRowSpan & " / " & iColSpan, X, Y, $hColumns[J].Width, H, Align.Center)
        
      Endif
      
      If bHasSpan Then
      
        XS = XO + $hColumns[C].X
        YS = YO + $hRows._GetRowY(R)
        hSpan = Rect(XS, YS, XO + $hColumns[C + iColSpan].X + $hColumns[C + iColSpan].W - XS, YO + $hRows._GetRowY(R + iRowSpan) + $hRows._GetRowHeight(R + iRowSpan) - YS)
        
      Else
      
        hSpan = Rect(X, Y, W, H)
        
      Endif
      
      Draw.ClipRect = hClip.Intersection(hSpan)
      If Draw.ClipRect Then 
        hData = _GetCellData(R, C)
        DrawCell(hSpan.X, hSpan.Y, hSpan.W, hSpan.H, R, C, hData)
      Endif
      
    NEXT_CELL:
      
      If I = $iRow And If J = $iCol Then
        hCursor = Rect(X, Y, Max(0, W - 1), Max(0, H - 1))
        ' Paint.Begin(Draw.Device)
        ' Paint.ClipRect = hClip
        ' Paint.Brush = Paint.Color(Color.SetAlpha(Color.SelectedBackground, 192))
        ' Paint.Rectangle(X, Y, W, H)
        ' Paint.Stroke
        ' Paint.End
      Endif
      
      X += W
      
    Next
    
    Y += H
    
  Next
  
  If hCursor Then
    If $bShowCursor Then
      Draw.ClipRect = hClip
      Draw.Foreground = iGrid 'Color.LightForeground
      Draw.Rect(hCursor.X, hCursor.Y, hCursor.W, hCursor.H)
    Endif
  Endif
  
  $hData = Null

  ' Sorted column
  
  If $bSorted And If $hColumns.Count > 1 And If iSort >= 0 And If iSort < $hColumns.Count Then
    
    'Paint.Begin(Draw.Device)
    Paint.ClipRect = hClip
    Paint.Brush = Paint.Color(Color.SetAlpha(Color.LightForeground, 224))
    
    With $hColumns[iSort]
    
      Paint.Rectangle(XO + .X, $hColumns.H + F, .W, $hView.ClientH - $hColumns.H - F * 2)
      Paint.Fill
    
    End With

    'Paint.End
    
  Endif

  ' Row selection

  If $iMode Then

    Y = YY
    X = XX
    
    'Paint.Begin(Draw.Device)
    Paint.ClipRect = hSaveClip
    Paint.Brush = Paint.Color(Color.SetAlpha(Color.SelectedBackground, 192))
    
    For I = iRow To iRow2
  
      H = $aRowY[I - iRow + 1] + F - Y
      
      If _IsRowSelected(I) Then
        'Paint.Rectangle(X, Y, $hColumns._GetWidth(), H)
        Paint.Rectangle(F, Y, $hView.ClientW - F * 2, H)
        Paint.Fill
      Endif
      
      Y += H
      
    Next
    
    'Paint.End
    
  Endif
  
  ' If Me.HasFocus And If Not $hView.Border Then
  '   Draw.ClipRect = Null
  '   Draw.Foreground = Color.LightBackground 'Color.LightForeground
  '   Draw.Rect($hView.ClientX, $hView.ClientY, $hView.ClientW, $hView.ClientH)
  ' Endif

End

Private Function Border_Read() As Boolean

  Return $hView.Border

End

Private Sub Border_Write(Value As Boolean)

  If $hView.Border = Value Then Return
  $hView.Border = Value
  ScrollArea_Arrange

End

Public Sub _GetFrameWidth() As Integer
  
  If $hView.Border Then Return Style.FrameWidth
  
End


Public Sub _ResizeContents()
  
  Dim F As Integer = _GetFrameWidth()
  
  ' Debug $hRows._GetHeight(); " / "; $hRows.Count;;
  ' If $hRows.Count Then Error $hRows[0].H * $hRows.Count;
  ' Error
  
  $hView.ResizeContents($hColumns._GetWidth() + $hRows.Width + F * 2, $hRows._GetHeight() + $hColumns.Height + F * 2)
  $hView._SetShadowOffset($hColumns.H, 0, $hRows.W, 0)
  
End

Private Function Grid_Read() As Boolean

  Return $bGrid

End

Private Sub Grid_Write(Value As Boolean)

  $bGrid = Value
  $hView.Refresh

End

Private Function Mode_Read() As Integer

  Return $iMode

End

Private Sub Mode_Write(Value As Integer)

  If Value = $iMode Then Return

  Select Case Value
    Case Select.None, Select.Multiple, Select.Single
      $hRows.UnSelectAll
      $iMode = Value
  End Select

End

Public Sub ScrollArea_Enter()
  
  $iDefaultMouse = Me.Mouse
  
End

Public Sub ScrollArea_Leave()
  
  Me.Mouse = $iDefaultMouse
  
End


Public Sub ScrollArea_MouseMove()
  
  Dim I, MX, MY, X, Y, iRow, iCol As Integer
  Dim iMouse As Integer
  Dim F As Integer = _GetFrameWidth()

  If Not Me.Enabled Then Return
  If $bIgnoreMove Then Return

  If $hRows.Count = 0 And If $hColumns.Count = 0 Then Return
  
  MX = Mouse.X - F
  MY = Mouse.Y - F
  
  $bInCell = False
  $bInRow = False
  
  If $bResize Then
    If $iRowResize >= 0 Then
      $hRows._SetRowHeight($iRowResize, Max(1, $iDimResize + MY - $MY))
    Else If $iColResize >= 0 Then
      $hColumns[$iColResize].Width = Max(1, $iDimResize + MX - $MX)
    Endif
    Return
  Endif
  
  iMouse = $iDefaultMouse 'Mouse.Default
  
  $iRowResize = -1
  $iColResize = -1
  
  If MX < $hRows.Width Then
    
    If $hRows.Resizable Then
      For I = 0 To $aRowY.Max
        If MY >= ($aRowY[I] - 1) And If MY <= ($aRowY[I] + 2) Then
          If I + $iFirstRow Then
            iMouse = Mouse.SizeS
            $iRowResize = I + $iFirstRow - 1
            $iDimResize = $hRows._GetRowHeight($iRowResize)
          Endif
          Break
        Endif
      Next
    Endif
    
  Else If MY < $hColumns.Height Then
    
    If $hColumns.Resizable Then
      X = MX + $hView.ScrollX - $hRows.Width
      For I = 1 To $hColumns.Count - 1
        With $hColumns[I]
          If $hColumns[I - 1].Resizable And If X >= (.X - 1) And If X <= (.X + 2) Then
            iMouse = Mouse.SizeE
            $iColResize = I - 1
            $iDimResize = $hColumns[$iColResize].Width
            Break
          Endif
        End With
      Next
      If $iColResize < 0 And If $hColumns[$hColumns.Count - 1].Resizable And If X >= ($hColumns._GetWidth() - 1) And If X <= ($hColumns._GetWidth() + 2) Then
        iMouse = Mouse.SizeE
        $iColResize = $hColumns.Count - 1
        $iDimResize = $hColumns[$iColResize].Width
      Endif
    Endif
    
  Endif
    
  If Mouse.Button = 0 And If $hView.Mouse <> iMouse Then $hView.Mouse = iMouse
  
  If $iRowResize >= 0 Or If $iColResize >= 0 Then Return
  
  iRow = -1
  iCol = -1
  
  X = MX
  Y = MY
  $SX = X
  $SY = Y
  
  If Mouse.Left Then
    
    If Y >= $hColumns.Height Then
      For I = 1 To $aRowY.Max
        If Y < $aRowY[I] Then
          iRow = I + $iFirstRow - 1
          Break
        Endif
      Next
      If iRow < 0 Then iRow = $hRows._FindRowFromPos(Y - $hColumns.Height + $hView.ScrollY)
    Endif
    
    If X >= $hRows.W Then
      X += $hView.ScrollX - $hRows.Width
      iCol = $hColumns._FindColumnFromPos(X)
    Endif
    
  Endif
  
  If iRow >= 0 Then
    
    $bInRow = True
    
    If iCol >= 0 Then $bInCell = True
    
    MoveTo(iRow, iCol)

  Endif
    
End

Public Sub TimerScroll_Timer()
  
  Dim X As Integer = $SX - $hRows.W + $hView.ScrollX
  Dim Y As Integer = $SY - $hColumns.Height + $hView.ScrollY
  Dim iCol As Integer
  Dim iRow As Integer 
  
  If Drag.Pending Then
    $hTimerScroll.Stop
    Return
  Endif
  
  If $SX < $hRows.W Then
    iCol = -1
  Else
    iCol = $hColumns._FindColumnFromPos(X)
    If iCol < 0 Then iCol = $hColumns.Count - 1
  Endif
  
  If Y < 0 Then
    iRow = 0
  Else
    iRow = $hRows._FindRowFromPos(Y)
    If iRow < 0 Then iRow = $hRows.Count - 1
  Endif
  
  MoveTo(iRow, iCol)
  
End

Public Sub _EnsureVisibleScroll(X As Integer, Y As Integer)
  
  $hView.EnsureVisible($hView.ScrollX + X - 16 - $hColumns.W, $hView.ScrollY + Y - 16 - $hRows.H, 32, 32)
  
End


Public Sub ScrollArea_MouseDrag()
  
  If Not Me.Enabled Then Return
  
  $bIgnoreMove = False
  If $bResize Or If $bMoveSelect Then 
    Stop Event
    Return
  Endif
  
  If Not $hTimerScroll Then
    $hTimerScroll = New Timer As "TimerScroll"
    $hTimerScroll.Delay = 50
    $hTimerScroll.Start
  Endif
  
End

Public Sub ScrollArea_MouseDown()
  
  Dim I, iOldRow As Integer
  Dim bCancel As Boolean
  Dim F As Integer = _GetFrameWidth()
  
  $MX = Mouse.X - F
  $MY = Mouse.Y - F
  
  If Not Me.Enabled Then Return
  
  Me.SetFocus
  
  iOldRow = $iRow
  
  $bIgnoreMove = False

  ScrollArea_MouseMove
  
  $bIgnoreMove = True

  If $iRowResize >= 0 Or If $iColResize >= 0 Then
    $bResize = True
    Return
  Endif
  
  If $iMode = Select.Multiple Then
    If $bInRow Then
      If Mouse.Control Then
        If $hRows._IsSelected($iRow) Then
          $hRows.UnSelect($iRow, 1)
          $iMoveSelectRow = $iRow
          $hMoveOldSelection = $hRows._SaveSelection()
          $bMoveUnSelect = True
        Else
          $hRows.Select($iRow, 1)
          $iMoveSelectRow = $iRow
          $hMoveOldSelection = $hRows._SaveSelection()
          $bMoveSelect = True
        Endif
      Else If Mouse.Shift And If iOldRow >= 0 Then 
        $hRows._GetSel().UnSelectAll
        $hRows.Select(iOldRow, 1)
        $iMoveSelectRow = iOldRow
        $hMoveOldSelection = $hRows._SaveSelection()
        $bMoveSelect = True
        Dec $iRow
        MoveTo($iRow + 1, -1)
      Else If Not _IsRowSelected($iRow) Then
        $hRows._GetSel().UnSelectAll
        $hRows.Select($iRow, 1)
        $iMoveSelectRow = $iRow
        $hMoveOldSelection = $hRows._SaveSelection()
        $bMoveSelect = True
      Else
        $iMoveSelectRow = $iRow
      Endif
    Endif
  Endif
  
  If $bInCell Then
    
  Else If Mouse.X < $hRows.Width And If Mouse.Y > $hColumns.H Then
    I = $hRows._FindRowFromPos(Mouse.Y - $hColumns.Height + $hView.ScrollY)
    If I >= 0 Then 
      'bCancel = Raise MouseDown
      'If Not bCancel Then Raise RowClick(I)
      
      Raise RowClick(I)
      'Stop Event
    Endif
  Else If Mouse.Y < $hColumns.Height And If Mouse.X > $hRows.W Then
    I = $hColumns._FindColumnFromPos(Mouse.X - $hRows.Width + $hView.ScrollX)
    If I >= 0 Then 
      'bCancel = Raise MouseDown
      'If Not bCancel Then
        bCancel = Raise ColumnClick(I)
        If Not bCancel Then
          If $bSorted Then
            If $hColumns.Sort = I Then
              $hColumns.Ascending = Not $hColumns.Ascending
            Else
              $hColumns.Sort = I
              $hColumns.Ascending = True
            Endif
          Endif
        Endif
      'Endif
      'Stop Event
    Endif
  Endif
  
End

' Public Sub ScrollArea_Menu()
'   
'   Debug
'   
' End

Private Sub AfterMouseUp()
  
  $bResize = False
  $bMoveSelect = False
  $bMoveUnSelect = False
  $hMoveOldSelection = Null
  $iMoveSelectRow = -1
  $bIgnoreMove = False
  
  If $hTimerScroll Then
    $hTimerScroll.Stop
    $hTimerScroll = Null
  Endif
  
End


Public Sub ScrollArea_MouseUp()
  
  'If $iMode = Select.Multiple And $bInRow And If $iRow = $iMoveSelectRow Then
  '  If Mouse.Normal Then
  '    $hRows._GetSel().UnSelectAll
  '    $hRows.Select($iRow, 1)
  '  Endif
  'Endif
  
  AfterMouseUp
  
End

Public Sub ScrollArea_DragLeave()
  
  AfterMouseUp
  
End


Public Sub ScrollArea_DblClick()
  
  'Debug $bInCell
  
  If $bInCell Then 
    Raise Activate
  Else If $iColResize >= 0 Then
    $hColumns[$iColResize].Width = -1
  Else If $iRowResize >= 0 Then
    $hRows[$iRowResize].Height = -1
  Endif
  
End


Private Function Data_Read() As _GridView_Data

  Return $hData

End

Public Sub _CheckCell(iRow As Integer, iColumn As Integer) 
  
  If iRow < 0 Or If iRow >= $hRows.Count Then Error.Raise("Bad row index")
  If iColumn < 0 Or If iColumn >= $hColumns.Count Then Error.Raise("Bad column index")
  
End

Public Sub _CheckCurrent()
  
  MoveTo(Min($iRow, $hRows.Count - 1), Min($iCol, $hColumns.Count - 1))
  
End


Public Sub _GetCellData(iRow As Integer, iColumn As Integer, Optional bCreate As Boolean) As _GridView_Data

  Dim hData As _GridView_Data

  hData = $cCells[GetCellKey(iRow, iColumn)]
  If Not hData Then
    If bCreate Then
      hData = New _GridView_Data
      hData.Font = Me.Font
      hData.Alignment = $hColumns[iColumn].Alignment
      $cCells[GetCellKey(iRow, iColumn)] = hData
    Else
      $hData = New _GridView_Data
      $hData.Font = Me.Font
      $hData.Alignment = $hColumns[iColumn].Alignment
      Raise Data(iRow, iColumn)
      hData = $hData
    Endif
  Endif
  
  Return hData
  
End


Public Sub _get(Row As Integer, Column As Integer) As _GridView_Cell
  
  Dim hCell As _GridView_Cell
  
  hCell = New _GridView_Cell
  hCell._Row = Row
  hCell._Column = Column
  hCell._View = Me
  Return hCell
  
End

Public Sub MoveTo(Row As Integer, Column As Integer)
  
  Dim S, L As Integer
  
  If Column < 0 Then Column = $iCol
  
  If Row < 0 Then
    If $iRow < 0 Then Return
    Row = -1
  Else If Row = $iRow And If Column = $iCol Then
    Return
  Else If Row >= $hRows.Count Or If Column < 0 Or If Column >= $hColumns.Count Then
    Return
  Endif
  
  $iRow = Row
  $iCol = Column
  
  If $iRow >= 0 And If $iCol < 0 Then $iCol = 0
  
  If $iRow >= 0 And If $iCol >= 0 Then _EnsureVisible($iRow, $iCol)
  $hView.Refresh

  Raise Change
  If $iMode = Select.Single Then 
    Raise Select
  Else If $bMoveSelect Or $bMoveUnSelect Then
    $hRows._RestoreSelection($hMoveOldSelection)
    S = Min($iRow, $iMoveSelectRow)
    L = Max($iRow, $iMoveSelectRow) - Min($iRow, $iMoveSelectRow) + 1
    If $bMoveSelect Then
      $hRows.Select(S, L)
    Else
      $hRows.UnSelect(S, L)
    Endif
  Else If $bKeyEvent And If $iMode = Select.Multiple Then
    $hRows._GetSel().UnSelectAll
    $hRows.Select($iRow, 1)
  Endif
  
End

Private Function Row_Read() As Integer

  Return $iRow

End

Private Sub Row_Write(Value As Integer)

  MoveTo(Value, $iCol)

End

Private Function Column_Read() As Integer

  If $iRow < 0 Then Return -1
  Return $iCol

End

Private Sub Column_Write(Value As Integer)

  MoveTo($iRow, Value)

End


' Private Sub EnsureRowVisible(iRow As Integer)
'   
'   'Debug iRow; ": "; $hView.ScrollX, $hRows._GetRowY(iRow), $hView.ClientW, $hRows._GetRowHeight(iRow)
'   Dim F As Integer = GetFrameWidth()
'   
'   $hView.EnsureVisible($hView.ScrollX - F, $hRows._GetRowY(iRow) - F, $hView.ClientW + F * 2, $hRows._GetRowHeight(iRow) + $hColumns.Height + F * 2)
'   
' End

Public Sub _EnsureVisible(iRow As Integer, iCol As Integer)
  
  'Debug iRow;; iCol
  If Not $hTimerEnsureVisible Then $hTimerEnsureVisible = New Timer As "TimerEnsureVisible"
  If $iRowEV < 0 Then $hTimerEnsureVisible.Trigger
  
  $iRowEV = iRow
  $iColEV = iCol
  
  'Debug iRow;; iCol
  
End

Public Sub TimerEnsureVisible_Timer()
  
  Dim iRowEV As Integer = $iRowEV
  Dim F As Integer = _GetFrameWidth()
  
  $iRowEV = -1

  With $hColumns[$iColEV]
    $hView.EnsureVisible(.X, $hRows._GetRowY(iRowEV) + F, Min($hView.ClientW - $hRows.W, .Width + $hRows.Width), $hRows._GetRowHeight(iRowEV) + $hColumns.Height + F)
  End With
  
Catch
  
End

Public Sub _SelectRow(iRow As Integer, bSelect As Boolean)
  
  If $iMode = Select.Single Then
    If bSelect Then
      If $iRow <> iRow Then
        Row_Write(iRow)
      Endif
    Else If $iRow >= 0 Then
      Row_Write(-1)
    Endif
  Endif
  
End

Public Sub Clear()
  
  $cCells.Clear
  $hRows._Clear
  $iRow = -1
  $iCol = 0
  _ResizeContents
  $hView.Refresh
  
End

Public Sub _ClearCell(iRow As Integer, iCol As Integer)
  
  $cCells.Remove(GetCellKey(iRow, iCol))
  
End

Private Function Resizable_Read() As Boolean

  Return $hColumns.Resizable

End

Private Sub Resizable_Write(Value As Boolean)

  $hColumns.Resizable = Value

End

Private Function ScrollX_Read() As Integer

  Return $hView.ScrollX

End

Private Sub ScrollX_Write(Value As Integer)

  $hView.ScrollX = Value

End

Private Function ScrollY_Read() As Integer

  Return $hView.ScrollY

End

Private Sub ScrollY_Write(Value As Integer)

  $hView.ScrollY = Value

End


Private Function ScrollW_Read() As Integer

  Return $hView.ScrollW

End

Private Function ScrollH_Read() As Integer

  Return $hView.ScrollH

End

Private Function ClientX_Read() As Integer

  Return $hView.ClientX + _GetFrameWidth()

End

Private Function ClientY_Read() As Integer

  Return $hView.ClientY + _GetFrameWidth()

End

Private Function ClientW_Read() As Integer

  Return $hView.ClientW - _GetFrameWidth() * 2

End

Private Function ClientH_Read() As Integer

  Return $hView.ClientH - _GetFrameWidth() * 2

End

Public Sub ScrollArea_Scroll()
  
  Raise Scroll
  
End

Public Sub _RaiseSelect()
  
  $hView.Refresh
  Raise Select
  
End

Public Sub Select(Optional Start As Integer = 0, Optional Length As Integer = -1)
  
  $hRows.Select(Start, Length)
  
End

Public Sub SelectAll()
  
  $hRows.SelectAll
  
End

Public Sub UnselectAll()
  
  $hRows.UnSelectAll
  
End

Private Function Scrollbar_Read() As Integer

  Return $hView.ScrollBar

End

Private Sub Scrollbar_Write(Value As Integer)

  $hView.ScrollBar = Value

End

Private Function AutoResize_Read() As Boolean

  Return $bAutoResize

End

Private Sub AutoResize_Write(Value As Boolean)

  $bAutoResize = Value
  $hColumns._Layout

End

Private Function Header_Read() As Integer

  Return $iHeader

End

Private Sub Header_Write(Value As Integer)

  Value = Value And 3

  $iHeader = Value
  $hColumns._Layout
  $hView.Refresh

End

Public Sub ScrollArea_KeyPress()
  
  Dim iRow As Integer
  Dim bStop As Boolean
  
  $bKeyEvent = True
  
  If $iMode = Select.Multiple Then
    $bMoveSelect = Key.Shift
    If $bMoveSelect And If $iMoveSelectRow < 0 Then
      $iMoveSelectRow = $iRow
      $hMoveOldSelection = $hRows._SaveSelection()
    Endif
  Endif
  
  Select Key.Code
    
    Case Key.Up, Key.Down, Key.Left, Key.Right, Key.Home, Key.End, Key.PageUp, Key.PageDown
      bStop = Raise KeyPress
      If bStop Then 
        Stop Event
        Goto _RETURN
      Endif
    
  End Select
  
  Select Key.Code
    
    Case Key.Up
      If $iRow > 0 Then MoveTo($iRow - 1, $iCol)
      Stop Event
      
    Case Key.Down
      If $iRow < ($hRows.Count - 1) Then MoveTo($iRow + 1, $iCol)
      Stop Event
      
    Case Key.Left
      If $iRow >= 0 Then
        If $iCol > 0 Then
          MoveTo($iRow, $iCol - 1)
        Else If $iRow > 0 Then
          MoveTo($iRow - 1, $hColumns.Count - 1)
        Endif
      Endif
      Stop Event
    
    Case Key.Right
      If $iRow >= 0 Then
        If $iCol < ($hColumns.Count - 1) Then 
          MoveTo($iRow, $iCol + 1)
        Else If $iRow < ($hRows.Count - 1) Then
          MoveTo($iRow + 1, 0)
        Endif
      Endif
      Stop Event
    
    Case Key.Home
      If Key.Control Or If Not $bShowCursor Then
        MoveTo(0, 0)
      Else
        MoveTo($iRow, 0)
      Endif
      Stop Event
    
    Case Key.End
      If Key.Control Or If Not $bShowCursor Then
        MoveTo($hRows.Count - 1, $hColumns.Count - 1)
      Else
        MoveTo($iRow, $hColumns.Count - 1)
      Endif
      Stop Event
      
    Case Key.PageUp
      iRow = $hRows._FindRowFromPos($hRows._GetRowY($iRow) + $hRows._GetRowHeight($iRow) - ($hView.ClientH - $hColumns.H - _GetFrameWidth() * 2))
      If iRow >= 0 Then 
        MoveTo(iRow, $iCol)
      Else
        MoveTo(0, $iCol)
      Endif
      Stop Event
      
    Case Key.PageDown
      iRow = $hRows._FindRowFromPos($hRows._GetRowY($iRow) + $hView.ClientH - $hColumns.H - _GetFrameWidth() * 2)
      If iRow >= 0 Then 
        MoveTo(iRow, $iCol)
      Else
        MoveTo($hRows.Count - 1, $iCol)
      Endif
      Stop Event
    
  End Select

_RETURN:

  $bKeyEvent = False
  
End

Private Sub MakeSpan(iRowSpan As Integer, iColSpan As Integer) As Integer
  
  Return Lsl(iRowSpan, 16) Or (iColSpan And &HFFFF&)
  
End

Private Sub UnmakeSpan(iSpan As Integer) As Short[]
  
  Return [CShort(Lsr(iSpan, 16)), CShort(iSpan And &HFFFF&)]
  
End


Public Sub _SetSpan(iRow As Integer, iCol As Integer, iRowSpan As Integer, iColSpan As Integer)
  
  Dim aOldSpan As Short[]
  Dim iOldRowSpan As Integer
  Dim iOldColSpan As Integer
  Dim I, J As Integer
  
  If iRow < 0 Or If iCol < 0 Or If iRow >= $hRows.Count Or If iCol >= $hColumns.Count Then Return
  
  If iRowSpan < -32768 Or If iRowSpan > 32767 Then Return
  If iColSpan < -32768 Or If iColSpan > 32767 Then Return

  If iRowSpan > 0 And If iColSpan < 0 Then iColSpan = 0
  If iColSpan > 0 And If iRowSpan < 0 Then iRowSpan = 0
  
  aOldSpan = _GetSpan(iRow, iCol)
  iOldRowSpan = aOldSpan[0]
  iOldColSpan = aOldSpan[1]
  
  If (iOldRowSpan < 0 Or iOldColSpan < 0) And If (iRowSpan <> 0 Or iColSpan <> 0) Then Return
  
  $cSpan.Remove(GetCellKey(iRow, iCol))
  
  If iOldColSpan > 0 Or If iOldRowSpan > 0 Then
    
    I = 1
    J = 0
    Do
      If I > iOldColSpan Then
        I = 0
        Inc J
        If J > iOldRowSpan Then Break
      Endif
      _SetSpan(iCol + I, iRow + J, 0, 0)
      Inc I
    Loop
    
  Endif

  If iRowSpan = 0 And If iColSpan = 0 Then Return
  
  $cSpan[GetCellKey(iRow, iCol)] = MakeSpan(iRowSpan, iColSpan)
  
  If iRowSpan >= 0 And If iColSpan >= 0 Then
    
    For I = 0 To iRowSpan
      For J = 0 To iColSpan
        If I = 0 And If J = 0 Then Continue
        _SetSpan(iRow + I, iCol + J, - I, - J)
      Next
    Next
    
  Endif
  
End

Private Sub HasSpan(iRow As Integer, iCol As Integer) As Boolean
  
  Return $cSpan.Exist(GetCellKey(iRow, iCol))
  
End


Public Sub _GetSpan(iRow As Integer, iCol As Integer) As Short[]
  
  Dim aSpan As New Short[2]
  Dim iSpan As Integer
  
  If iRow < 0 Or If iCol < 0 Or If iRow >= $hRows.Count Or If iCol >= $hColumns.Count Then Return aSpan
  Try iSpan = $cSpan[GetCellKey(iRow, iCol)]
  If iSpan = 0 Then Return aSpan
  aSpan = UnmakeSpan(iSpan)
  aSpan[0] = Min(aSpan[0], $hRows.Count - iRow - 1)
  aSpan[1] = Min(aSpan[1], $hColumns.Count - iCol - 1)
  Return aSpan
  
End


Private Function ShowCursor_Read() As Boolean

  Return $bShowCursor

End

Private Sub ShowCursor_Write(Value As Boolean)

  $bShowCursor = Value
  $hView.Refresh

End

Public Sub _GetCellWidth(iRow As Integer, iCol As Integer) As Integer
  
  Dim W, I As Integer

  If Not HasSpan(iRow, iCol) Then Return $hColumns[iCol].Width

  For I = iCol To iCol + Max(0, _GetSpan(iRow, iCol)[1])
    W += $hColumns[I].Width
  Next
  
  Return W
  
End

Public Sub _GetCellHeight(iRow As Integer, iCol As Integer) As Integer
  
  Dim H, I As Integer

  If Not HasSpan(iRow, iCol) Then Return $hRows._GetRowHeight(iRow)

  For I = iRow To iRow + Max(0, _GetSpan(iRow, iCol)[0])
    H += $hRows._GetRowHeight(I)
  Next
  
  Return H
  
End

Private Function Current_Read() As _GridView_Cell

  If $iRow < 0 Or If $iCol < 0 Then Return
  Return _get($iRow, $iCol)

End

Public Sub RowAt(Y As Integer) As Integer
  
  Y -= $hColumns.Height
  If Y < 0 Then Return -1
  
  Return $hRows._FindRowFromPos(Y + $hView.ScrollY)
  
End

Public Sub ColumnAt(X As Integer) As Integer
  
  X -= $hRows.Width
  If X < 0 Then Return -1
  
  Return $hColumns._FindColumnFromPos(X + $hView.ScrollX)
  
End

Public Sub _GetVisibleWidth() As Integer
  
  Return $hView.ClientW - _GetFrameWidth() * 2 - $hRows.Width
  
End

Public Sub ScrollArea_Resize()
  
  'Debug $hView.ClientW
  $hColumns.Column__Refresh
  
End

Public Sub ScrollArea_Arrange()
  
  'Debug $hView.ClientW
  $hColumns.Column__Refresh
  
End

Private Sub MoveCell(iRowSrc As Integer, iColSrc As Integer, iRowDst As Integer, iColDst As Integer)
  
  Dim S, D As String
  
  S = GetCellKey(iRowSrc, iColSrc)
  D = GetCellKey(iRowDst, iColDst)
  
  $cCells[D] = $cCells[S]
  $cCells[S] = Null
  
  ' If HasSpan(iRowSrc, iColSrc) Then
  '   aSpan = _GetSpan(iRowSrc, iColSrc)
  '   _SetSpan(iRowSrc, iColSrc, 0, 0)
  '   _SetSpan(iRowDst, iColDst, aSpan[0], aSpan[1])
  ' Endif
  
End


Public Sub _RemoveRows(Start As Integer, Length As Integer)
  
  Dim I, J, D As Integer
  
  If Start < 0 Or If Start >= $hRows.Count Or Length <= 0 Or (Start + Length) > $hRows.Count Then Error.Raise("Bad argument")
  
  D = Start
  
  'For J = 0 To $hColumns.Max
  '  _SetSpan(D, J, 0, 0)
  'Next
  
  For I = Start + Length To $hRows.Max
    For J = 0 To $hColumns.Max
      MoveCell(I, J, D, J)
    Next
    Inc D
  Next
  
  $hRows.Count -= Length
  
End

Public Sub _InsertRows(Start As Integer, Length As Integer)
  
  Dim I, J As Integer
  
  If Start < 0 Or If Length <= 0 Or If Start > $hRows.Count Then Error.Raise("Bad argument")
  
  For I = $hRows.Max DownTo Start
    For J = 0 To $hColumns.Max
      MoveCell(I, J, I + Length, J)
    Next
  Next
  
  $hRows.Count += Length
  
End
' 

Private Function Font_Read() As Font

  Return Super.Font

End

Private Sub Font_Write(Value As Font)

  Super.Font = Value
  _ResizeContents

End

' Private Function Mouse_Read() As Integer
' 
'   Return Super.Mouse
' 
' End
' 
' Private Sub Mouse_Write(Value As Integer)
' 
'   Super.Mouse = Value
'   $iDefaultMouse = Value
' 
' End

Public Sub _GetPreferredWidth(iCol As Integer) As Integer
  
  Dim PW, W, I As Integer
  Dim hData As _GridView_Data
  Dim hFont As Font
  Dim iColSpan As Integer
  Dim D As Integer
  
  PW = Me.Font.TextWidth($hColumns[iCol].Text) + 8 + If($bSorted, 16, 0)
  
  I = Max(0, $hRows._FindRowFromPos($hView.ScrollY))
  For I = I To Min(1000 + I, $hRows.Max)
    
    hData = _GetCellData(I, iCol)
    
    If HasSpan(I, iCol) Then
      iColSpan = _GetSpan(I, iCol)[1]
      If iColSpan < 0 Then
        hData = _GetCellData(I, iCol + iColSpan)
        iColSpan = _GetSpan(I, iCol + iColSpan)[1]
      Endif
      D = iColSpan + 1
    Else
      D = 1
    Endif
    
    With hData
      
      W = Max(8, .Padding * 2)
      hFont = .Font
      If Not hFont Then hFont = Me.Font
      
      If .RichText Then
        If Not .WordWrap Then W += hFont.RichTextWidth(.RichText)
      Else If .Text Then
        If Not .WordWrap Then W += hFont.TextWidth(.Text)
      Endif
      
      If .Picture Then
        W += .Picture.Width
        If .Text Or If .RichText Then W += .Padding
      Endif
      
      PW = Max(PW, (W + D - 1) \ D)
      
    End With
    
  Next
  
  Return PW
  
End

Public Sub _GetPreferredHeight(iRow As Integer) As Integer
  
  Dim PH, H, I, J, WC As Integer
  Dim hSpan As Short[]
  Dim hData As _GridView_Data
  Dim hFont As Font
  Dim iRowSpan, iColSpan As Integer
  Dim iCol As Integer
  Dim D As Integer
  
  PH = $hRows.Height
  
  For I = 0 To $hColumns.Max
    
    iCol = I
    
    If HasSpan(iRow, iCol) Then
      hSpan = _GetSpan(iRow, iCol)
      iRowSpan = hSpan[0]
      iColSpan = hSpan[1]
      If iRowSpan < 0 Then iRow += iRowSpan
      If iColSpan < 0 Then iCol += iColSpan
      hData = _GetCellData(iRow, iCol)
      hSpan = _GetSpan(iRow, iCol)
      iRowSpan = hSpan[0]
      iColSpan = hSpan[1]
      D = iRowSpan + 1
    Else
      D = 1
      iRowSpan = 0
      iColSpan = 0
      hData = _GetCellData(iRow, iCol)
    Endif

    WC = $hColumns[iCol].W
    For J = 1 To iColSpan
      WC += $hColumns[iCol + J].Width
    Next
    
    With hData
      
      H = Max(4, .Padding * 2)
      hFont = .Font
      If Not hFont Then hFont = Me.Font
      
      If .RichText Then
        If .WordWrap Then
          H += hFont.RichTextHeight(.RichText, WC - .Padding * 2)
        Else
          H += hFont.RichTextHeight(.RichText)
        Endif
      Else If .Text Then
        If .WordWrap Then
          H += hFont.RichTextHeight(Html(.Text), WC - .Padding * 2)
        Else
          H += hFont.TextHeight(.Text)
        Endif
      Endif
      
      If .Picture Then
        H = Max(.Picture.H + .Padding * 2, H)
      Endif
      
      PH = Max(PH, (H + D - 1) \ D)
      
    End With
    
  Next
  
  Return PH
  
End

Public Sub _RaiseRowResize(iRow As Integer)
  
  Raise RowResize(iRow)
  
End

Public Sub _RaiseColumnResize(iCol As Integer)
  
  Raise ColumnResize(iCol)
  
End

Public Sub _RaiseSort()
  
  Raise Sort
  
End


Private Function Sorted_Read() As Boolean

  Return $bSorted

End

Private Sub Sorted_Write(Value As Boolean)

  $bSorted = Value
  If Not $bSorted Then
    $hColumns.Sort = -1
  Else
    $hColumns.Sort = 0
    $hColumns.Ascending = True
  Endif
  
  Me.Refresh

End

Public Sub Scroll(X As Integer, Y As Integer)
  
  $hView.Scroll(X, Y)
  
End

Public Sub _RaiseColumnSize(iCol As Integer) As Boolean

  Dim bCancel As Boolean
  
  If Not Object.CanRaise(Me, "ColumnSize") Then Return True
  bCancel = Raise ColumnSize(iCol)
  Return bCancel
  
End

Public Sub _RaiseRowSize(iRow As Integer) As Boolean

  Dim bCancel As Boolean
  
  If Not Object.CanRaise(Me, "RowSize") Then Return True
  bCancel = Raise RowSize(iRow)
  Return bCancel
  
End

Private Function Background_Read() As Integer

  Return $hView.Background

End

Private Sub Background_Write(Value As Integer)

  If Value = Color.Default Then Value = Color.TextBackground
  $hView.Background = Value

End

Public Sub GridViewClick_MouseDown()
  
  If $bInCell Then Raise Click
  
End
